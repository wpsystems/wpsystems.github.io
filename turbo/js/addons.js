(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["addons"],{

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/2d-color-picker/style.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/2d-color-picker/style.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-2dcolor-picker {\n  width: 150px;\n  height: 150px;\n  border-radius: 8px;\n  margin: 8px;\n  position: relative;\n  user-select: none;\n}\n\n.sa-2dcolor-picker-image {\n  border-radius: 8px;\n  width: 150px;\n  height: 150px;\n  user-select: none;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/block-palette-icons/userstyle.css":
/*!***************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/block-palette-icons/userstyle.css ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".scratchCategoryItemBubble {\n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: 17px 17px;\n  height: 22px;\n  width: 22px;\n}\n\n.scratchCategoryId-motion .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/motion_icon.svg */ "./src/addons/addons/block-palette-icons/icons/motion_icon.svg")) + ");\n}\n\n.scratchCategoryId-looks .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/looks_icon.svg */ "./src/addons/addons/block-palette-icons/icons/looks_icon.svg")) + ");\n}\n\n.scratchCategoryId-sound .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/sound_icon.svg */ "./src/addons/addons/block-palette-icons/icons/sound_icon.svg")) + ");\n}\n\n.scratchCategoryId-events .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/events_icon.svg */ "./src/addons/addons/block-palette-icons/icons/events_icon.svg")) + ");\n}\n\n.scratchCategoryId-control .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/control_icon.svg */ "./src/addons/addons/block-palette-icons/icons/control_icon.svg")) + ");\n}\n\n.scratchCategoryId-sensing .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/sensing_icon.svg */ "./src/addons/addons/block-palette-icons/icons/sensing_icon.svg")) + ");\n}\n\n.scratchCategoryId-operators .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/operators_icon.svg */ "./src/addons/addons/block-palette-icons/icons/operators_icon.svg")) + ");\n}\n\n.scratchCategoryId-variables .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/variables_icon.svg */ "./src/addons/addons/block-palette-icons/icons/variables_icon.svg")) + ");\n}\n\n.scratchCategoryId-lists .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/list_icon.svg */ "./src/addons/addons/block-palette-icons/icons/list_icon.svg")) + ");\n}\n\n.scratchCategoryId-myBlocks .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/block_icon.svg */ "./src/addons/addons/block-palette-icons/icons/block_icon.svg")) + ");\n}\n\n.scratchCategoryId-tw .scratchCategoryItemBubble {\n  background-image: url(" + escape(__webpack_require__(/*! ./icons/tw_icon.svg */ "./src/addons/addons/block-palette-icons/icons/tw_icon.svg")) + ");\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/clones/style.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/clones/style.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".clone-container-container {\n  display: none;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  -ms-flex-align: center;\n  align-items: center;\n  padding: 0.25rem;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  color: #a065ff;\n}\n\n.clone-container {\n  font-size: 0.625rem;\n  font-weight: bold;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  white-space: nowrap;\n}\n\n.clone-icon {\n  margin: 0.25rem;\n  display: inline-block;\n  background-image: url(" + escape(__webpack_require__(/*! ./cat.svg */ "./src/addons/addons/clones/cat.svg")) + ");\n  height: 16px;\n  width: 16px;\n}\n\n.clone-container-container[data-count=\"0\"] {\n  display: none;\n}\n\n.clone-container-container[data-count=\"300\"] {\n  color: #ff6680;\n}\n\n.clone-container-container[data-count=\"300\"] .clone-icon {\n  background-image: url(" + escape(__webpack_require__(/*! ./300cats.svg */ "./src/addons/addons/clones/300cats.svg")) + ");\n}\n\n.clone-count::after {\n  content: attr(data-str);\n}\n\n.sa-clones-small .clone-container-container {\n  display: none !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/color-picker/style.css":
/*!****************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/color-picker/style.css ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-color-picker {\n  display: flex;\n}\n\n.sa-color-picker-code {\n  margin: 8px 0;\n}\n\n.sa-color-picker-paint {\n  margin-top: 16px;\n  margin-bottom: 4px;\n}\n\n.sa-color-picker > .sa-color-picker-color {\n  border: none;\n  border-top-left-radius: 1rem;\n  border-bottom-left-radius: 1rem;\n  padding: 0;\n  padding-left: 0.6rem;\n  padding-right: 0.4rem;\n  margin-left: 0.5rem;\n  outline: none;\n  box-sizing: border-box;\n  width: 3rem;\n  height: 2rem;\n}\n[theme=\"dark\"] .sa-color-picker > .sa-color-picker-color {\n  background: var(--ui-secondary);\n}\n\n.sa-color-picker > .sa-color-picker-text {\n  box-sizing: border-box;\n  width: calc(150px - 3rem);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n[dir=\"rtl\"] .sa-color-picker > .sa-color-picker-color {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 1rem;\n  border-bottom-right-radius: 1rem;\n  margin-left: 0;\n  margin-right: 0.5rem;\n}\n\n[dir=\"rtl\"] .sa-color-picker > .sa-color-picker-text {\n  border-top-left-radius: 1rem;\n  border-bottom-left-radius: 1rem;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\nbody.sa-hide-eye-dropper-background div[class*=\"stage_color-picker-background\"] {\n  /* Do not show eye dropper background if the color picker is \"fake\" */\n  display: none;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/custom-zoom/style.css":
/*!***************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/custom-zoom/style.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-custom-zoom-area {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 60px;\n  height: 148px;\n  pointer-events: none;\n}\n.blocklyZoom > * {\n  transition: transform var(--sa-custom-zoom-speed, 0) ease-in-out;\n}\n.sa-custom-zoom-hidden > * {\n  transform: translateX(80px);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/debugger/style.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/debugger/style.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-debugger-container {\n  margin-right: 0.2rem;\n}\n\n.debug {\n  display: none;\n}\n.debug {\n  position: absolute;\n  z-index: 492;\n  background-color: white;\n  width: 400px;\n  height: 25rem;\n}\n\n.debug h1 {\n  padding: 10px;\n  cursor: move;\n  z-index: 10;\n  color: #fff !important;\n  width: calc(100% - 20px);\n  font-size: 20px;\n}\n\n.sa-debugger-unpause {\n  animation: unpauseBackground 2s infinite alternate;\n}\n@keyframes unpauseBackground /* Firefox */ {\n  0% {\n    background-color: rgba(0, 0, 0, 0.15);\n  }\n  100% {\n    background-color: rgba(0, 0, 0, 0);\n  }\n}\n.sa-debugger-unpause > img {\n  width: 20px;\n  height: 20px;\n}\n\n.log {\n  --message-border-color: rgba(0, 0, 0, 0.15);\n  --warning-border-color: hsl(50deg 100% 88%);\n  --error-border-color: hsl(0deg 100% 92%);\n  --error-text-color: red;\n  --monospace-font-size: 12px;\n  --monospace-font-family: consolas, lucida console, courier new, monospace;\n  --source-code-font-size: 12px;\n  --source-code-font-family: consolas, lucida console, courier new, monospace;\n  font-family: var(--monospace-font-family);\n  font-size: var(--monospace-font-size) !important;\n  word-wrap: break-word;\n  user-select: text;\n  box-sizing: border-box;\n  min-width: 0;\n  min-height: 0;\n  display: flex;\n  border-top: 1px solid var(--message-border-color);\n  border-bottom: 1px solid var(--message-border-color);\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  flex: auto;\n  line-height: 1.2;\n  border-top-right-radius: revert;\n  border-top-left-radius: revert;\n  cursor: text;\n  align-items: center;\n  padding: 3px;\n  color: #575e75;\n  content-visibility: auto;\n  contain-intrinsic-size: 1.2rem;\n}\n.warn {\n  border-color: var(--warning-border-color);\n  color: hsl(39deg 100% 18%);\n  background-color: hsl(50deg 100% 95%);\n}\n.error {\n  border-color: var(--error-border-color);\n  color: var(--error-text-color);\n  background-color: hsl(0deg 100% 95%);\n}\n.log:not(.warn):not(.error) + .log:not(.warn):not(.error),\n.warn + .warn,\n.error + .error {\n  border-top-color: transparent;\n}\n.logs {\n  border-radius: 0;\n  padding: 0;\n}\n.extra-log-container {\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  flex: 1;\n  cursor: default;\n  width: 100%;\n}\n.console-variable {\n  padding: 4px;\n  border-radius: 10px;\n  color: white;\n  margin-right: 5px;\n}\n.log > span:not(.console-variable) {\n  flex-grow: 1;\n}\n.log a {\n  color: inherit;\n  opacity: 0.5;\n  text-decoration: underline;\n  float: right;\n  text-align: right;\n  max-width: 100%;\n  padding-left: 4px;\n  margin-right: 4px;\n  margin-left: auto;\n}\n.log a:hover {\n  color: #4d97ff;\n  opacity: 1;\n}\n\n.logLink.deletedTarget {\n  pointer-events: none;\n}\n\n.logIcon {\n  width: 1rem;\n  height: 1rem;\n  margin: 0 0.25rem;\n}\n\n.log:not(.warn):not(.error) {\n  margin-left: 1.5rem;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/drag-drop/dragged-over.css":
/*!********************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/drag-drop/dragged-over.css ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/* Based on the `stage-selector_raised` class */\ndiv[class*=\"stage-selector_header_\"],\ndiv[class*=\"sprite-selector_sprite-selector\"],\ndiv[class*=\"sprite-info_sprite-info\"],\ndiv[class*=\"monitor_list-body\"] {\n  -webkit-transition: background-color 0.25s ease;\n  -o-transition: background-color 0.25s ease;\n  transition: background-color 0.25s ease;\n}\n.sa-dragged-over,\n.sa-dragged-over div[class*=\"stage-selector_header_\"],\n.sa-dragged-over div[class*=\"sprite-info_sprite-info\"],\n.sa-dragged-over div[class*=\"monitor_list-body\"] {\n  background-color: hsla(0, 100%, 77%, 1) !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/editor-colored-context-menus/userscript.css":
/*!*************************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/editor-colored-context-menus/userscript.css ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".u-contextmenu-colored .blocklyContextMenu {\n  background-color: var(--u-contextmenu-bg) !important;\n  border-color: #0003;\n}\n.u-contextmenu-colored .blocklyContextMenu .goog-menuitem .goog-menuitem-content {\n  color: white;\n}\n.u-contextmenu-colored .blocklyContextMenu .goog-menuitem:hover.goog-menuitem-highlight,\n.s3dev-mi:hover {\n  border-color: transparent;\n}\n.u-contextmenu-colored .blocklyContextMenu .goog-menuitem:hover {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/editor-devtools/userscript.css":
/*!************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/editor-devtools/userscript.css ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "#s3devToolBar {\n  display: flex;\n  white-space: nowrap;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n}\n\n.s3devLabel {\n  display: flex;\n  padding-right: 2em;\n}\n\n[dir=\"rtl\"] .s3devLabel {\n  padding-right: 0;\n  padding-left: 2em;\n}\n\n.s3devLabel > span:first-child {\n  margin-left: 1.5em;\n  margin-right: 1em;\n  font-weight: bold;\n  font-size: 0.625rem;\n  user-select: none;\n  cursor: default;\n  white-space: nowrap;\n  padding-top: 2px;\n}\n\n[dir=\"rtl\"] .s3devLabel > span:first-child {\n  margin-right: 1.5em;\n  margin-left: 1em;\n}\n\n.s3devAction {\n  transition: opacity 200ms ease-in;\n  /*font-weight: bold;*/\n  opacity: 0;\n}\n\n.s3devLabel:hover .s3devAction {\n  opacity: 0.7;\n}\n\n/* Wrapper around find button and drop down */\n.s3devWrap {\n  overflow: visible;\n  /*margin-left:3em;*/\n  position: relative;\n}\n\n#s3devFind {\n  height: 2rem;\n}\n\n/* Find Input Box */\ninput.s3devInp {\n  min-width: 100%;\n  box-sizing: border-box !important;\n  /* !important required for extension, because CSS injection method (and hence order) differs from addon */\n  height: 1.5rem;\n\n  /* Change Scratch default styles */\n  border-radius: 0.25rem;\n  font-size: 0.75rem;\n  padding-left: 0.4em;\n}\n[theme=\"dark\"] input.s3devInp {\n  color: #eee;\n  background: #3333;\n}\n[theme=\"dark\"] input.s3devInp:hover {\n  background: #333;\n}\n\ninput.s3devInp:focus {\n  /* Change Scratch default styles */\n  box-shadow: none;\n}\n\n/* Drop down from find button */\n#s3devDDOut {\n  top: -6px;\n}\n\n/* Drop down from find button */\ndiv.s3devDDOut {\n  z-index: 100;\n  left: 0;\n  width: 16em;\n  position: relative;\n  /*padding: 2.2em 0 0;*/\n  /*background-color: white;*/\n  padding: 4px;\n}\n\n/* Drop down from find button */\nul.s3devDD {\n  display: none;\n  position: relative;\n  padding: 0.2em 0;\n  font-size: 0.75rem;\n  line-height: 1;\n  overflow-y: auto;\n  min-height: 128px;\n  max-height: 65vh;\n  user-select: none;\n  max-width: 100%;\n}\n\ndiv.s3devDDOut.vis {\n  /*box-shadow: 0 2px 3px rgba(0,0,0,0.3), 0 5px 8px rgba(0,0,0,0.2);*/\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\n  background-color: white;\n  border: none;\n  border-radius: 4px;\n}\n[theme=\"dark\"] div.s3devDDOut.vis {\n  background-color: #111;\n}\n\ndiv.s3devDDOut.vis ul.s3devDD {\n  display: block;\n  border: none;\n}\n\n/* Drop down items */\n.s3devDD > li {\n  display: block;\n  padding: 0.5em 0.3em;\n  white-space: nowrap;\n  margin: 0;\n  font-weight: bold;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.s3devDD > li > b {\n  background-color: #aaffaa;\n  color: black;\n}\n\n/* Drop down items */\n.s3devDD > li:hover,\n.s3devDD > li.sel {\n  color: white;\n  cursor: pointer;\n}\n\n#s3devDD > li::before {\n  content: \"\\25CF   \"; /* ● */\n}\n\n.define {\n  color: rgb(255, 102, 128);\n}\n.define:hover,\n.define.sel {\n  background-color: rgb(255, 102, 128);\n}\n\n.flag {\n  color: #4cbf56;\n}\n.flag:hover,\n.flag.sel {\n  background-color: #4cbf56;\n}\n\n.receive {\n  color: rgb(255, 191, 0);\n}\n.receive:hover,\n.receive.sel {\n  background-color: rgb(255, 191, 0);\n}\n\n.event {\n  color: rgb(255, 191, 0);\n}\n.event:hover,\n.event.sel {\n  background-color: rgb(255, 191, 0);\n}\n\n.var,\n.VAR {\n  color: rgb(255, 120, 26);\n}\n.var:hover,\n.var.sel,\n.VAR:hover,\n.VAR.sel {\n  background-color: rgb(255, 120, 26);\n}\n\n.list,\n.LIST {\n  color: rgb(255, 102, 26);\n}\n.list:hover,\n.list.sel,\n.LIST:hover,\n.LIST.sel {\n  background-color: rgb(255, 102, 26);\n}\n\n.costume {\n  color: rgb(26, 66, 255);\n}\n.costume:hover,\n.costume.sel {\n  background-color: rgb(26, 66, 255);\n}\n\n.operators {\n  background-color: rgb(64, 191, 74);\n  color: rgb(56, 148, 56);\n}\n.operators:hover,\n.operators.sel {\n  background-color: rgb(56, 148, 56);\n}\n\n.data {\n  background-color: rgb(255, 140, 26);\n  color: rgb(219, 110, 0);\n}\n.data:hover,\n.data.sel {\n  background-color: rgb(219, 110, 0);\n}\n\n.data-lists {\n  background-color: rgb(255, 102, 26);\n  color: rgb(255, 102, 26);\n}\n.data-lists:hover,\n.data-lists.sel {\n  background-color: rgb(207, 81, 20);\n}\n\n.sensing {\n  background-color: rgb(76, 191, 230);\n  color: rgb(46, 142, 184);\n}\n.sensing:hover,\n.sensing.sel {\n  background-color: rgb(46, 142, 184);\n}\n\n.looks {\n  background-color: rgb(153, 102, 255);\n  color: rgb(119, 77, 203);\n}\n.looks:hover,\n.looks.sel {\n  background-color: rgb(119, 77, 203);\n}\n\n.sounds {\n  background-color: rgb(214, 92, 214);\n  color: rgb(189, 66, 189);\n}\n.sounds:hover,\n.sounds.sel {\n  background-color: rgb(189, 66, 189);\n}\n\n.motion {\n  background-color: rgb(76, 151, 255);\n  color: rgb(51, 115, 204);\n}\n.motion:hover,\n.motion.sel {\n  background-color: rgb(51, 115, 204);\n}\n\n.events {\n  background-color: rgb(255, 213, 0);\n  color: rgb(204, 153, 0);\n}\n.events:hover,\n.events.sel {\n  background-color: rgb(204, 153, 0);\n}\n\n.control {\n  background-color: rgb(255, 171, 25);\n  color: rgb(207, 139, 23);\n}\n.control:hover,\n.control.sel {\n  background-color: rgb(207, 139, 23);\n}\n\n.TurboWarp {\n  background-color: #ff4c4c;\n  color: rgb(207, 139, 23);\n}\n.TurboWarp:hover,\n.TurboWarp.sel {\n  background-color: #e64444;\n}\n\n.null {\n  background-color: rgb(255, 102, 128);\n  color: rgb(255, 77, 106);\n}\n.null:hover,\n.null.sel {\n  background-color: rgb(255, 77, 106);\n}\n\n.extension {\n  background-color: rgb(15 189 140);\n}\n.extension:hover,\n.extension.sel {\n  background-color: rgb(11 158 117);\n}\n\n/*.s3devDD>li.hat::before {                           content: '◠ ';}*/\n/*.s3devDD>li.hat::before {                           content: '▲ ';}*/\n/*.s3devDD>li.block::before {                         content: '■ ';}*/\n/*.s3devDD>li.reporter::before {                      content: '● ';}*/\n/*.s3devDD>li.boolean::before {                       content: '◆ ';}*/\n\n#s3devIDD > li {\n  height: 19px;\n  padding: 3px 8px;\n  margin: 2px 0.3em;\n  box-sizing: border-box;\n  position: relative;\n  color: white;\n  font-weight: bold;\n  width: min-content;\n}\n\n.s3devDD > li.hat {\n  border-radius: 14px 14px 3px 3px;\n}\n.s3devDD > li.block {\n  border-radius: 3px;\n}\n.s3devDD > li.reporter {\n  border-radius: 10px;\n}\n\n.s3devDD > li.boolean {\n  width: min-content;\n}\n.s3devDD > li.boolean::before {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  border-right: 9px solid transparent;\n  border-top: 9px solid white;\n  border-bottom: 10px solid white;\n}\n.s3devDD > li.boolean::after {\n  content: \"\";\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  border-left: 9px solid transparent;\n  border-top: 9px solid white;\n  border-bottom: 10px solid white;\n}\n[theme=\"dark\"] .s3devDD > li.boolean::before {\n  border-top-color: #111;\n  border-bottom-color: #111;\n}\n[theme=\"dark\"] .s3devDD > li.boolean::after {\n  border-top-color: #111;\n  border-bottom-color: #111;\n}\n\n#s3devOverlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(80, 80, 80, 0.5);\n  z-index: 9999;\n  padding: 10em;\n  color: white;\n  font-weight: bold;\n}\n\n.s3devMulti {\n  font-weight: normal;\n  position: absolute;\n  right: 0;\n  white-space: nowrap;\n  background-color: inherit;\n  z-index: 1;\n  padding: 0;\n}\n\n.s3devNav {\n  padding: 0 6px;\n}\n\n.s3devNav:hover {\n  color: #ffff80;\n}\n\n.s3devAction {\n  margin-left: 2em;\n  font-size: 12px;\n  font-weight: bold;\n  line-height: 2;\n}\n\n@media screen and (max-width: 1180px) {\n  .s3devAction {\n    display: none;\n  }\n}\n\n.s3devHide {\n  display: none;\n}\n\n.s3dev-mi:hover {\n  background-color: #d6e9f8;\n}\n[theme=\"dark\"] .s3dev-mi:hover {\n  background-color: var(--ui-tertiary);\n}\n\n#s3devHelpPop > div {\n  box-sizing: border-box;\n  width: 800px;\n  height: 60vh;\n  max-height: 800px;\n  max-width: 85%;\n  margin: auto;\n  margin-top: 20vh;\n}\n\n#s3devHelpPop [class*=\"modal_header-item-title\"] {\n  margin: 0 -20rem 0 0;\n}\n#s3devHelpPop[dir=\"rtl\"] [class*=\"modal_header-item-title\"] {\n  margin: 0 0 0 -20rem;\n}\n\n#s3devHelpContent {\n  height: calc(100% - 3.125rem);\n  overflow-y: auto;\n  padding: 1em 2em 4em;\n  background-color: white;\n  user-select: text;\n}\n[theme=\"dark\"] #s3devHelpPop > div {\n  background: #111;\n}\n\n#s3devFloatingBar {\n  display: flex;\n  white-space: nowrap;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\n  position: absolute;\n  min-width: 128px;\n  background-color: white;\n  border-radius: 4px;\n  box-shadow: rgba(0, 0, 0, 0.3) 0 0 3px, rgba(0, 0, 0, 0.2) 0 3px 10px;\n\n  z-index: 1000001;\n}\n[theme=\"dark\"] #s3devFloatingBar {\n  background-color: #111;\n}\n\n#s3devInsertLabel {\n  padding: 0;\n  align-items: center;\n}\n\n/* Drop down from find button */\nul#s3devIDD {\n  max-height: 200px;\n  margin-bottom: 0;\n}\n\n#s3devIDD > li > b {\n  background-color: rgba(0, 0, 0, 0.6);\n  color: white;\n}\n\n[data-highlighted=\"true\"] {\n  background-color: hsla(30, 100%, 55%, 1) !important; /* orange */\n  color: white !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/editor-searchable-dropdowns/userscript.css":
/*!************************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/editor-searchable-dropdowns/userscript.css ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".u-dropdown-searchbar {\n  width: 100%;\n  box-sizing: border-box;\n  /* based on styles for the title input */\n  color: white;\n  background-color: hsla(0, 100%, 100%, 0.25);\n  border: 1px dashed hsla(0, 0%, 0%, 0.15);\n  padding: 0.5rem;\n  outline: none;\n  transition: 0.25s ease-out;\n  font-size: 13px;\n  font-weight: bold;\n  border-radius: 4px;\n}\n.u-dropdown-searchbar:hover {\n  background-color: hsla(0, 100%, 100%, 0.5);\n}\n.u-dropdown-searchbar:focus {\n  background-color: white;\n  color: black;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/editor-stage-left/stageleft.css":
/*!*************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/editor-stage-left/stageleft.css ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[class^=\"stage-header_stage-button-icon\"] {\n  transform: scaleX(-1);\n}\n[class^=\"target-pane_target-pane\"] {\n  -webkit-flex-direction: row-reverse;\n  -ms-flex-direction: row-reverse;\n  flex-direction: row-reverse;\n}\n[dir=\"ltr\"] [class^=\"target-pane_stage-selector-wrapper\"] {\n  margin-left: 0;\n  margin-right: calc(0.5rem / 2);\n}\n[dir=\"ltr\"] [class^=\"sprite-selector_sprite-selector\"] {\n  margin-left: calc(0.5rem / 2);\n  margin-right: 0;\n}\n[dir=\"rtl\"] [class^=\"target-pane_stage-selector-wrapper\"] {\n  margin-right: 0;\n  margin-left: calc(0.5rem / 2);\n}\n[dir=\"rtl\"] [class^=\"sprite-selector_sprite-selector\"] {\n  margin-right: calc(0.5rem / 2);\n  margin-left: 0;\n}\n[class^=\"gui_flex-wrapper\"] {\n  -webkit-flex-direction: row-reverse;\n  -ms-flex-direction: row-reverse;\n  flex-direction: row-reverse;\n  overflow-x: hidden;\n}\n\n[dir=\"ltr\"] [class^=\"backpack_backpack-header\"] {\n  border-top-right-radius: 0;\n  border-top-left-radius: 0.5rem;\n}\n[dir=\"ltr\"] [class^=\"blocks_blocks_C530M\"] .injectionDiv,\n[dir=\"ltr\"] [class^=\"asset-panel_wrapper\"] {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0.5rem;\n}\n[dir=\"ltr\"] [class^=\"gui_extension-button-container\"] {\n  border-bottom-left-radius: 0.5rem;\n}\n\n[dir=\"rtl\"] [class^=\"backpack_backpack-header\"] {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0.5rem;\n}\n[dir=\"rtl\"] [class^=\"blocks_blocks_C530M\"] .injectionDiv,\n[dir=\"rtl\"] [class^=\"asset-panel_wrapper\"] {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0.5rem;\n}\n[dir=\"rtl\"] [class^=\"gui_extension-button-container\"] {\n  border-bottom-right-radius: 0.5rem;\n}\n\n.Popover {\n  z-index: 40;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/editor-theme3/theme3.css":
/*!******************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/editor-theme3/theme3.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "path.blocklyBlockBackground[fill=\"#FF6680\"],\npath.blocklyBlockBackground[fill=\"#5CB1D6\"],\npath.blocklyBlockBackground[fill=\"#FFBF00\"],\ng[data-category] > path.blocklyBlockBackground {\n  stroke: #0003;\n}\ng[data-argument-type=\"dropdown\"] > path,\ng[data-argument-type=\"dropdown\"] > rect,\ng[data-argument-type=\"variable\"] > rect,\ng[data-argument-type=\"variable\"] > path,\ng[data-shapes=\"c-block c-1 hat\"] > g[data-shapes=\"stack\"]:not(.blocklyDraggable) > path,\npath[data-argument-type=\"boolean\"] {\n  stroke: #0003;\n  fill: #0001;\n}\ng[data-argument-type*=\"text\"] > path,\n[data-category] g > line {\n  stroke: #0002;\n}\n.scratchCategoryItemBubble {\n  border-color: #0003 !important;\n}\n\n#s3devDD > li.extension {\n  background-color: var(--editorTheme3-PenColor);\n}\n\n.blocklyEditableText rect {\n  fill: #0001;\n}\n\n.fieldTextInput {\n  border-color: #0003 !important;\n}\n\n.blocklyBlockBackground[fill=\"#FFFFFF\"] {\n  fill: var(--editorTheme3-inputColor);\n}\n.blocklyEditableText > text {\n  fill: var(--editorTheme3-inputColor-text);\n}\n.blocklyHtmlInput {\n  background-color: var(--editorTheme3-inputColor);\n  color: var(--editorTheme3-inputColor-text);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/folders/style.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/folders/style.css ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-folders-contextmenu-container {\n}\n\n.sa-folders-contextmenu-item {\n  max-width: 250px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n[sa-folders-context-type=\"folder\"] > :not(.sa-folders-contextmenu-container) {\n  display: none;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/gamepad/gamepadlib.css":
/*!****************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/gamepad/gamepadlib.css ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".gamepadlib-selector {\n  width: 100%;\n  margin-bottom: 3px;\n}\n\n.gamepadlib-content {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n}\n.gamepadlib-content-buttons {\n  padding-right: 10px;\n}\n.gamepadlib-content-axes {\n}\n\n.gamepadlib-mapping {\n  display: flex;\n  align-items: center;\n  margin-bottom: 3px;\n}\n.gamepadlib-mapping-label {\n  width: 100px;\n  text-align: center;\n}\n.gamepadlib-keyinput {\n  text-align: center;\n  width: 75px;\n  height: 25px;\n  border-radius: 0;\n  border: 1px solid black;\n  background: white;\n  color: black;\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n.gamepadlib-mapping[data-value=\"1\"] .gamepadlib-keyinput {\n  background: yellow;\n}\n.gamepadlib-keyinput[data-accepting-input=\"true\"] {\n  background: #d6fff9;\n}\n.gamepadlib-keyinput[data-empty=\"true\"]:not([data-accepting-input=\"true\"]) {\n  color: #aaa;\n  font-style: italic;\n}\n\n.gamepadlib-axis {\n  margin-bottom: 8px;\n  text-align: center;\n}\n.gamepadlib-axis-circle {\n  position: relative;\n  width: 150px;\n  height: 150px;\n  border: 1px solid black;\n  overflow: hidden;\n}\n.gamepadlib-axis-dot {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  background-image: url(" + escape(__webpack_require__(/*! ./dot.svg */ "./src/addons/addons/gamepad/dot.svg")) + ");\n  width: 8px;\n  height: 8px;\n  transform: translate(-50%, -50%);\n  pointer-events: none;\n}\n.gamepadlib-axis-mapping {\n  width: 100%;\n}\n\n.gamepadlib-axis-circle-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.gamepadlib-axis-circle-overlay > .gamepadlib-axis-mapper {\n  position: absolute;\n}\n.gamepadlib-axis-circle-overlay > .gamepadlib-axis-mapper:nth-of-type(1) {\n  left: 50%;\n  top: 0;\n  transform: translateX(-50%);\n}\n.gamepadlib-axis-circle-overlay > .gamepadlib-axis-mapper:nth-of-type(2) {\n  left: 0;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.gamepadlib-axis-circle-overlay > .gamepadlib-axis-mapper:nth-of-type(3) {\n  right: 0;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.gamepadlib-axis-circle-overlay > .gamepadlib-axis-mapper:nth-of-type(4) {\n  left: 50%;\n  bottom: 0;\n  transform: translateX(-50%);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/gamepad/style.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/gamepad/style.css ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-gamepad-container {\n  margin-right: 0.2rem;\n}\n\n.sa-gamepad-spacer {\n  display: flex;\n  width: 100%;\n  justify-content: flex-end;\n}\n\n.sa-gamepad-popup-outer {\n  /* above fullscreen */\n  z-index: 99999;\n}\n.sa-gamepad-popup {\n  box-sizing: border-box;\n  width: 700px;\n  max-height: min(800px, 85vh);\n  height: 100%;\n  max-width: 85%;\n  margin: 50px auto;\n  display: flex;\n  flex-direction: column;\n}\n.sa-gamepad-popup-content {\n  background-color: white;\n  padding: 1.5rem 2.25rem;\n  height: 100%;\n  overflow-y: auto;\n}\n\n.sa-gamepad-popup [class*=\"modal_header-item-title\"] {\n  margin: 0 -20rem 0 0;\n}\n\n.sa-gamepad-cursor {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 9999;\n  user-select: none;\n  pointer-events: none;\n  will-change: transform;\n  image-rendering: optimizeSpeed;\n  image-rendering: crisp-edges;\n  image-rendering: pixelated;\n}\n.sa-gamepad-cursor-down {\n  filter: invert(100%);\n}\n\n.sa-gamepad-small .sa-gamepad-container[data-editor-mode=\"editor\"] {\n  display: none !important;\n}\n\n.sa-gamepad-hide-cursor [class^=\"stage_stage_\"] {\n  cursor: none;\n}\n\n.sa-gamepad-browser-support-warning {\n  font-weight: bold;\n  margin-bottom: 10px;\n}\n\n.sa-gamepad-store-settings {\n  display: none;\n}\n.sa-gamepad-store-settings > input {\n  margin-right: 4px;\n}\n.sa-gamepad-has-controller .sa-gamepad-store-settings {\n  display: block;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/hide-flyout/style.css":
/*!***************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/hide-flyout/style.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".blocklyFlyout,\n.blocklyFlyoutScrollbar,\n.sa-lock-image {\n  transition-property: transform;\n}\n\n.blocklyFlyout.sa-flyoutClose {\n  transform: translateX(-200px) !important;\n}\n\n.blocklyFlyoutScrollbar.sa-flyoutClose {\n  transform: translateX(35px) !important;\n}\n\n.sa-lock-image.sa-flyoutClose {\n  transform: translateX(-260px);\n}\n\n.sa-flyout-placeHolder {\n  position: absolute;\n  left: 61px;\n  top: 44px;\n  height: 100%;\n  width: 251px;\n}\n\n.sa-lock-image {\n  position: absolute;\n  z-index: 20;\n  width: 20px;\n  cursor: pointer;\n  top: 46px;\n  left: 280px;\n}\n\n.injectionDiv {\n  overflow: hidden !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/mediarecorder/style.css":
/*!*****************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/mediarecorder/style.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".mediaRecorderPopup {\n  box-sizing: border-box;\n  width: 700px;\n  max-height: min(800px, 80vh);\n  max-width: 85%;\n  margin-top: 20vh;\n  overflow-y: auto;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.mediaRecorderPopup [class*=\"modal_header-item-title\"] {\n  margin: 0; /* required because there is no close button */\n}\n\n.mediaRecorderPopupContent {\n  background-color: white;\n  padding: 1.5rem 2.25rem;\n}\n[theme=\"dark\"] .mediaRecorderPopupContent {\n  color: var(--text-primary);\n  background-color: var(--ui-primary);\n}\n\n.mediaRecorderPopup p {\n  font-size: 1rem;\n  margin: 1rem auto;\n}\n\n.mediaRecorderPopup p :last-child {\n  margin-left: 1rem;\n}\n\n.mediaRecorderPopup[dir=\"rtl\"] p :last-child {\n  margin-left: 0;\n  margin-right: 1rem;\n}\n\n#recordOptionSecondsInput {\n  width: 6rem;\n}\n\n.mediaRecorderPopupButtons {\n  margin-top: 1.5rem;\n}\n\n.mediaRecorderPopupButtons button {\n  margin-left: 0.5rem;\n}\n\n.mediaRecorderPopupButtons button:nth-of-type(1) {\n  color: black;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/mouse-pos/style.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/mouse-pos/style.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".pos-container-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  -ms-flex-align: center;\n  align-items: center;\n  padding: 0.25rem;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pos-container {\n  font-size: 0.6rem;\n  font-weight: bold;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  color: #5cb1d6;\n  white-space: nowrap;\n}\n\n/* Use pseudo elements to avoid firing mutation observers by just moving the cursor */\n.pos-container > span::after {\n  content: attr(data-content);\n}\n\n.sa-mouse-pos-small .pos-container-container {\n  display: none !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/onion-skinning/style.css":
/*!******************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/onion-skinning/style.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-onion-controls-container {\n  display: flex;\n  flex-direction: row;\n  height: calc(1.95rem + 2px);\n}\n\n.sa-onion-button {\n  position: relative;\n}\n.sa-onion-button:focus-within {\n  background-color: hsla(0, 100%, 65%, 0.2);\n}\n.sa-onion-button[data-enabled=\"true\"] {\n  background-color: #ff4c4c;\n}\n\n.sa-onion-settings {\n  position: absolute;\n  bottom: 0;\n  right: 16px;\n  /* based on the styles for the color dropdown */\n  padding: 4px;\n  border-radius: 4px;\n  border: 1px solid #ddd;\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\n  transition-property: bottom, opacity;\n  transition-duration: 500ms;\n  transition-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  opacity: 0;\n  pointer-events: none;\n  background: white;\n  color: black;\n}\n.sa-onion-settings[data-visible=\"true\"] {\n  bottom: 16px;\n  pointer-events: auto;\n  opacity: 1;\n}\n[dir=\"rtl\"] .sa-onion-settings {\n  right: initial;\n  left: 24px;\n}\n.sa-onion-settings .sa-onion-button {\n  border-color: #d9d9d9 !important; /* override dark mode */\n}\n\n.sa-onion-settings-line {\n  display: flex;\n  justify-content: flex-end;\n  align-items: baseline;\n}\n\n.sa-onion-settings-input {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  text-align: center;\n  border: 0;\n  background: transparent;\n  -moz-appearance: textfield;\n  border: 0;\n  outline: 0;\n}\n\n.sa-onion-settings-input::-webkit-outer-spin-button,\n.sa-onion-settings-input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n.sa-onion-settings-tip {\n  position: absolute;\n  bottom: 0;\n  transform: translateY(100%);\n  right: 101px;\n}\n[dir=\"rtl\"] .sa-onion-settings-tip {\n  right: 118px;\n}\n.sa-onion-settings-polygon {\n  fill: white;\n  stroke: #ddd;\n}\n\n[theme=\"dark\"] .sa-onion-image[data-image=\"settings\"] {\n  filter: invert(1);\n}\n[theme=\"dark\"] .sa-onion-image[data-image=\"increment\"] {\n  filter: none;\n}\n[theme=\"dark\"] .sa-onion-image[data-image=\"decrement\"] {\n  filter: none;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/pause/style.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/pause/style.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".pause-btn {\n  width: 2rem;\n  height: 2rem;\n  padding: 0.375rem;\n  border-radius: 0.25rem;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  user-drag: none;\n  cursor: pointer;\n}\n\n.pause-btn:hover {\n  background-color: hsla(0, 100%, 65%, 0.15);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/remove-curved-stage-border/remove-borders.css":
/*!***************************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/remove-curved-stage-border/remove-borders.css ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[class*=\"stage_stage\"] {\n  border-radius: 0rem !important;\n}\n\n[class*=\"stage_green-flag-overlay-wrapper\"] {\n  border-radius: 0rem !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/transparent-orphans/userstyle.css":
/*!***************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/transparent-orphans/userstyle.css ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".blocklySvg > .blocklyWorkspace > .blocklyBlockCanvas > .blocklyDraggable[data-shapes*=\"hat\"],\n.blocklyFlyout > .blocklyWorkspace > .blocklyBlockCanvas > .blocklyDraggable {\n  opacity: calc(1 - var(--transparentOrphans-block) / 100);\n}\n.blocklyWsDragSurface > .blocklyBlockCanvas > .blocklyDraggable[data-shapes*=\"hat\"] {\n  opacity: calc(1 - var(--transparentOrphans-block) / 100);\n}\n\n.blocklySvg > .blocklyWorkspace > .blocklyBlockCanvas > .blocklyDraggable:not([data-shapes*=\"hat\"]) {\n  opacity: calc(1 - var(--transparentOrphans-orphan) / 100);\n}\n.blocklyWsDragSurface > .blocklyBlockCanvas > .blocklyDraggable:not([data-shapes*=\"hat\"]) {\n  opacity: calc(1 - var(--transparentOrphans-orphan) / 100);\n}\n\n.blocklyBlockDragSurface {\n  opacity: calc(1 - var(--transparentOrphans-dragged) / 100);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/tw-interface-customization/remove-backpack.css":
/*!****************************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/tw-interface-customization/remove-backpack.css ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[class^=\"backpack_backpack-container\"] {\n  display: none;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/variable-manager/style.css":
/*!********************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/variable-manager/style.css ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/* Change z-indexes to allow more than 3 tabs */\n.gui_tab_27Unf.gui_is-selected_sHAiu {\n  z-index: 10 !important;\n}\n.gui_tab_27Unf:nth-of-type(1) {\n  z-index: 9;\n}\n.gui_tab_27Unf:nth-of-type(2) {\n  z-index: 8;\n}\n.gui_tab_27Unf:nth-of-type(3) {\n  z-index: 7;\n}\n.gui_tab_27Unf:nth-of-type(4) {\n  z-index: 6;\n}\n\n.sa-var-manager {\n  display: block;\n  padding: 18px;\n  /* weird hack to fix scrolling??? */\n  height: 50px;\n  overflow-y: auto;\n}\n\n.sa-var-manager-searchbox {\n  background-image: url(" + escape(__webpack_require__(/*! ./search.svg */ "./src/addons/addons/variable-manager/search.svg")) + ");\n  width: 25%;\n  margin-bottom: 4px;\n  padding: 8px;\n  padding-right: 32px; /* for the text to not overlap the image */\n  border-radius: 4px;\n  background-repeat: no-repeat;\n  background-size: 18px 18px;\n  background-position: calc(100% - 7px) center;\n  font-size: 0.75rem;\n}\n[theme=\"dark\"] .sa-var-manager-searchbox {\n  border-color: #333;\n}\n\n[dir=\"rtl\"] .sa-var-manager-searchbox {\n  padding-right: 8px;\n  padding-left: 32px;\n  background-position: 7px center;\n}\n\n.sa-var-manager.freeze .sa-var-manager-value *,\n.sa-var-manager.freeze .sa-var-manager-name * {\n  opacity: 0.5;\n}\n\n.sa-var-manager.freeze input:focus,\n.sa-var-manager.freeze textarea:focus {\n  opacity: 1;\n}\n\n.sa-var-manager-heading {\n  display: block;\n  font-weight: bold;\n  font-size: large;\n  margin-top: 6px;\n  margin-bottom: 6px;\n}\n\n.sa-var-manager-name {\n  word-break: break-word;\n}\n\n.sa-var-manager .sa-var-manager-value {\n  width: 75%;\n}\n\n.sa-var-manager * > input {\n  background: none;\n  border: none;\n  padding: 8px;\n  width: 100%;\n  height: 100%;\n}\n\n.sa-var-manager-value > textarea {\n  background: none;\n  border: none;\n  padding: 8px;\n  width: 100%;\n  height: 100%;\n  line-height: 2em;\n  resize: none;\n}\n\n.sa-var-manager table {\n  border-radius: 5px;\n  border-collapse: collapse;\n  width: 100%;\n}\n\n.sa-var-manager td {\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  text-align: left;\n}\n[theme=\"dark\"] .sa-var-manager td {\n  border-color: #333;\n}\n\n/* tr:nth-child(even) {\n    background-color: #dddddd;\n} */\n", ""]);

// exports


/***/ }),

/***/ "./src/addons/addons eager recursive ./!./node_modules/css-loader/index.js!./ ^\\.\\/.*$ include: \\.css$":
/*!*****************************************************************************************************!*\
  !*** ./src/addons/addons eager ./node_modules/css-loader ^\.\/.*$ include: \.css$ namespace object ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./2d-color-picker/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/2d-color-picker/style.css",
	"./block-palette-icons/userstyle.css": "./node_modules/css-loader/index.js!./src/addons/addons/block-palette-icons/userstyle.css",
	"./clones/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/clones/style.css",
	"./color-picker/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/color-picker/style.css",
	"./custom-zoom/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/custom-zoom/style.css",
	"./debugger/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/debugger/style.css",
	"./drag-drop/dragged-over.css": "./node_modules/css-loader/index.js!./src/addons/addons/drag-drop/dragged-over.css",
	"./editor-colored-context-menus/userscript.css": "./node_modules/css-loader/index.js!./src/addons/addons/editor-colored-context-menus/userscript.css",
	"./editor-devtools/userscript.css": "./node_modules/css-loader/index.js!./src/addons/addons/editor-devtools/userscript.css",
	"./editor-searchable-dropdowns/userscript.css": "./node_modules/css-loader/index.js!./src/addons/addons/editor-searchable-dropdowns/userscript.css",
	"./editor-stage-left/stageleft.css": "./node_modules/css-loader/index.js!./src/addons/addons/editor-stage-left/stageleft.css",
	"./editor-theme3/theme3.css": "./node_modules/css-loader/index.js!./src/addons/addons/editor-theme3/theme3.css",
	"./folders/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/folders/style.css",
	"./gamepad/gamepadlib.css": "./node_modules/css-loader/index.js!./src/addons/addons/gamepad/gamepadlib.css",
	"./gamepad/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/gamepad/style.css",
	"./hide-flyout/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/hide-flyout/style.css",
	"./mediarecorder/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/mediarecorder/style.css",
	"./mouse-pos/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/mouse-pos/style.css",
	"./onion-skinning/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/onion-skinning/style.css",
	"./pause/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/pause/style.css",
	"./remove-curved-stage-border/remove-borders.css": "./node_modules/css-loader/index.js!./src/addons/addons/remove-curved-stage-border/remove-borders.css",
	"./transparent-orphans/userstyle.css": "./node_modules/css-loader/index.js!./src/addons/addons/transparent-orphans/userstyle.css",
	"./tw-interface-customization/remove-backpack.css": "./node_modules/css-loader/index.js!./src/addons/addons/tw-interface-customization/remove-backpack.css",
	"./variable-manager/style.css": "./node_modules/css-loader/index.js!./src/addons/addons/variable-manager/style.css"
};


function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(function(id) {
		return __webpack_require__.t(id, 7);
	});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = "./src/addons/addons eager recursive ./!./node_modules/css-loader/index.js!./ ^\\.\\/.*$ include: \\.css$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/addons/addons eager recursive ^\\.\\/.*$ include: \\.js$":
/*!**************************************************************************!*\
  !*** ./src/addons/addons eager ^\.\/.*$ include: \.js$ namespace object ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./2d-color-picker/paint-editor": "./src/addons/addons/2d-color-picker/paint-editor.js",
	"./2d-color-picker/paint-editor.js": "./src/addons/addons/2d-color-picker/paint-editor.js",
	"./2d-color-picker/userscript": "./src/addons/addons/2d-color-picker/userscript.js",
	"./2d-color-picker/userscript.js": "./src/addons/addons/2d-color-picker/userscript.js",
	"./bitmap-copy/userscript": "./src/addons/addons/bitmap-copy/userscript.js",
	"./bitmap-copy/userscript.js": "./src/addons/addons/bitmap-copy/userscript.js",
	"./block-switching/blockToDom": "./src/addons/addons/block-switching/blockToDom.js",
	"./block-switching/blockToDom.js": "./src/addons/addons/block-switching/blockToDom.js",
	"./block-switching/userscript": "./src/addons/addons/block-switching/userscript.js",
	"./block-switching/userscript.js": "./src/addons/addons/block-switching/userscript.js",
	"./blocks2image/userscript": "./src/addons/addons/blocks2image/userscript.js",
	"./blocks2image/userscript.js": "./src/addons/addons/blocks2image/userscript.js",
	"./cat-blocks/userscript": "./src/addons/addons/cat-blocks/userscript.js",
	"./cat-blocks/userscript.js": "./src/addons/addons/cat-blocks/userscript.js",
	"./clones/userscript": "./src/addons/addons/clones/userscript.js",
	"./clones/userscript.js": "./src/addons/addons/clones/userscript.js",
	"./color-picker/code-editor": "./src/addons/addons/color-picker/code-editor.js",
	"./color-picker/code-editor.js": "./src/addons/addons/color-picker/code-editor.js",
	"./color-picker/paint-editor": "./src/addons/addons/color-picker/paint-editor.js",
	"./color-picker/paint-editor.js": "./src/addons/addons/color-picker/paint-editor.js",
	"./color-picker/userscript": "./src/addons/addons/color-picker/userscript.js",
	"./color-picker/userscript.js": "./src/addons/addons/color-picker/userscript.js",
	"./custom-block-shape/userscript": "./src/addons/addons/custom-block-shape/userscript.js",
	"./custom-block-shape/userscript.js": "./src/addons/addons/custom-block-shape/userscript.js",
	"./custom-zoom/userscript": "./src/addons/addons/custom-zoom/userscript.js",
	"./custom-zoom/userscript.js": "./src/addons/addons/custom-zoom/userscript.js",
	"./data-category-tweaks-v2/userscript": "./src/addons/addons/data-category-tweaks-v2/userscript.js",
	"./data-category-tweaks-v2/userscript.js": "./src/addons/addons/data-category-tweaks-v2/userscript.js",
	"./debugger/userscript": "./src/addons/addons/debugger/userscript.js",
	"./debugger/userscript.js": "./src/addons/addons/debugger/userscript.js",
	"./drag-drop/userscript": "./src/addons/addons/drag-drop/userscript.js",
	"./drag-drop/userscript.js": "./src/addons/addons/drag-drop/userscript.js",
	"./editor-colored-context-menus/userscript": "./src/addons/addons/editor-colored-context-menus/userscript.js",
	"./editor-colored-context-menus/userscript.js": "./src/addons/addons/editor-colored-context-menus/userscript.js",
	"./editor-devtools/BlockInstance": "./src/addons/addons/editor-devtools/BlockInstance.js",
	"./editor-devtools/BlockInstance.js": "./src/addons/addons/editor-devtools/BlockInstance.js",
	"./editor-devtools/BlockItem": "./src/addons/addons/editor-devtools/BlockItem.js",
	"./editor-devtools/BlockItem.js": "./src/addons/addons/editor-devtools/BlockItem.js",
	"./editor-devtools/DevTools": "./src/addons/addons/editor-devtools/DevTools.js",
	"./editor-devtools/DevTools.js": "./src/addons/addons/editor-devtools/DevTools.js",
	"./editor-devtools/DomHelpers": "./src/addons/addons/editor-devtools/DomHelpers.js",
	"./editor-devtools/DomHelpers.js": "./src/addons/addons/editor-devtools/DomHelpers.js",
	"./editor-devtools/XML": "./src/addons/addons/editor-devtools/XML.js",
	"./editor-devtools/XML.js": "./src/addons/addons/editor-devtools/XML.js",
	"./editor-devtools/blockly/BlockFlasher": "./src/addons/addons/editor-devtools/blockly/BlockFlasher.js",
	"./editor-devtools/blockly/BlockFlasher.js": "./src/addons/addons/editor-devtools/blockly/BlockFlasher.js",
	"./editor-devtools/blockly/UndoGroup": "./src/addons/addons/editor-devtools/blockly/UndoGroup.js",
	"./editor-devtools/blockly/UndoGroup.js": "./src/addons/addons/editor-devtools/blockly/UndoGroup.js",
	"./editor-devtools/blockly/Utils": "./src/addons/addons/editor-devtools/blockly/Utils.js",
	"./editor-devtools/blockly/Utils.js": "./src/addons/addons/editor-devtools/blockly/Utils.js",
	"./editor-devtools/show-broadcast": "./src/addons/addons/editor-devtools/show-broadcast.js",
	"./editor-devtools/show-broadcast.js": "./src/addons/addons/editor-devtools/show-broadcast.js",
	"./editor-devtools/userscript": "./src/addons/addons/editor-devtools/userscript.js",
	"./editor-devtools/userscript.js": "./src/addons/addons/editor-devtools/userscript.js",
	"./editor-searchable-dropdowns/userscript": "./src/addons/addons/editor-searchable-dropdowns/userscript.js",
	"./editor-searchable-dropdowns/userscript.js": "./src/addons/addons/editor-searchable-dropdowns/userscript.js",
	"./editor-sounds/userscript": "./src/addons/addons/editor-sounds/userscript.js",
	"./editor-sounds/userscript.js": "./src/addons/addons/editor-sounds/userscript.js",
	"./editor-stage-left/fix-share-the-love": "./src/addons/addons/editor-stage-left/fix-share-the-love.js",
	"./editor-stage-left/fix-share-the-love.js": "./src/addons/addons/editor-stage-left/fix-share-the-love.js",
	"./editor-theme3/theme3": "./src/addons/addons/editor-theme3/theme3.js",
	"./editor-theme3/theme3.js": "./src/addons/addons/editor-theme3/theme3.js",
	"./folders/userscript": "./src/addons/addons/folders/userscript.js",
	"./folders/userscript.js": "./src/addons/addons/folders/userscript.js",
	"./gamepad/gamepadlib": "./src/addons/addons/gamepad/gamepadlib.js",
	"./gamepad/gamepadlib.js": "./src/addons/addons/gamepad/gamepadlib.js",
	"./gamepad/userscript": "./src/addons/addons/gamepad/userscript.js",
	"./gamepad/userscript.js": "./src/addons/addons/gamepad/userscript.js",
	"./hide-flyout/userscript": "./src/addons/addons/hide-flyout/userscript.js",
	"./hide-flyout/userscript.js": "./src/addons/addons/hide-flyout/userscript.js",
	"./initialise-sprite-position/userscript": "./src/addons/addons/initialise-sprite-position/userscript.js",
	"./initialise-sprite-position/userscript.js": "./src/addons/addons/initialise-sprite-position/userscript.js",
	"./load-extensions/userscript": "./src/addons/addons/load-extensions/userscript.js",
	"./load-extensions/userscript.js": "./src/addons/addons/load-extensions/userscript.js",
	"./mediarecorder/userscript": "./src/addons/addons/mediarecorder/userscript.js",
	"./mediarecorder/userscript.js": "./src/addons/addons/mediarecorder/userscript.js",
	"./mouse-pos/userscript": "./src/addons/addons/mouse-pos/userscript.js",
	"./mouse-pos/userscript.js": "./src/addons/addons/mouse-pos/userscript.js",
	"./mute-project/userscript": "./src/addons/addons/mute-project/userscript.js",
	"./mute-project/userscript.js": "./src/addons/addons/mute-project/userscript.js",
	"./onion-skinning/userscript": "./src/addons/addons/onion-skinning/userscript.js",
	"./onion-skinning/userscript.js": "./src/addons/addons/onion-skinning/userscript.js",
	"./pause/module": "./src/addons/addons/pause/module.js",
	"./pause/module.js": "./src/addons/addons/pause/module.js",
	"./pause/userscript": "./src/addons/addons/pause/userscript.js",
	"./pause/userscript.js": "./src/addons/addons/pause/userscript.js",
	"./remove-sprite-confirm/userscript": "./src/addons/addons/remove-sprite-confirm/userscript.js",
	"./remove-sprite-confirm/userscript.js": "./src/addons/addons/remove-sprite-confirm/userscript.js",
	"./tw-interface-customization/remove-backpack": "./src/addons/addons/tw-interface-customization/remove-backpack.js",
	"./tw-interface-customization/remove-backpack.js": "./src/addons/addons/tw-interface-customization/remove-backpack.js",
	"./tw-project-info/blockcount": "./src/addons/addons/tw-project-info/blockcount.js",
	"./tw-project-info/blockcount.js": "./src/addons/addons/tw-project-info/blockcount.js",
	"./variable-manager/userscript": "./src/addons/addons/variable-manager/userscript.js",
	"./variable-manager/userscript.js": "./src/addons/addons/variable-manager/userscript.js"
};


function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(__webpack_require__);
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = "./src/addons/addons eager recursive ^\\.\\/.*$ include: \\.js$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/addons/addons/2d-color-picker/assets/sv-gr.png":
/*!************************************************************!*\
  !*** ./src/addons/addons/2d-color-picker/assets/sv-gr.png ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/1d88d0fb1688305cd93cb879e0eb83da.png";

/***/ }),

/***/ "./src/addons/addons/2d-color-picker/paint-editor.js":
/*!***********************************************************!*\
  !*** ./src/addons/addons/2d-color-picker/paint-editor.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assets_sv_gr_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/sv-gr.png */ "./src/addons/addons/2d-color-picker/assets/sv-gr.png");
/* harmony import */ var _assets_sv_gr_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_assets_sv_gr_png__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libraries/common/cs/normalize-color.js */ "./src/addons/libraries/common/cs/normalize-color.js");
/* harmony import */ var _libraries_common_cs_rate_limiter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libraries/common/cs/rate-limiter.js */ "./src/addons/libraries/common/cs/rate-limiter.js");
/* harmony import */ var _libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libraries/thirdparty/cs/tinycolor-min.js */ "./src/addons/libraries/thirdparty/cs/tinycolor-min.js");
/* inserted by pull.js */


const _twGetAsset = path => {
  if (path === "/assets/sv-gr.png") return _assets_sv_gr_png__WEBPACK_IMPORTED_MODULE_0___default.a;
  throw new Error("Unknown asset: ".concat(path));
}; // this script was happily stolen from the color-picker addon, developed by Richie Bendall and apple502j
// import required libraries





/* harmony default export */ __webpack_exports__["default"] = (async ({
  addon,
  console,
  msg
}) => {
  let prevEventHandler; // 250-ms rate limit

  const rateLimiter = new _libraries_common_cs_rate_limiter_js__WEBPACK_IMPORTED_MODULE_2__["default"](250); // get the color from scratch

  const getColor = element => {
    let fillOrStroke;
    const state = addon.tab.redux.state;

    if (state.scratchPaint.modals.fillColor) {
      fillOrStroke = "fill";
    } else if (state.scratchPaint.modals.strokeColor) {
      fillOrStroke = "stroke";
    } else {
      return;
    }

    const colorType = state.scratchPaint.fillMode.colorIndex;
    const primaryOrSecondary = ["primary", "secondary"][colorType];
    const color = state.scratchPaint.color["".concat(fillOrStroke, "Color")][primaryOrSecondary];
    if (color === null || color === "scratch-paint/style-path/mixed") return; // This value can be arbitrary - it can be HEX, RGB, etc.
    // Use tinycolor to convert them.

    return Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(color).toHex8();
  }; // load the new color to scratch


  const setColor = (hex, element) => {
    hex = Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_1__["normalizeHex"])(hex);
    if (!addon.tab.redux.state || !addon.tab.redux.state.scratchPaint) return; // The only way to reliably set color is to invoke eye dropper via click()
    // then faking that the eye dropper reported the value.

    const onEyeDropperOpened = ({
      detail
    }) => {
      if (detail.action.type !== "scratch-paint/eye-dropper/ACTIVATE_COLOR_PICKER") return;
      addon.tab.redux.removeEventListener("statechanged", onEyeDropperOpened);
      setTimeout(() => {
        const previousTool = addon.tab.redux.state.scratchPaint.color.eyeDropper.previousTool;
        if (previousTool) previousTool.activate();
        addon.tab.redux.state.scratchPaint.color.eyeDropper.callback(hex);
        addon.tab.redux.dispatch({
          type: "scratch-paint/eye-dropper/DEACTIVATE_COLOR_PICKER"
        });
      }, 50);
    };

    addon.tab.redux.addEventListener("statechanged", onEyeDropperOpened);
    element.children[1].children[0].click();
  }; // for the color picker's background color


  const convertToGeneralColor = hex => {
    let h = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(hex).toHsv();
    h.s = 1;
    h.v = 1;
    return Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(h).toHex();
  }; // le loop


  while (true) {
    // wait for color dialog box appearance
    const element = await addon.tab.waitForElement('div[class*="color-picker_swatch-row"]', {
      markAsSeen: true,
      reduxCondition: state => state.scratchGui.editorTab.activeTabIndex === 1 && !state.scratchGui.mode.isPlayerOnly
    });
    rateLimiter.abort(false); // update the bg color of the picker

    function updateColor() {
      rateLimiter.limit(() => {
        let c = getColor(element);
        let chsv = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(c).toHsv();
        updateHandleFinal(chsv.s, chsv.v);
        saColorPicker.style.background = "#" + convertToGeneralColor(getColor(element));
      });
    } // redux stuff


    addon.tab.redux.initialize();
    addon.tab.redux.addEventListener("statechanged", e => e.detail.action.type === "scratch-paint/fill-style/CHANGE_FILL_COLOR" || e.detail.action.type === "scratch-paint/fill-style/CHANGE_FILL_COLOR_2" || e.detail.action.type === "scratch-paint/stroke-style/CHANGE_STROKE_COLOR" || e.detail.action.type === "scratch-paint/stroke-style/CHANGE_STROKE_COLOR_2" ? updateColor() : 0);

    if (addon.tab.redux && typeof prevEventHandler === "function") {
      addon.tab.redux.removeEventListener("statechanged", prevEventHandler);
      prevEventHandler = null;
    } // get the color


    if (addon.tab.editorMode !== "editor") continue;
    let defaultColor = getColor(element); // create the color picker element and all it's child elements

    const saColorPicker = document.createElement("div");
    saColorPicker.className = "sa-2dcolor-picker";
    saColorPicker.style.background = "#" + convertToGeneralColor(defaultColor || "ff0000");
    const saColorPickerImage = Object.assign(document.createElement("img"), {
      className: "sa-2dcolor-picker-image",
      src: _twGetAsset("/assets/sv-gr.png"),
      draggable: false
    });
    const saColorPickerHandle = Object.assign(document.createElement("div"), {
      className: addon.tab.scratchClass("slider_handle")
    });
    saColorPickerHandle.style.pointerEvents = "none"; // create the label

    const saColorLabel = document.createElement("div");
    saColorLabel.className = addon.tab.scratchClass("color-picker_row-header", {
      others: "sa-2dcolor-label"
    });
    const saColorLabelName = document.createElement("span");
    saColorLabelName.className = addon.tab.scratchClass("color-picker_label-name", {
      others: "sa-2dcolor-label-name"
    });
    saColorLabelName.innerText = msg("shade");
    const saColorLabelVal = document.createElement("span");
    saColorLabelVal.className = addon.tab.scratchClass("color-picker_label-readout", {
      others: "sa-2dcolor-label-val"
    });
    saColorLabel.appendChild(saColorLabelName);
    saColorLabel.appendChild(saColorLabelVal);
    let keyPressed = -1;
    let originalPos = {
      x: 0,
      y: 0
    };
    window.addEventListener("keydown", e => keyPressed = e.keyCode);
    window.addEventListener("keyup", () => keyPressed = -1);
    let origHue = 0;
    let el = null;

    let mousemovefunc = function mousemovefunc(e) {
      updateHandle(e, keyPressed, originalPos);
      return false;
    };

    let mouseupfunc = function mouseupfunc(e) {
      updateFinal(e, keyPressed, originalPos);
    };

    function updateHandle(e, keyPressed, originalPos) {
      let cx = Math.min(Math.max(e.clientX - saColorPicker.getBoundingClientRect().x, 0), 150);
      let cy = Math.min(Math.max(e.clientY - saColorPicker.getBoundingClientRect().y, 0), 150);

      if (keyPressed === 16) {
        if (Math.abs(cx - originalPos.x) > Math.abs(cy - originalPos.y)) cy = originalPos.y;else cx = originalPos.x;
      }

      saColorPickerHandle.style.left = cx - 8 + "px";
      saColorPickerHandle.style.top = cy - 8 + "px";
      saColorLabelVal.innerText = "".concat(Math.round(cx / 150 * 100), ", ").concat(100 - Math.round(cy / 150 * 100)); //update color in real-time (i only bothered to do that for solid colors)

      if ((!addon.tab.redux.state.scratchPaint.fillMode.gradientType || addon.tab.redux.state.scratchPaint.fillMode.gradientType === "SOLID") && el) {
        let c = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
          h: origHue,
          s: cx / 150,
          v: 1 - cy / 150
        }).toHex();
        if (c.startsWith("#")) el.style.background = c;else el.style.background = "#" + c;
      }
    }

    function updateHandleFinal(s, v) {
      saColorPickerHandle.style.left = s * 150 - 8 + "px";
      saColorPickerHandle.style.top = (1 - v) * 150 - 8 + "px";
      saColorLabelVal.innerText = "".concat(Math.round(s * 100), ", ").concat(Math.round(v * 100));
    }

    function updateFinal(e, keyPressed, originalPos) {
      rateLimiter.limit(() => {
        let ox = Math.min(Math.max(e.clientX - saColorPicker.getBoundingClientRect().x, 0), 150);
        let oy = Math.min(Math.max(e.clientY - saColorPicker.getBoundingClientRect().y, 0), 150);

        if (keyPressed === 16) {
          if (Math.abs(ox - originalPos.x) > Math.abs(oy - originalPos.y)) oy = originalPos.y;else ox = originalPos.x;
        }

        let color = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(getColor(element)).toHsv();
        let s = ox / 150;
        let v = 1 - oy / 150;
        let newColor = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
          h: color.h,
          s: s,
          v: v,
          a: color.a
        }).toHex8();
        setColor(newColor, element);
        updateHandleFinal(s, v);
      });
      window.removeEventListener("pointermove", mousemovefunc);
      window.removeEventListener("pointerup", mouseupfunc);
    }

    if (defaultColor) {
      let defaultHexColor = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(defaultColor).toHsv();
      updateHandleFinal(defaultHexColor.s, defaultHexColor.v);
    } else updateHandleFinal(1, 1);

    saColorPicker.addEventListener("pointerdown", e => {
      e.preventDefault();
      originalPos = {
        x: parseFloat(saColorPickerHandle.style.left) + 8,
        y: parseFloat(saColorPickerHandle.style.top) + 8
      };
      let fillOrStroke;
      const state = addon.tab.redux.state;

      if (state.scratchPaint.modals.fillColor) {
        fillOrStroke = "fill";
      } else if (state.scratchPaint.modals.strokeColor) {
        fillOrStroke = "stroke";
      } else {
        fillOrStroke = "wh";
      }

      el = null;
      if (fillOrStroke === "fill") el = document.getElementsByClassName(addon.tab.scratchClass("color-button_color-button-swatch"))[0];else if (fillOrStroke === "stroke") el = document.getElementsByClassName(addon.tab.scratchClass("color-button_color-button-swatch"))[1];
      if (el) origHue = Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_3__["default"])(el.style.background).toHsv().h;
      updateHandle(e);
      window.addEventListener("pointermove", mousemovefunc);
      window.addEventListener("pointerup", mouseupfunc);
    });

    prevEventHandler = ({
      detail
    }) => {
      if (detail.action.type === "scratch-paint/color-index/CHANGE_COLOR_INDEX") {
        setTimeout(() => {
          updateColor();
        }, 100);
      }
    };

    addon.tab.redux.addEventListener("statechanged", prevEventHandler);
    saColorPicker.appendChild(saColorPickerImage);
    saColorPicker.appendChild(saColorPickerHandle);
    const [colorSlider, saturationSlider, brightnessSlider] = [...element.parentElement.querySelectorAll('[class^="color-picker_row-header"]')].map(i => i.parentElement);
    saturationSlider.style.display = "none";
    brightnessSlider.style.display = "none";
    colorSlider.insertAdjacentElement("afterend", saColorPicker);
    colorSlider.insertAdjacentElement("afterend", saColorLabel);
  }
});

/***/ }),

/***/ "./src/addons/addons/2d-color-picker/userscript.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/2d-color-picker/userscript.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paint_editor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paint-editor.js */ "./src/addons/addons/2d-color-picker/paint-editor.js");

/* harmony default export */ __webpack_exports__["default"] = (async api => {
  Object(_paint_editor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(api);
});

/***/ }),

/***/ "./src/addons/addons/bitmap-copy/userscript.js":
/*!*****************************************************!*\
  !*** ./src/addons/addons/bitmap-copy/userscript.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async ({
  addon,
  console
}) => {
  if (!addon.tab.redux.state) return console.warn("Redux is not available!");
  addon.tab.redux.initialize();
  addon.tab.redux.addEventListener("statechanged", ({
    detail
  }) => {
    const e = detail;
    if (!e.action || e.action.type !== "scratch-paint/clipboard/SET") return;
    const items = e.next.scratchPaint.clipboard.items;
    if (items.length !== 1) return;
    const firstItem = items[0]; // TODO vector support

    if (!Array.isArray(firstItem) || firstItem[0] !== "Raster") return console.log("copied element is vector");
    const dataURL = firstItem[1].source;
    addon.tab.copyImage(dataURL).then(() => console.log("Image successfully copied")).catch(e => console.error("Image could not be copied: ".concat(e)));
  });
});

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/block_icon.svg":
/*!********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/block_icon.svg ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/318e019bdee5ed02903aa5f22a9903f2.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/control_icon.svg":
/*!**********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/control_icon.svg ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/e1249124e702a974df36355af6aa2385.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/events_icon.svg":
/*!*********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/events_icon.svg ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/9d7acb2e5784a9a1d52e564af3d8469b.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/list_icon.svg":
/*!*******************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/list_icon.svg ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/bd6d382729ecbd23c5181cf2b327072f.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/looks_icon.svg":
/*!********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/looks_icon.svg ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/e008ee0cb1202de1137823150da1644a.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/motion_icon.svg":
/*!*********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/motion_icon.svg ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/c088896fb05dc466b45ecaa1d5c4d007.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/operators_icon.svg":
/*!************************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/operators_icon.svg ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/ab2c140af0ffba6b515eebc2156742e2.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/sensing_icon.svg":
/*!**********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/sensing_icon.svg ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/7601fa61034e5d7d542538e1e4338a4e.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/sound_icon.svg":
/*!********************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/sound_icon.svg ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/7b98085c05bdcd97dd0c6d4b34317793.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/tw_icon.svg":
/*!*****************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/tw_icon.svg ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/ce8ffc09dce132288116ec7d5a2d5f56.svg";

/***/ }),

/***/ "./src/addons/addons/block-palette-icons/icons/variables_icon.svg":
/*!************************************************************************!*\
  !*** ./src/addons/addons/block-palette-icons/icons/variables_icon.svg ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/4bfaa15915bc5fb88b40b3e1a537c3ea.svg";

/***/ }),

/***/ "./src/addons/addons/block-switching/blockToDom.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/block-switching/blockToDom.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * This file is imported from https://github.com/LLK/scratch-blocks/
 * It has been cleaned up and unnecessary functions have been removed.
 * Original license is below.
 *
 * @license
 * Visual Blocks Editor
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable */
const INPUT_VALUE = 1;
const NEXT_STATEMENT = 3;
const DUMMY_INPUT = 5; // Partially implements goog.dom.createDom.

const createDom = function createDom(tagName,
/* unused */
_params, children) {
  const element = document.createElement(tagName);

  if (children !== undefined) {
    if (!Array.isArray(children)) {
      children = [children];
    }

    for (const child of children) {
      if (typeof child === "string") {
        element.appendChild(document.createTextNode(child));
      } else {
        element.appendChild(child);
      }
    }
  }

  return element;
}; // Partially implements goog.dom.removeNode


const removeNode = node => {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
};

const fieldToDomVariable_ = function fieldToDomVariable_(field) {
  // The field had not been initialized fully before being serialized.
  // This can happen if a block is created directly through a call to
  // workspace.newBlock instead of from XML.
  // The new block will be serialized for the first time when firing a block
  // creation event.
  if (field.getValue() == null) {
    field.initModel();
  } // Get the variable directly from the field, instead of doing a lookup.  This
  // will work even if the variable has already been deleted.  This can happen
  // because the flyout defers deleting blocks until the next time the flyout is
  // opened.


  var variable = field.getVariable();

  if (!variable) {
    throw Error("Tried to serialize a variable field with no variable.");
  }

  var container = createDom("field", null, variable.name);
  container.setAttribute("name", field.name);
  container.setAttribute("id", variable.getId());
  container.setAttribute("variabletype", variable.type);
  return container;
};

const fieldToDom_ = function fieldToDom_(field) {
  if (field.name && field.SERIALIZABLE) {
    if (field.referencesVariables()) {
      return fieldToDomVariable_(field);
    } else {
      var container = createDom("field", null, field.getValue());
      container.setAttribute("name", field.name);
      return container;
    }
  }

  return null;
};

const allFieldsToDom_ = function allFieldsToDom_(block, element) {
  for (var i = 0, input; input = block.inputList[i]; i++) {
    for (var j = 0, field; field = input.fieldRow[j]; j++) {
      var fieldDom = fieldToDom_(field);

      if (fieldDom) {
        element.appendChild(fieldDom);
      }
    }
  }
};

const blockToDom = function blockToDom(block, opt_noId) {
  var element = createDom(block.isShadow() ? "shadow" : "block");
  element.setAttribute("type", block.type);

  if (!opt_noId) {
    element.setAttribute("id", block.id);
  }

  if (block.mutationToDom) {
    // Custom data for an advanced block.
    var mutation = block.mutationToDom();

    if (mutation && (mutation.hasChildNodes() || mutation.hasAttributes())) {
      element.appendChild(mutation);
    }
  }

  allFieldsToDom_(block, element);
  scratchCommentToDom_(block, element);

  if (block.data) {
    var dataElement = createDom("data", null, block.data);
    element.appendChild(dataElement);
  }

  for (var i = 0, input; input = block.inputList[i]; i++) {
    var container;
    var empty = true;

    if (input.type == DUMMY_INPUT) {
      continue;
    } else {
      var childBlock = input.connection.targetBlock();

      if (input.type == INPUT_VALUE) {
        container = createDom("value");
      } else if (input.type == NEXT_STATEMENT) {
        container = createDom("statement");
      }

      var shadow = input.connection.getShadowDom();

      if (shadow && (!childBlock || !childBlock.isShadow())) {
        var shadowClone = cloneShadow_(shadow); // Remove the ID from the shadow dom clone if opt_noId
        // is specified to true.

        if (opt_noId && shadowClone.getAttribute("id")) {
          shadowClone.removeAttribute("id");
        }

        container.appendChild(shadowClone);
      }

      if (childBlock) {
        container.appendChild(blockToDom(childBlock, opt_noId));
        empty = false;
      }
    }

    container.setAttribute("name", input.name);

    if (!empty) {
      element.appendChild(container);
    }
  }

  if (block.inputsInlineDefault != block.inputsInline) {
    element.setAttribute("inline", block.inputsInline);
  }

  if (block.isCollapsed()) {
    element.setAttribute("collapsed", true);
  }

  if (block.disabled) {
    element.setAttribute("disabled", true);
  }

  if (!block.isDeletable() && !block.isShadow()) {
    element.setAttribute("deletable", false);
  }

  if (!block.isMovable() && !block.isShadow()) {
    element.setAttribute("movable", false);
  }

  if (!block.isEditable()) {
    element.setAttribute("editable", false);
  }

  var nextBlock = block.getNextBlock();

  if (nextBlock) {
    var container = createDom("next", null, blockToDom(nextBlock, opt_noId));
    element.appendChild(container);
  }

  var shadow = block.nextConnection && block.nextConnection.getShadowDom();

  if (shadow && (!nextBlock || !nextBlock.isShadow())) {
    container.appendChild(cloneShadow_(shadow));
  }

  return element;
};

const scratchCommentToDom_ = function scratchCommentToDom_(block, element) {
  var commentText = block.getCommentText();

  if (commentText) {
    var commentElement = createDom("comment", null, commentText);

    if (typeof block.comment == "object") {
      commentElement.setAttribute("id", block.comment.id);
      commentElement.setAttribute("pinned", block.comment.isVisible());
      var hw; // TODO: scratch-blocks uses `block.comment instanceof Blockly.ScratchBlockComment`

      if (block.comment.getHeightWidth) {
        hw = block.comment.getHeightWidth();
      } else {
        hw = block.comment.getBubbleSize();
      }

      commentElement.setAttribute("h", hw.height);
      commentElement.setAttribute("w", hw.width);
      var xy = block.comment.getXY();
      commentElement.setAttribute("x", xy.x);
      commentElement.setAttribute("y", xy.y);
      commentElement.setAttribute("minimized", block.comment.isMinimized());
    }

    element.appendChild(commentElement);
  }
};

const cloneShadow_ = function cloneShadow_(shadow) {
  shadow = shadow.cloneNode(true); // Walk the tree looking for whitespace.  Don't prune whitespace in a tag.

  var node = shadow;
  var textNode;

  while (node) {
    if (node.firstChild) {
      node = node.firstChild;
    } else {
      while (node && !node.nextSibling) {
        textNode = node;
        node = node.parentNode;

        if (textNode.nodeType == 3 && textNode.data.trim() == "" && node.firstChild != textNode) {
          // Prune whitespace after a tag.
          removeNode(textNode);
        }
      }

      if (node) {
        textNode = node;
        node = node.nextSibling;

        if (textNode.nodeType == 3 && textNode.data.trim() == "") {
          // Prune whitespace before a tag.
          removeNode(textNode);
        }
      }
    }
  }

  return shadow;
};

const blockToDomWithXY = block => {
  const xml = blockToDom(block, false);
  const position = block.getRelativeToSurfaceXY();
  xml.setAttribute("x", Math.round(block.workspace.RTL ? -position.x : position.x));
  xml.setAttribute("y", Math.round(position.y));
  return xml;
};

/* harmony default export */ __webpack_exports__["default"] = (blockToDomWithXY);

/***/ }),

/***/ "./src/addons/addons/block-switching/userscript.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/block-switching/userscript.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _blockToDom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockToDom.js */ "./src/addons/addons/block-switching/blockToDom.js");

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  await addon.tab.traps.getBlockly();
  const blockSwitches = {};
  const noopSwitch = {
    opcode: "noop"
  };

  if (addon.settings.get("motion")) {
    blockSwitches["motion_turnright"] = [noopSwitch, {
      opcode: "motion_turnleft"
    }];
    blockSwitches["motion_turnleft"] = [{
      opcode: "motion_turnright"
    }, noopSwitch];
    blockSwitches["motion_setx"] = [noopSwitch, {
      opcode: "motion_changexby",
      remap: {
        X: "DX"
      }
    }, {
      opcode: "motion_sety",
      remap: {
        X: "Y"
      }
    }, {
      opcode: "motion_changeyby",
      remap: {
        X: "DY"
      }
    }];
    blockSwitches["motion_changexby"] = [{
      opcode: "motion_setx",
      remap: {
        DX: "X"
      }
    }, noopSwitch, {
      opcode: "motion_sety",
      remap: {
        DX: "Y"
      }
    }, {
      opcode: "motion_changeyby",
      remap: {
        DX: "DY"
      }
    }];
    blockSwitches["motion_sety"] = [{
      opcode: "motion_setx",
      remap: {
        Y: "X"
      }
    }, {
      opcode: "motion_changexby",
      remap: {
        Y: "DX"
      }
    }, noopSwitch, {
      opcode: "motion_changeyby",
      remap: {
        Y: "DY"
      }
    }];
    blockSwitches["motion_changeyby"] = [{
      opcode: "motion_setx",
      remap: {
        DY: "X"
      }
    }, {
      opcode: "motion_changexby",
      remap: {
        DY: "DX"
      }
    }, {
      opcode: "motion_sety",
      remap: {
        DY: "Y"
      }
    }, noopSwitch];
    blockSwitches["motion_xposition"] = [noopSwitch, {
      opcode: "motion_yposition"
    }];
    blockSwitches["motion_yposition"] = [{
      opcode: "motion_xposition"
    }, noopSwitch];
  }

  if (addon.settings.get("looks")) {
    blockSwitches["looks_seteffectto"] = [noopSwitch, {
      opcode: "looks_changeeffectby",
      remap: {
        VALUE: "CHANGE"
      }
    }];
    blockSwitches["looks_changeeffectby"] = [{
      opcode: "looks_seteffectto",
      remap: {
        CHANGE: "VALUE"
      }
    }, noopSwitch];
    blockSwitches["looks_setsizeto"] = [noopSwitch, {
      opcode: "looks_changesizeby",
      remap: {
        SIZE: "CHANGE"
      }
    }];
    blockSwitches["looks_changesizeby"] = [{
      opcode: "looks_setsizeto",
      remap: {
        CHANGE: "SIZE"
      }
    }, noopSwitch];
    blockSwitches["looks_costumenumbername"] = [noopSwitch, {
      opcode: "looks_backdropnumbername"
    }];
    blockSwitches["looks_backdropnumbername"] = [{
      opcode: "looks_costumenumbername"
    }, noopSwitch];
    blockSwitches["looks_show"] = [noopSwitch, {
      opcode: "looks_hide"
    }];
    blockSwitches["looks_hide"] = [{
      opcode: "looks_show"
    }, noopSwitch];
    blockSwitches["looks_nextcostume"] = [noopSwitch, {
      opcode: "looks_nextbackdrop"
    }];
    blockSwitches["looks_nextbackdrop"] = [{
      opcode: "looks_nextcostume"
    }, noopSwitch];
    blockSwitches["looks_think"] = [noopSwitch, {
      opcode: "looks_say"
    }];
    blockSwitches["looks_say"] = [{
      opcode: "looks_think"
    }, noopSwitch];
    blockSwitches["looks_thinkforsecs"] = [noopSwitch, {
      opcode: "looks_sayforsecs"
    }];
    blockSwitches["looks_sayforsecs"] = [{
      opcode: "looks_thinkforsecs"
    }, noopSwitch];
    blockSwitches["looks_switchbackdropto"] = [noopSwitch, {
      opcode: "looks_switchbackdroptoandwait"
    }];
    blockSwitches["looks_switchbackdroptoandwait"] = [{
      opcode: "looks_switchbackdropto"
    }, noopSwitch];
  }

  if (addon.settings.get("sound")) {
    blockSwitches["sound_play"] = [noopSwitch, {
      opcode: "sound_playuntildone"
    }];
    blockSwitches["sound_playuntildone"] = [{
      opcode: "sound_play"
    }, noopSwitch];
    blockSwitches["sound_seteffectto"] = [noopSwitch, {
      opcode: "sound_changeeffectby"
    }];
    blockSwitches["sound_changeeffectby"] = [{
      opcode: "sound_seteffectto"
    }, noopSwitch];
    blockSwitches["sound_setvolumeto"] = [noopSwitch, {
      opcode: "sound_changevolumeby"
    }];
    blockSwitches["sound_changevolumeby"] = [{
      opcode: "sound_setvolumeto"
    }, noopSwitch];
  }

  if (addon.settings.get("event")) {
    blockSwitches["event_broadcast"] = [noopSwitch, {
      opcode: "event_broadcastandwait"
    }];
    blockSwitches["event_broadcastandwait"] = [{
      opcode: "event_broadcast"
    }, noopSwitch];
  }

  if (addon.settings.get("control")) {
    blockSwitches["control_if"] = [noopSwitch, {
      opcode: "control_if_else"
    }];
    blockSwitches["control_if_else"] = [{
      opcode: "control_if",
      remap: {
        SUBSTACK2: "split"
      }
    }, noopSwitch];
    blockSwitches["control_repeat_until"] = [noopSwitch, {
      opcode: "control_wait_until",
      remap: {
        SUBSTACK: "split"
      }
    }, {
      opcode: "control_forever",
      remap: {
        CONDITION: "split"
      }
    }];
    blockSwitches["control_forever"] = [{
      opcode: "control_repeat_until"
    }, noopSwitch];
    blockSwitches["control_wait_until"] = [{
      opcode: "control_repeat_until"
    }, noopSwitch];
  }

  if (addon.settings.get("operator")) {
    blockSwitches["operator_equals"] = [{
      opcode: "operator_gt"
    }, noopSwitch, {
      opcode: "operator_lt"
    }];
    blockSwitches["operator_gt"] = [noopSwitch, {
      opcode: "operator_equals"
    }, {
      opcode: "operator_lt"
    }];
    blockSwitches["operator_lt"] = [{
      opcode: "operator_gt"
    }, {
      opcode: "operator_equals"
    }, noopSwitch];
    blockSwitches["operator_add"] = [noopSwitch, {
      opcode: "operator_subtract"
    }, {
      opcode: "operator_multiply"
    }, {
      opcode: "operator_divide"
    }, {
      opcode: "operator_mod"
    }];
    blockSwitches["operator_subtract"] = [{
      opcode: "operator_add"
    }, noopSwitch, {
      opcode: "operator_multiply"
    }, {
      opcode: "operator_divide"
    }, {
      opcode: "operator_mod"
    }];
    blockSwitches["operator_multiply"] = [{
      opcode: "operator_add"
    }, {
      opcode: "operator_subtract"
    }, noopSwitch, {
      opcode: "operator_divide"
    }, {
      opcode: "operator_mod"
    }];
    blockSwitches["operator_divide"] = [{
      opcode: "operator_add"
    }, {
      opcode: "operator_subtract"
    }, {
      opcode: "operator_multiply"
    }, noopSwitch, {
      opcode: "operator_mod"
    }];
    blockSwitches["operator_mod"] = [{
      opcode: "operator_add"
    }, {
      opcode: "operator_subtract"
    }, {
      opcode: "operator_multiply"
    }, {
      opcode: "operator_divide"
    }, noopSwitch];
    blockSwitches["operator_and"] = [noopSwitch, {
      opcode: "operator_or"
    }];
    blockSwitches["operator_or"] = [{
      opcode: "operator_and"
    }, noopSwitch];
  }

  if (addon.settings.get("sensing")) {
    blockSwitches["sensing_mousex"] = [noopSwitch, {
      opcode: "sensing_mousey"
    }];
    blockSwitches["sensing_mousey"] = [{
      opcode: "sensing_mousex"
    }, noopSwitch];
  }

  if (addon.settings.get("data")) {
    blockSwitches["data_setvariableto"] = [noopSwitch, {
      opcode: "data_changevariableby",
      remapValueType: {
        VALUE: "math_number"
      }
    }];
    blockSwitches["data_changevariableby"] = [{
      opcode: "data_setvariableto",
      remapValueType: {
        VALUE: "text"
      }
    }, noopSwitch];
    blockSwitches["data_showvariable"] = [noopSwitch, {
      opcode: "data_hidevariable"
    }];
    blockSwitches["data_hidevariable"] = [{
      opcode: "data_showvariable"
    }, noopSwitch];
    blockSwitches["data_showlist"] = [noopSwitch, {
      opcode: "data_hidelist"
    }];
    blockSwitches["data_hidelist"] = [{
      opcode: "data_showlist"
    }, noopSwitch];
    blockSwitches["data_replaceitemoflist"] = [noopSwitch, {
      opcode: "data_insertatlist"
    }];
    blockSwitches["data_insertatlist"] = [{
      opcode: "data_replaceitemoflist"
    }, noopSwitch];
  }

  if (addon.settings.get("extension")) {
    blockSwitches["pen_penDown"] = [noopSwitch, {
      opcode: "pen_penUp"
    }];
    blockSwitches["pen_penUp"] = [{
      opcode: "pen_penDown"
    }, noopSwitch];
    blockSwitches["pen_setPenColorParamTo"] = [noopSwitch, {
      opcode: "pen_changePenColorParamBy"
    }];
    blockSwitches["pen_changePenColorParamBy"] = [{
      opcode: "pen_setPenColorParamTo"
    }, noopSwitch];
    blockSwitches["pen_setPenHueToNumber"] = [noopSwitch, {
      opcode: "pen_changePenHueBy"
    }];
    blockSwitches["pen_changePenHueBy"] = [{
      opcode: "pen_setPenHueToNumber"
    }, noopSwitch];
    blockSwitches["pen_setPenShadeToNumber"] = [noopSwitch, {
      opcode: "pen_changePenShadeBy"
    }];
    blockSwitches["pen_changePenShadeBy"] = [{
      opcode: "pen_setPenShadeToNumber"
    }, noopSwitch];
    blockSwitches["pen_setPenSizeTo"] = [noopSwitch, {
      opcode: "pen_changePenSizeBy"
    }];
    blockSwitches["pen_changePenSizeBy"] = [{
      opcode: "pen_setPenSizeTo"
    }, noopSwitch];
    blockSwitches["music_setTempo"] = [noopSwitch, {
      opcode: "music_changeTempo"
    }];
    blockSwitches["music_changeTempo"] = [{
      opcode: "music_setTempo"
    }, noopSwitch];
  } // Switching for these is implemented by Scratch. We only define them here to optionally add a border.
  // Because we don't implement the switching ourselves, this is not controlled by the data category option.


  blockSwitches["data_variable"] = [];
  blockSwitches["data_listcontents"] = [];
  let addBorderToContextMenuItem = -1;

  const genuid = () => {
    const CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%()*+,-./:;=?@[]^_`{|}~";
    let result = "";

    for (let i = 0; i < 20; i++) {
      result += CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
    }

    return result;
  };

  const menuCallbackFactory = (block, opcodeData) => () => {
    if (opcodeData.opcode === "noop") {
      return;
    }

    const workspace = block.workspace; // Make a copy of the block with the proper type set.
    // It doesn't seem to be possible to change a Block's type after it's created, so we'll just make a new block instead.

    const xml = Object(_blockToDom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(block);
    xml.setAttribute("type", opcodeData.opcode);
    const id = block.id;
    const parent = block.getParent();
    let parentConnection;
    let blockConnectionType;

    if (parent) {
      // If the block has a parent, find the parent -> child connection that will be reattached later.
      const parentConnections = parent.getConnections_();
      parentConnection = parentConnections.find(c => c.targetConnection && c.targetConnection.sourceBlock_ === block); // There's two types of connections from child -> parent. We need to figure out which one is used.

      const blockConnections = block.getConnections_();
      const blockToParentConnection = blockConnections.find(c => c.targetConnection && c.targetConnection.sourceBlock_ === parent);
      blockConnectionType = blockToParentConnection.type;
    }

    const pasteSeparately = []; // Apply input remappings.

    if (opcodeData.remap) {
      for (const child of Array.from(xml.children)) {
        const oldName = child.getAttribute("name");
        const newName = opcodeData.remap[oldName];

        if (newName) {
          if (newName === "split") {
            // This input will be split off into its own script.
            const inputXml = child.firstChild;
            const inputId = inputXml.id;
            const inputBlock = workspace.getBlockById(inputId);
            const position = inputBlock.getRelativeToSurfaceXY();
            inputXml.setAttribute("x", Math.round(workspace.RTL ? -position.x : position.x));
            inputXml.setAttribute("y", Math.round(position.y));
            pasteSeparately.push(inputXml);
            xml.removeChild(child);
          } else {
            child.setAttribute("name", newName);
          }
        }
      }
    }

    if (opcodeData.remapValueType) {
      for (const child of Array.from(xml.children)) {
        const name = child.getAttribute("name");
        const newType = opcodeData.remapValueType[name];

        if (newType) {
          const valueNode = child.firstChild;
          const fieldNode = valueNode.firstChild;
          valueNode.setAttribute("type", newType);
          fieldNode.setAttribute("name", newType === "text" ? "TEXT" : "NUM");
        }
      }
    } // Mark the latest event in the undo stack.
    // This will be used later to group all of our events.


    const undoStack = workspace.undoStack_;

    if (undoStack.length) {
      undoStack[undoStack.length - 1]._blockswitchingLastUndo = true;
    } // Remove the old block and insert the new one.


    block.dispose();
    workspace.paste(xml);

    for (const separateBlock of pasteSeparately) {
      workspace.paste(separateBlock);
    } // The new block will have the same ID as the old one.


    const newBlock = workspace.getBlockById(id);

    if (parentConnection) {
      // Search for the same type of connection on the new block as on the old block.
      const newBlockConnections = newBlock.getConnections_();
      const newBlockConnection = newBlockConnections.find(c => c.type === blockConnectionType);
      newBlockConnection.connect(parentConnection);
    } // Events (responsible for undoStack updates) are delayed with a setTimeout(f, 0)
    // https://github.com/LLK/scratch-blocks/blob/f159a1779e5391b502d374fb2fdd0cb5ca43d6a2/core/events.js#L182


    setTimeout(() => {
      const group = genuid();

      for (let i = undoStack.length - 1; i >= 0 && !undoStack[i]._blockswitchingLastUndo; i--) {
        undoStack[i].group = group;
      }
    }, 0);
  };

  const customContextMenuHandler = function customContextMenuHandler(options) {
    if (addon.self.disabled) return;

    if (addon.settings.get("border")) {
      addBorderToContextMenuItem = options.length;
    }

    if (this._originalCustomContextMenu) {
      this._originalCustomContextMenu.call(this, options);
    }

    const switches = blockSwitches[this.type];

    for (const opcodeData of switches) {
      const isNoop = opcodeData.opcode === "noop";

      if (isNoop && !addon.settings.get("noop")) {
        continue;
      }

      const translationOpcode = isNoop ? this.type : opcodeData.opcode;
      const translation = msg(translationOpcode);
      options.push({
        enabled: true,
        text: translation,
        callback: menuCallbackFactory(this, opcodeData)
      });
    }
  };

  const injectCustomContextMenu = block => {
    const type = block.type;

    if (!Object.prototype.hasOwnProperty.call(blockSwitches, type)) {
      return;
    }

    if (block._customContextMenuInjected) {
      return;
    }

    block._customContextMenuInjected = true;

    if (block.customContextMenu) {
      block._originalCustomContextMenu = block.customContextMenu;
    }

    block.customContextMenu = customContextMenuHandler;
  };

  const changeListener = change => {
    if (change.type !== "create") {
      return;
    }

    for (const id of change.ids) {
      const block = Blockly.getMainWorkspace().getBlockById(id);
      if (!block) continue;
      injectCustomContextMenu(block);
    }
  };

  const mutationObserverCallback = mutations => {
    if (addon.self.disabled) return;

    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.classList.contains("blocklyContextMenu")) {
          if (addBorderToContextMenuItem === -1) {
            continue;
          }

          const children = node.children;
          const item = children[addBorderToContextMenuItem];

          if (item) {
            item.style.paddingTop = "2px";
            item.style.borderTop = "1px solid hsla(0, 0%, 0%, 0.15)";
          }

          addBorderToContextMenuItem = -1;
        }
      }
    }
  };

  const inject = () => {
    const workspace = Blockly.getMainWorkspace();

    if (workspace._blockswitchingInjected) {
      return;
    }

    mutationObserver.observe(document.querySelector(".blocklyWidgetDiv"), {
      childList: true
    });
    workspace._blockswitchingInjected = true;
    workspace.getAllBlocks().forEach(injectCustomContextMenu);
    workspace.addChangeListener(changeListener);
    const languageSelector = document.querySelector('[class^="language-selector_language-select"]');

    if (languageSelector) {
      languageSelector.addEventListener("change", () => {
        setTimeout(inject);
      });
    }
  };

  const mutationObserver = new MutationObserver(mutationObserverCallback);

  if (addon.tab.editorMode === "editor") {
    const interval = setInterval(() => {
      if (Blockly.getMainWorkspace()) {
        inject();
        clearInterval(interval);
      }
    }, 100);
  }

  addon.tab.addEventListener("urlChange", () => addon.tab.editorMode === "editor" && inject());
});

/***/ }),

/***/ "./src/addons/addons/blocks2image/userscript.js":
/*!******************************************************!*\
  !*** ./src/addons/addons/blocks2image/userscript.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  const buttonItem = [msg("export_selected_to_SVG"), msg("export_all_to_SVG"), msg("export_selected_to_PNG"), msg("export_all_to_PNG")];

  function eventMouseDown(e) {
    if (e.button === 2) {
      let blockSvg = e.target.closest("[data-id]");
      let isBackground = !blockSvg && e.target.closest("svg.blocklySvg");

      if (blockSvg || isBackground) {
        let dataId = blockSvg && blockSvg.getAttribute("data-id");

        if (dataId || isBackground) {
          setTimeout(async () => {
            let widget = document.querySelector("div.blocklyWidgetDiv");

            if (!widget) {
              return;
            }

            let blocklyContextMenu = widget.querySelector("div.blocklyContextMenu");

            if (!blocklyContextMenu) {
              return;
            }

            if (isBackground) {
              buttonItem.forEach((item, index) => {
                const wrapperItem = document.createElement("div");
                wrapperItem.id = "blocks2imgCommand".concat(index + 1);
                wrapperItem.classList.add("goog-menuitem", "blocks2img");
                if (addon.tab.direction === "rtl") wrapperItem.classList.add("goog-menuitem-rtl");

                wrapperItem.onmouseenter = () => wrapperItem.classList.add("goog-menuitem-highlight");

                wrapperItem.onmouseleave = () => wrapperItem.classList.remove("goog-menuitem-highlight");

                wrapperItem.style.userSelect = "none";

                if (index === 0) {
                  wrapperItem.style.borderTop = "1px solid hsla(0, 0%, 0%, 0.15)"; // resolve borderTop style conflict with goog-menuitem-highlight class

                  wrapperItem.style.borderBottom = "none";
                  wrapperItem.style.paddingTop = "4px";
                  wrapperItem.style.paddingBottom = "3px";
                }

                const menuItem = document.createElement("div");
                menuItem.classList.add("goog-menuitem-content");
                menuItem.style.userSelect = "user-select: none";
                menuItem.textContent = item;
                wrapperItem.append(menuItem);

                wrapperItem.onclick = () => {
                  hidePopups();
                  exportBlock({
                    command: "export" + (index + 1)
                  });
                };

                blocklyContextMenu.append(wrapperItem);
              });
            }

            if (blocklyContextMenu.children.length < 15) {
              blocklyContextMenu.style.maxHeight = "none";
              widget.style.height = blocklyContextMenu.getBoundingClientRect().height + 12 + "px";
              blocklyContextMenu.style.maxHeight = "";
            }

            function hidePopups() {
              const currentWorkspace = Blockly.getMainWorkspace();
              const element = currentWorkspace.getToolbox().HtmlDiv;
              element.dispatchEvent(new MouseEvent("mousedown", {
                relatedTarget: element,
                bubbles: true
              }));
              element.dispatchEvent(new MouseEvent("mouseup", {
                relatedTarget: element,
                bubbles: true
              }));
            }
          }, 1);
        }
      }
    }
  }

  document.addEventListener("mousedown", e => {
    if (e.target.closest("g.blocklyWorkspace")) {
      eventMouseDown(e);
    }
  }, true);

  function exportBlock(request, sender, sendMessage) {
    // console.log(request)
    let isExportPNG = request.command === "export3" || request.command === "export4"; // blocks-media as base64 for svg inline image

    let blocksMedia = new Map();
    blocksMedia.set("repeat.svg", "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIxLjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9InJlcGVhdCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDI0IDI0IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyNCAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiNDRjhCMTc7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8dGl0bGU+cmVwZWF0PC90aXRsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIzLjMsMTFjLTAuMywwLjYtMC45LDEtMS41LDFoLTEuNmMtMC4xLDEuMy0wLjUsMi41LTEuMSwzLjZjLTAuOSwxLjctMi4zLDMuMi00LjEsNC4xCgljLTEuNywwLjktMy42LDEuMi01LjUsMC45Yy0xLjgtMC4zLTMuNS0xLjEtNC45LTIuM2MtMC43LTAuNy0wLjctMS45LDAtMi42YzAuNi0wLjYsMS42LTAuNywyLjMtMC4ySDdjMC45LDAuNiwxLjksMC45LDIuOSwwLjkKCXMxLjktMC4zLDIuNy0wLjljMS4xLTAuOCwxLjgtMi4xLDEuOC0zLjVoLTEuNWMtMC45LDAtMS43LTAuNy0xLjctMS43YzAtMC40LDAuMi0wLjksMC41LTEuMmw0LjQtNC40YzAuNy0wLjYsMS43LTAuNiwyLjQsMEwyMyw5LjIKCUMyMy41LDkuNywyMy42LDEwLjQsMjMuMywxMXoiLz4KPHBhdGggY2xhc3M9InN0MSIgZD0iTTIxLjgsMTFoLTIuNmMwLDEuNS0wLjMsMi45LTEsNC4yYy0wLjgsMS42LTIuMSwyLjgtMy43LDMuNmMtMS41LDAuOC0zLjMsMS4xLTQuOSwwLjhjLTEuNi0wLjItMy4yLTEtNC40LTIuMQoJYy0wLjQtMC4zLTAuNC0wLjktMC4xLTEuMmMwLjMtMC40LDAuOS0wLjQsMS4yLTAuMWwwLDBjMSwwLjcsMi4yLDEuMSwzLjQsMS4xczIuMy0wLjMsMy4zLTFjMC45LTAuNiwxLjYtMS41LDItMi42CgljMC4zLTAuOSwwLjQtMS44LDAuMi0yLjhoLTIuNGMtMC40LDAtMC43LTAuMy0wLjctMC43YzAtMC4yLDAuMS0wLjMsMC4yLTAuNGw0LjQtNC40YzAuMy0wLjMsMC43LTAuMywwLjksMEwyMiw5LjgKCWMwLjMsMC4zLDAuNCwwLjYsMC4zLDAuOVMyMiwxMSwyMS44LDExeiIvPgo8L3N2Zz4K");
    blocksMedia.set("green-flag.svg", "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIxLjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9ImdyZWVuZmxhZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDI0IDI0IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyNCAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiM0NTk5M0Q7fQoJLnN0MXtmaWxsOiM0Q0JGNTY7fQo8L3N0eWxlPgo8dGl0bGU+Z3JlZW5mbGFnPC90aXRsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIwLjgsMy43Yy0wLjQtMC4yLTAuOS0wLjEtMS4yLDAuMmMtMiwxLjYtNC44LDEuNi02LjgsMGMtMi4zLTEuOS01LjYtMi4zLTguMy0xVjIuNWMwLTAuNi0wLjUtMS0xLTEKCXMtMSwwLjQtMSwxdjE4LjhjMCwwLjUsMC41LDEsMSwxaDAuMWMwLjUsMCwxLTAuNSwxLTF2LTYuNGMxLTAuNywyLjEtMS4yLDMuNC0xLjNjMS4yLDAsMi40LDAuNCwzLjQsMS4yYzIuOSwyLjMsNywyLjMsOS44LDAKCWMwLjMtMC4yLDAuNC0wLjUsMC40LTAuOVY0LjdDMjEuNiw0LjIsMjEuMywzLjgsMjAuOCwzLjd6IE0yMC41LDEzLjlDMjAuNSwxMy45LDIwLjUsMTMuOSwyMC41LDEzLjlDMTgsMTYsMTQuNCwxNiwxMS45LDE0CgljLTEuMS0wLjktMi41LTEuNC00LTEuNGMtMS4yLDAuMS0yLjMsMC41LTMuNCwxLjFWNEM3LDIuNiwxMCwyLjksMTIuMiw0LjZjMi40LDEuOSw1LjcsMS45LDguMSwwYzAuMSwwLDAuMSwwLDAuMiwwCgljMCwwLDAuMSwwLjEsMC4xLDAuMUwyMC41LDEzLjl6Ii8+CjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMC42LDQuOGwtMC4xLDkuMWMwLDAsMCwwLjEsMCwwLjFjLTIuNSwyLTYuMSwyLTguNiwwYy0xLjEtMC45LTIuNS0xLjQtNC0xLjRjLTEuMiwwLjEtMi4zLDAuNS0zLjQsMS4xVjQKCUM3LDIuNiwxMCwyLjksMTIuMiw0LjZjMi40LDEuOSw1LjcsMS45LDguMSwwYzAuMSwwLDAuMSwwLDAuMiwwQzIwLjUsNC43LDIwLjYsNC43LDIwLjYsNC44eiIvPgo8L3N2Zz4K");
    blocksMedia.set("rotate-left.svg", "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIGlkPSJyb3RhdGUtY2xvY2t3aXNlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHN0eWxlPi5jbHMtMXtmaWxsOiMzZDc5Y2M7fS5jbHMtMntmaWxsOiNmZmY7fTwvc3R5bGU+PHRpdGxlPnJvdGF0ZS1jbG9ja3dpc2U8L3RpdGxlPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIwLjM0LDE4LjIxYTEwLjI0LDEwLjI0LDAsMCwxLTguMSw0LjIyLDIuMjYsMi4yNiwwLDAsMS0uMTYtNC41MmgwYTUuNTgsNS41OCwwLDAsMCw0LjI1LTIuNTMsNS4wNiw1LjA2LDAsMCwwLC41NC00LjYyQTQuMjUsNC4yNSwwLDAsMCwxNS41NSw5YTQuMzEsNC4zMSwwLDAsMC0yLS44QTQuODIsNC44MiwwLDAsMCwxMC40LDlsMS4xMiwxLjQxQTEuNTksMS41OSwwLDAsMSwxMC4zNiwxM0gyLjY3YTEuNTYsMS41NiwwLDAsMS0xLjI2LS42M0ExLjU0LDEuNTQsMCwwLDEsMS4xMywxMUwyLjg1LDMuNTdBMS41OSwxLjU5LDAsMCwxLDQuMzgsMi40LDEuNTcsMS41NywwLDAsMSw1LjYyLDNMNi43LDQuMzVhMTAuNjYsMTAuNjYsMCwwLDEsNy43Mi0xLjY4QTkuODgsOS44OCwwLDAsMSwxOSw0LjgxLDkuNjEsOS42MSwwLDAsMSwyMS44Myw5LDEwLjA4LDEwLjA4LDAsMCwxLDIwLjM0LDE4LjIxWiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTE5LjU2LDE3LjY1YTkuMjksOS4yOSwwLDAsMS03LjM1LDMuODMsMS4zMSwxLjMxLDAsMCwxLS4wOC0yLjYyLDYuNTMsNi41MywwLDAsMCw1LTIuOTIsNi4wNSw2LjA1LDAsMCwwLC42Ny01LjUxLDUuMzIsNS4zMiwwLDAsMC0xLjY0LTIuMTYsNS4yMSw1LjIxLDAsMCwwLTIuNDgtMUE1Ljg2LDUuODYsMCwwLDAsOSw4Ljg0TDEwLjc0LDExYS41OS41OSwwLDAsMS0uNDMsMUgyLjdhLjYuNiwwLDAsMS0uNi0uNzVMMy44MSwzLjgzYS41OS41OSwwLDAsMSwxLS4yMWwxLjY3LDIuMWE5LjcxLDkuNzEsMCwwLDEsNy43NS0yLjA3LDguODQsOC44NCwwLDAsMSw0LjEyLDEuOTIsOC42OCw4LjY4LDAsMCwxLDIuNTQsMy43MkE5LjE0LDkuMTQsMCwwLDEsMTkuNTYsMTcuNjVaIi8+PC9zdmc+");
    blocksMedia.set("rotate-right.svg", "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIGlkPSJyb3RhdGUtY291bnRlci1jbG9ja3dpc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDI0IDI0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzNkNzljYzt9LmNscy0ye2ZpbGw6I2ZmZjt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPnJvdGF0ZS1jb3VudGVyLWNsb2Nrd2lzZTwvdGl0bGU+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMjIuNjgsMTIuMmExLjYsMS42LDAsMCwxLTEuMjcuNjNIMTMuNzJhMS41OSwxLjU5LDAsMCwxLTEuMTYtMi41OGwxLjEyLTEuNDFhNC44Miw0LjgyLDAsMCwwLTMuMTQtLjc3LDQuMzEsNC4zMSwwLDAsMC0yLC44LDQuMjUsNC4yNSwwLDAsMC0xLjM0LDEuNzMsNS4wNiw1LjA2LDAsMCwwLC41NCw0LjYyQTUuNTgsNS41OCwwLDAsMCwxMiwxNy43NGgwYTIuMjYsMi4yNiwwLDAsMS0uMTYsNC41MkExMC4yNSwxMC4yNSwwLDAsMSwzLjc0LDE4LDEwLjE0LDEwLjE0LDAsMCwxLDIuMjUsOC43OCw5LjcsOS43LDAsMCwxLDUuMDgsNC42NCw5LjkyLDkuOTIsMCwwLDEsOS42NiwyLjVhMTAuNjYsMTAuNjYsMCwwLDEsNy43MiwxLjY4bDEuMDgtMS4zNWExLjU3LDEuNTcsMCwwLDEsMS4yNC0uNiwxLjYsMS42LDAsMCwxLDEuNTQsMS4yMWwxLjcsNy4zN0ExLjU3LDEuNTcsMCwwLDEsMjIuNjgsMTIuMloiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMS4zOCwxMS44M0gxMy43N2EuNTkuNTksMCwwLDEtLjQzLTFsMS43NS0yLjE5YTUuOSw1LjksMCwwLDAtNC43LTEuNTgsNS4wNyw1LjA3LDAsMCwwLTQuMTEsMy4xN0E2LDYsMCwwLDAsNywxNS43N2E2LjUxLDYuNTEsMCwwLDAsNSwyLjkyLDEuMzEsMS4zMSwwLDAsMS0uMDgsMi42Miw5LjMsOS4zLDAsMCwxLTcuMzUtMy44MkE5LjE2LDkuMTYsMCwwLDEsMy4xNyw5LjEyLDguNTEsOC41MSwwLDAsMSw1LjcxLDUuNCw4Ljc2LDguNzYsMCwwLDEsOS44MiwzLjQ4YTkuNzEsOS43MSwwLDAsMSw3Ljc1LDIuMDdsMS42Ny0yLjFhLjU5LjU5LDAsMCwxLDEsLjIxTDIyLDExLjA4QS41OS41OSwwLDAsMSwyMS4zOCwxMS44M1oiLz48L3N2Zz4=");
    blocksMedia.set("dropdown-arrow.svg", "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=");
    let svg = document.createElement("svg");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttribute("xmlns:html", "http://www.w3.org/1999/xhtml");
    svg.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    svg.setAttribute("version", "1.1");
    let style = document.createElement("style");
    style.textContent = "\n    .blocklyText {\n        fill: #fff;\n        font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n        font-size: 12pt;\n        font-weight: 500;\n    }\n    .blocklyNonEditableText>text, .blocklyEditableText>text {\n        fill: #575E75;\n    }\n    .blocklyDropdownText {\n        fill: #fff !important;\n    }\n    ";

    if (request.command === "export1" || request.command === "export3") {
      svg = selectedBlocks(svg, style, isExportPNG);
    } else {
      svg = allBlocks(svg, style, isExportPNG);
    } // resolve nbsp whitespace


    let texts = Array.from(svg.getElementsByTagName("text"));
    texts.forEach(text => {
      text.innerHTML = text.innerHTML.replace(/&nbsp;/g, " ");
    }); // resolve image path

    let images = Array.from(svg.getElementsByTagName("image"));
    let scratchURL = window.location.origin;
    images.forEach(item => {
      let builtinSvgData = blocksMedia.get(item.getAttribute("xlink:href").substring(item.getAttribute("xlink:href").lastIndexOf("/") + 1));

      if (builtinSvgData) {
        // replace svg file path (official) to inline svg
        item.setAttribute("xlink:href", builtinSvgData);
      } else if (item.getAttribute("xlink:href").indexOf("/static/") === 0) {
        // replace link path for third party website
        item.setAttribute("xlink:href", scratchURL + item.getAttribute("xlink:href").slice(0));
      } else if (item.getAttribute("xlink:href").indexOf("./static/") === 0) {
        item.setAttribute("xlink:href", scratchURL + item.getAttribute("xlink:href").slice(1));
      } else if (item.getAttribute("xlink:href").indexOf("static/") === 0) {
        item.setAttribute("xlink:href", scratchURL + "/" + item.getAttribute("xlink:href"));
      }
    });
    let tmp = document.createElement("div");
    tmp.appendChild(svg);

    if (request.command === "export1" || request.command === "export2") {
      exportData(tmp.innerHTML);
    } else {
      exportPNG(svg);
    }
  }

  function selectedBlocks(svg, style, isExportPNG) {
    let svgchild = document.querySelector("svg.blocklySvg g.blocklySelected");

    if (!svgchild) {
      alert(msg("error_blocks_unselected"));
      throw new Error("Can not found selected blocks");
    }

    svgchild = svgchild.cloneNode(true);
    let dataShapes = svgchild.getAttribute("data-shapes");
    svgchild.setAttribute("transform", "translate(0,".concat(dataShapes === "hat" ? "18" : "0", ") ").concat(isExportPNG ? "scale(2)" : ""));
    svg.append(style);
    svg.append(svgchild);
    return svg;
  }

  function allBlocks(svg, style, isExportPNG) {
    var _svgchild, _svgchild$childNodes;

    let svgchild = document.querySelector("svg.blocklySvg g.blocklyBlockCanvas");
    svgchild = svgchild.cloneNode(true);
    let xArr = [];
    let yArr = [];

    if (!((_svgchild = svgchild) !== null && _svgchild !== void 0 && (_svgchild$childNodes = _svgchild.childNodes) !== null && _svgchild$childNodes !== void 0 && _svgchild$childNodes.length)) {
      alert(msg("error_blocks_not_added"));
      throw new Error("Workspace is empty");
    }

    svgchild.childNodes.forEach(g => {
      let x = g.getAttribute("transform").match(/translate\((.*?),(.*?)\)/)[1] || 0;
      let y = g.getAttribute("transform").match(/translate\((.*?),(.*?)\)/)[2] || 0;
      xArr.push(x * (isExportPNG ? 2 : 1));
      yArr.push(y * (isExportPNG ? 2 : 1));
      g.style.display = ""; // because of TW scratch-blocks changes
    });
    svgchild.setAttribute("transform", "translate(".concat(-Math.min(...xArr), ",").concat(-Math.min(...yArr) + 18 * (isExportPNG ? 2 : 1), ") ").concat(isExportPNG ? "scale(2)" : ""));
    svg.append(style);
    svg.append(svgchild);
    return svg;
  }

  function exportData(text) {
    const saveLink = document.createElement("a");
    document.body.appendChild(saveLink);
    const data = new Blob([text], {
      type: "text"
    });
    const url = window.URL.createObjectURL(data);
    saveLink.href = url; // File name: project-DATE-TIME

    const date = new Date();
    const timestamp = "".concat(date.toLocaleDateString(), "-").concat(date.toLocaleTimeString());
    saveLink.download = "block_".concat(timestamp, ".svg");
    saveLink.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(saveLink);
  }

  function exportPNG(svg) {
    const div = document.createElement("div");
    div.appendChild(svg);
    const iframe = document.createElement("iframe"); // iframe.style.display = "none"

    document.body.append(iframe);
    iframe.contentDocument.write(div.innerHTML);
    let {
      width,
      height
    } = iframe.contentDocument.body.querySelector("svg g").getBoundingClientRect();
    height = height + 20 * 2; //  hat block height restore

    svg.setAttribute("width", width + "px");
    svg.setAttribute("height", height + "px");
    let canvas = document.createElement("canvas");
    let ctx = canvas.getContext("2d");
    let img = document.createElement("img");
    img.setAttribute("src", "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(div.innerHTML))));

    img.onload = function () {
      canvas.height = img.height;
      canvas.width = img.width;
      ctx.drawImage(img, 0, 0, img.width, img.height); // Now is done

      let dataURL = canvas.toDataURL("image/png");
      let link = document.createElement("a");
      const date = new Date();
      const timestamp = "".concat(date.toLocaleDateString(), "-").concat(date.toLocaleTimeString());
      link.download = "block_".concat(timestamp, ".png");
      link.href = dataURL;
      link.click();
      iframe.remove();
    };
  }
});

/***/ }),

/***/ "./src/addons/addons/cat-blocks/userscript.js":
/*!****************************************************!*\
  !*** ./src/addons/addons/cat-blocks/userscript.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Based on https://github.com/LLK/scratch-blocks/compare/hotfix/totally-normal-2021 (Apache 2.0)
 * It has been modified to work properly in our environment and fix some bugs.
 */
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  const Blockly = await addon.tab.traps.getBlockly();
  const shouldWatchMouseCursor = addon.settings.get("watch");
  Blockly.BlockSvg.START_HAT_HEIGHT = 31;
  Blockly.BlockSvg.START_HAT_PATH = "c2.6,-2.3 5.5,-4.3 8.5,-6.2" + "c-1,-12.5 5.3,-23.3 8.4,-24.8c3.7,-1.8 16.5,13.1 18.4,15.4" + "c8.4,-1.3 17,-1.3 25.4,0c1.9,-2.3 14.7,-17.2 18.4,-15.4" + "c3.1,1.5 9.4,12.3 8.4,24.8c3,1.8 5.9,3.9 8.5,6.1";
  Blockly.BlockSvg.TOP_LEFT_CORNER_DEFINE_HAT = "c0,-7.1 3.7,-13.3 9.3,-16.9c1.7,-7.5 5.4,-13.2 7.6,-14.2" + "c2.6,-1.3 10,6 14.6,11.1h33c4.6,-5.1 11.9,-12.4 14.6,-11.1" + "c1.9,0.9 4.9,5.2 6.8,11.1c2.6,0,5.2,0,7.8,0";

  Blockly.BlockSvg.prototype.renderCatFace_ = function () {
    this.catPath_.svgFace.setAttribute("fill", "#000000");
    var closedEye = Blockly.utils.createSvgElement("path", {}, this.svgFace_);
    closedEye.setAttribute("d", "M25.2-1.1c0.1,0,0.2,0,0.2,0l8.3-2.1l-7-4.8" + "c-0.5-0.3-1.1-0.2-1.4,0.3s-0.2,1.1,0.3,1.4L29-4.1l-4,1" + "c-0.5,0.1-0.9,0.7-0.7,1.2C24.3-1.4,24.7-1.1,25.2-1.1z");
    closedEye.setAttribute("fill-opacity", "0");
    this.catPath_.svgFace.closedEye = closedEye;
    var closedEye2 = Blockly.utils.createSvgElement("path", {}, this.svgFace_);
    closedEye2.setAttribute("d", "M62.4-1.1c-0.1,0-0.2,0-0.2,0l-8.3-2.1l7-4.8" + "c0.5-0.3,1.1-0.2,1.4,0.3s0.2,1.1-0.3,1.4l-3.4,2.3l4,1" + "c0.5,0.1,0.9,0.7,0.7,1.2C63.2-1.4,62.8-1.1,62.4-1.1z");
    closedEye2.setAttribute("fill-opacity", "0");
    this.catPath_.svgFace.closedEye2 = closedEye2;
    var eye = Blockly.utils.createSvgElement("circle", {}, this.svgFace_);
    eye.setAttribute("cx", "59.2");
    eye.setAttribute("cy", "-3.3");
    eye.setAttribute("r", "3.4");
    eye.setAttribute("fill-opacity", "0.6");
    this.catPath_.svgFace.eye = eye;
    var eye2 = Blockly.utils.createSvgElement("circle", {}, this.svgFace_);
    eye2.setAttribute("cx", "29.1");
    eye2.setAttribute("cy", "-3.3");
    eye2.setAttribute("r", "3.4");
    eye2.setAttribute("fill-opacity", "0.6");
    this.catPath_.svgFace.eye2 = eye2;
    var mouth = Blockly.utils.createSvgElement("path", {}, this.svgFace_);
    mouth.setAttribute("d", "M45.6,0.1c-0.9,0-1.7-0.3-2.3-0.9" + "c-0.6,0.6-1.3,0.9-2.2,0.9c-0.9,0-1.8-0.3-2.3-0.9c-1-1.1-1.1-2.6-1.1-2.8" + "c0-0.5,0.5-1,1-1l0,0c0.6,0,1,0.5,1,1c0,0.4,0.1,1.7,1.4,1.7" + "c0.5,0,0.7-0.2,0.8-0.3c0.3-0.3,0.4-1,0.4-1.3c0-0.1,0-0.1,0-0.2" + "c0-0.5,0.5-1,1-1l0,0c0.5,0,1,0.4,1,1c0,0,0,0.1,0,0.2" + "c0,0.3,0.1,0.9,0.4,1.2C44.8-2.2,45-2,45.5-2s0.7-0.2,0.8-0.3" + "c0.3-0.4,0.4-1.1,0.3-1.3c0-0.5,0.4-1,0.9-1.1c0.5,0,1,0.4,1.1,0.9" + "c0,0.2,0.1,1.8-0.8,2.8C47.5-0.4,46.8,0.1,45.6,0.1z");
    mouth.setAttribute("fill-opacity", "0.6");
    this.catPath_.ear.setAttribute("d", "M73.1-15.6c1.7-4.2,4.5-9.1,5.8-8.5" + "c1.6,0.8,5.4,7.9,5,15.4c0,0.6-0.7,0.7-1.1,0.5c-3-1.6-6.4-2.8-8.6-3.6" + "C72.8-12.3,72.4-13.7,73.1-15.6z");
    this.catPath_.ear.setAttribute("fill", "#FFD5E6");
    this.catPath_.ear2.setAttribute("d", "M22.4-15.6c-1.7-4.2-4.5-9.1-5.8-8.5" + "c-1.6,0.8-5.4,7.9-5,15.4c0,0.6,0.7,0.7,1.1,0.5c3-1.6,6.4-2.8,8.6-3.6" + "C22.8-12.3,23.2-13.7,22.4-15.6z");
    this.catPath_.ear2.setAttribute("fill", "#FFD5E6");
  };

  Blockly.BlockSvg.prototype.initCatStuff = function () {
    if (this.hasInitCatStuff) return;
    this.hasInitCatStuff = true; // Ear part of the SVG path for hat blocks

    var LEFT_EAR_UP = "c-1,-12.5 5.3,-23.3 8.4,-24.8c3.7,-1.8 16.5,13.1 18.4,15.4";
    var LEFT_EAR_DOWN = "c-5.8,-4.8 -8,-18 -4.9,-19.5c3.7,-1.8 24.5,11.1 31.7,10.1";
    var RIGHT_EAR_UP = "c1.9,-2.3 14.7,-17.2 18.4,-15.4c3.1,1.5 9.4,12.3 8.4,24.8";
    var RIGHT_EAR_DOWN = "c7.2,1 28,-11.9 31.7,-10.1c3.1,1.5 0.9,14.7 -4.9,19.5"; // Ears look slightly different for define hat blocks

    var DEFINE_HAT_LEFT_EAR_UP = "c0,-7.1 3.7,-13.3 9.3,-16.9c1.7,-7.5 5.4,-13.2 7.6,-14.2c2.6,-1.3 10,6 14.6,11.1";
    var DEFINE_HAT_RIGHT_EAR_UP = "h33c4.6,-5.1 11.9,-12.4 14.6,-11.1c1.9,0.9 4.9,5.2 6.8,11.1c2.6,0,5.2,0,7.8,0";
    var DEFINE_HAT_LEFT_EAR_DOWN = "c0,-4.6 1.6,-8.9 4.3,-12.3c-2.4,-5.6 -2.9,-12.4 -0.7,-13.4c2.1,-1 9.6,2.6 17,5.8" + "c2.6,0 6.2,0 10.9,0";
    var DEFINE_HAT_RIGHT_EAR_DOWN = "c0,0 25.6,0 44,0c7.4,-3.2 14.8,-6.8 16.9,-5.8c1.2,0.6 1.6,2.9 1.3,5.8";
    var that = this;
    this.catPath_.ear = Blockly.utils.createSvgElement("path", {}, this.catPath_);
    this.catPath_.ear2 = Blockly.utils.createSvgElement("path", {}, this.catPath_);

    if (this.RTL) {
      // Mirror the ears.
      this.catPath_.ear.setAttribute("transform", "scale(-1 1)");
      this.catPath_.ear2.setAttribute("transform", "scale(-1 1)");
    }

    this.catPath_.addEventListener("mouseenter", function (event) {
      clearTimeout(that.blinkFn); // blink

      if (event.target.svgFace.eye) {
        event.target.svgFace.eye.setAttribute("fill-opacity", "0");
        event.target.svgFace.eye2.setAttribute("fill-opacity", "0");
        event.target.svgFace.closedEye.setAttribute("fill-opacity", "0.6");
        event.target.svgFace.closedEye2.setAttribute("fill-opacity", "0.6");
      } // reset after a short delay


      that.blinkFn = setTimeout(function () {
        if (event.target.svgFace.eye) {
          event.target.svgFace.eye.setAttribute("fill-opacity", "0.6");
          event.target.svgFace.eye2.setAttribute("fill-opacity", "0.6");
          event.target.svgFace.closedEye.setAttribute("fill-opacity", "0");
          event.target.svgFace.closedEye2.setAttribute("fill-opacity", "0");
        }
      }, 100);
    });
    this.catPath_.ear.addEventListener("mouseenter", function () {
      clearTimeout(that.earFn);
      clearTimeout(that.ear2Fn); // ear flick

      that.catPath_.ear.setAttribute("fill-opacity", "0");
      that.catPath_.ear2.setAttribute("fill-opacity", "");
      var bodyPath = that.catPath_.svgBody.getAttribute("d");
      bodyPath = bodyPath.replace(RIGHT_EAR_UP, RIGHT_EAR_DOWN);
      bodyPath = bodyPath.replace(DEFINE_HAT_RIGHT_EAR_UP, DEFINE_HAT_RIGHT_EAR_DOWN);
      bodyPath = bodyPath.replace(LEFT_EAR_DOWN, LEFT_EAR_UP);
      bodyPath = bodyPath.replace(DEFINE_HAT_LEFT_EAR_DOWN, DEFINE_HAT_LEFT_EAR_UP);
      that.catPath_.svgBody.setAttribute("d", bodyPath); // reset after a short delay

      that.earFn = setTimeout(function () {
        that.catPath_.ear.setAttribute("fill-opacity", "");
        var bodyPath = that.catPath_.svgBody.getAttribute("d");
        bodyPath = bodyPath.replace(RIGHT_EAR_DOWN, RIGHT_EAR_UP);
        bodyPath = bodyPath.replace(DEFINE_HAT_RIGHT_EAR_DOWN, DEFINE_HAT_RIGHT_EAR_UP);
        that.catPath_.svgBody.setAttribute("d", bodyPath);
      }, 50);
    });
    this.catPath_.ear2.addEventListener("mouseenter", function () {
      clearTimeout(that.earFn);
      clearTimeout(that.ear2Fn); // ear flick

      that.catPath_.ear2.setAttribute("fill-opacity", "0");
      that.catPath_.ear.setAttribute("fill-opacity", "");
      var bodyPath = that.catPath_.svgBody.getAttribute("d");
      bodyPath = bodyPath.replace(LEFT_EAR_UP, LEFT_EAR_DOWN);
      bodyPath = bodyPath.replace(DEFINE_HAT_LEFT_EAR_UP, DEFINE_HAT_LEFT_EAR_DOWN);
      bodyPath = bodyPath.replace(RIGHT_EAR_DOWN, RIGHT_EAR_UP);
      bodyPath = bodyPath.replace(DEFINE_HAT_RIGHT_EAR_DOWN, DEFINE_HAT_RIGHT_EAR_UP);
      that.catPath_.svgBody.setAttribute("d", bodyPath); // reset after a short delay

      that.ear2Fn = setTimeout(function () {
        that.catPath_.ear2.setAttribute("fill-opacity", "");
        var bodyPath = that.catPath_.svgBody.getAttribute("d");
        bodyPath = bodyPath.replace(LEFT_EAR_DOWN, LEFT_EAR_UP);
        bodyPath = bodyPath.replace(DEFINE_HAT_LEFT_EAR_DOWN, DEFINE_HAT_LEFT_EAR_UP);
        that.catPath_.svgBody.setAttribute("d", bodyPath);
      }, 50);
    });

    if (this.RTL) {
      // Set to the correct initial position
      this.svgFace_.style.transform = "translate(-87px, 0px)";
    }

    if (this.shouldWatchMouse()) {
      this.windowListener = function (event) {
        var time = Date.now();
        if (time < that.lastCallTime + that.CALL_FREQUENCY_MS) return;
        that.lastCallTime = time;
        if (!that.shouldWatchMouse()) return; // mouse watching

        if (that.workspace) {
          // not disposed
          var xy = that.getCatFacePosition();
          var mouseLocation = {
            x: event.x / that.workspace.scale,
            y: event.y / that.workspace.scale
          };
          var dx = mouseLocation.x - xy.x;
          var dy = mouseLocation.y - xy.y;
          var theta = Math.atan2(dx, dy); // Map the vector from the cat face to the mouse location to a much shorter
          // vector in the same direction, which will be the translation vector for
          // the cat face

          var delta = Math.sqrt(dx * dx + dy * dy);
          var scaleFactor = delta / (delta + 1); // Equation for radius of ellipse at theta for axes with length a and b

          var a = 2;
          var b = 5;
          var r = a * b / Math.sqrt(Math.pow(b * Math.cos(theta), 2) + Math.pow(a * Math.sin(theta), 2)); // Convert polar coordinate back to x, y coordinate

          dx = r * scaleFactor * Math.sin(theta);
          dy = r * scaleFactor * Math.cos(theta);
          if (that.RTL) dx -= 87; // Translate face over

          that.svgFace_.style.transform = "translate(" + dx + "px, " + dy + "px)";
        }
      };

      document.addEventListener("mousemove", this.windowListener);
    }
  };

  let workspacePositionRect = null;

  Blockly.BlockSvg.prototype.getCatFacePosition = function () {
    // getBoundingClientRect is not performant
    //var offset = that.workspace.getParentSvg().getBoundingClientRect();
    if (!workspacePositionRect) {
      workspacePositionRect = this.workspace.getParentSvg().getBoundingClientRect();
    }

    var offset = {
      x: workspacePositionRect.x,
      y: workspacePositionRect.y
    };

    if (!this.isInFlyout && this.workspace.getFlyout()) {
      offset.x += this.workspace.getFlyout().getWidth();
    }

    offset.x += this.workspace.scrollX;
    offset.y += this.workspace.scrollY;
    var xy = this.getRelativeToSurfaceXY(this.svgGroup_);

    if (this.RTL) {
      xy.x = this.workspace.getWidth() - xy.x - this.width;
    } // convert to workspace units


    xy.x += offset.x / this.workspace.scale;
    xy.y += offset.y / this.workspace.scale; // distance to center of face

    xy.x -= 43.5;
    xy.y -= 4; // flyout category offset

    xy.x += 60;

    if (this.RTL) {
      // We've been calculating from the right edge. Convert x to from left edge.
      xy.x = screen.width - xy.x;
    }

    return xy;
  };

  Blockly.BlockSvg.prototype.shouldWatchMouse = function () {
    if (!shouldWatchMouseCursor) return false; // if (window.vmLoadHigh || !window.CAT_CHASE_MOUSE) return false;

    var xy = this.getCatFacePosition();
    const MARGIN = 50;
    var blockXOnScreen = xy.x > -MARGIN && xy.x - MARGIN < screen.width / this.workspace.scale;
    var blockYOnScreen = xy.y > -MARGIN && xy.y - MARGIN < screen.height / this.workspace.scale;
    return this.startHat_ && !this.isGlowingStack_ && blockXOnScreen && blockYOnScreen;
  };

  const originalRenderDraw = Blockly.BlockSvg.prototype.renderDraw_;

  Blockly.BlockSvg.prototype.renderDraw_ = function (...args) {
    if (!this.svgFace_) {
      this.sa_catBlockConstructor();
    }

    const r = originalRenderDraw.call(this, ...args);

    if (!this.outputConnection && !this.previousConnection) {
      this.initCatStuff();
    }

    if (this.startHat_ && !this.svgFace_.firstChild) {
      this.renderCatFace_();
    }

    return r;
  };

  const originalDispose = Blockly.BlockSvg.prototype.dispose;

  Blockly.BlockSvg.prototype.dispose = function (...args) {
    clearTimeout(this.blinkFn);
    clearTimeout(this.earFn);
    clearTimeout(this.ear2Fn);

    if (this.windowListener) {
      document.removeEventListener("mousemove", this.windowListener);
    }

    return originalDispose.call(this, ...args);
  };

  const originalSetGlowStack = Blockly.BlockSvg.prototype.setGlowStack;

  Blockly.BlockSvg.prototype.setGlowStack = function (isGlowingStack) {
    if (this.windowListener) {
      if (isGlowingStack) {
        // For performance, don't follow the mouse when the stack is glowing
        document.removeEventListener("mousemove", this.windowListener);

        if (this.workspace && this.svgFace_.style) {
          // reset face direction
          if (this.RTL) {
            this.svgFace_.style.transform = "translate(-87px, 0px)";
          } else {
            this.svgFace_.style.transform = "";
          }
        }
      } else {
        document.addEventListener("mousemove", this.windowListener);
      }
    }

    return originalSetGlowStack.call(this, isGlowingStack);
  };

  Blockly.BlockSvg.prototype.sa_catBlockConstructor = function () {
    this.catPath_ = Blockly.utils.createSvgElement("g", {}, this.svgGroup_);
    this.svgFace_ = Blockly.utils.createSvgElement("g", {}, this.catPath_);
    this.catPath_.svgFace = this.svgFace_;
    this.catPath_.svgBody = this.svgPath_;
    this.lastCallTime = 0;
    this.CALL_FREQUENCY_MS = 60;
  };

  const workspace = Blockly.getMainWorkspace();

  if (workspace) {
    const vm = addon.tab.traps.vm;

    if (vm.editingTarget) {
      vm.emitWorkspaceUpdate();
    }

    const flyout = workspace.getFlyout();

    if (flyout) {
      const flyoutWorkspace = flyout.getWorkspace();
      Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.Xml.workspaceToDom(flyoutWorkspace), flyoutWorkspace);
      workspace.getToolbox().refreshSelection();
      workspace.toolboxRefreshEnabled_ = true;
    }
  }
});

/***/ }),

/***/ "./src/addons/addons/clones/300cats.svg":
/*!**********************************************!*\
  !*** ./src/addons/addons/clones/300cats.svg ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/60fb267c5ab0c6f4ed9ab4a891ca7dd5.svg";

/***/ }),

/***/ "./src/addons/addons/clones/cat.svg":
/*!******************************************!*\
  !*** ./src/addons/addons/clones/cat.svg ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/8a30520407ffdf5b0e7e06e490db9c1d.svg";

/***/ }),

/***/ "./src/addons/addons/clones/userscript.js":
/*!************************************************!*\
  !*** ./src/addons/addons/clones/userscript.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  const vm = addon.tab.traps.vm;

  if (addon.tab.redux.state && addon.tab.redux.state.scratchGui.stageSize.stageSize === "small") {
    document.body.classList.add("sa-clones-small");
  }

  document.addEventListener("click", e => {
    if (e.target.closest("[class*='stage-header_stage-button-first']")) {
      document.body.classList.add("sa-clones-small");
    } else if (e.target.closest("[class*='stage-header_stage-button-last']")) {
      document.body.classList.remove("sa-clones-small");
    }
  }, {
    capture: true
  });
  let countContainerContainer = document.createElement("div");
  addon.tab.displayNoneWhileDisabled(countContainerContainer);
  let countContainer = document.createElement("div");
  let count = document.createElement("span");
  let icon = document.createElement("span");
  countContainerContainer.className = "clone-container-container";
  countContainer.className = "clone-container";
  count.className = "clone-count";
  icon.className = "clone-icon";
  countContainerContainer.appendChild(icon);
  countContainerContainer.appendChild(countContainer);
  countContainer.appendChild(count);
  let lastChecked = 0;
  const cache = Array(301).fill().map((_, i) => msg("clones", {
    cloneCount: i
  }));

  function doCloneChecks() {
    const v = vm.runtime._cloneCounter; // performance

    if (v === lastChecked) return;
    countContainerContainer.dataset.count = lastChecked = v;
    count.dataset.str = cache[v] || msg("clones", {
      cloneCount: v
    });
    if (v === 0) countContainerContainer.style.display = "none";else countContainerContainer.style.display = "flex";
  }

  vm.runtime.on("targetWasRemoved", t => {
    // Fix bug with inaccurate clone counter
    if (t.isOriginal) vm.runtime.changeCloneCounter(1);
  });
  const oldStep = vm.runtime.constructor.prototype._step;

  vm.runtime.constructor.prototype._step = function (...args) {
    const ret = oldStep.call(this, ...args);
    doCloneChecks();
    return ret;
  };

  while (true) {
    let bar = await addon.tab.waitForElement('[class*="controls_controls-container"]', {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });

    if (addon.tab.editorMode === "editor") {
      bar.appendChild(countContainerContainer);
    }
  }
});

/***/ }),

/***/ "./src/addons/addons/color-picker/code-editor.js":
/*!*******************************************************!*\
  !*** ./src/addons/addons/color-picker/code-editor.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libraries/common/cs/normalize-color.js */ "./src/addons/libraries/common/cs/normalize-color.js");
/* harmony import */ var _libraries_common_cs_rate_limiter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libraries/common/cs/rate-limiter.js */ "./src/addons/libraries/common/cs/rate-limiter.js");
/* harmony import */ var _libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libraries/thirdparty/cs/tinycolor-min.js */ "./src/addons/libraries/thirdparty/cs/tinycolor-min.js");



/* harmony default export */ __webpack_exports__["default"] = (async ({
  addon,
  console,
  msg
}) => {
  // 250-ms rate limit
  const rateLimiter = new _libraries_common_cs_rate_limiter_js__WEBPACK_IMPORTED_MODULE_1__["default"](250);

  const getColor = element => {
    const {
      children
    } = element.parentElement; // h: 0 - 360

    const h = children[1].getAttribute("aria-valuenow"); // s: 0 - 1

    const s = children[3].getAttribute("aria-valuenow"); // v: 0 - 255, divide by 255

    const vMultipliedBy255 = children[5].getAttribute("aria-valuenow");
    const v = Number(vMultipliedBy255) / 255;
    return Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_2__["default"])("hsv(".concat(h, ", ").concat(s, ", ").concat(v || 0, ")")).toHexString();
  };

  const setColor = (hex, element) => {
    hex = Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__["normalizeHex"])(hex);
    if (!addon.tab.redux.state || !addon.tab.redux.state.scratchGui) return; // The only way to reliably set color is to invoke eye dropper via click()
    // then faking that the eye dropper reported the value.

    const onEyeDropperClosed = ({
      detail
    }) => {
      if (detail.action.type !== "scratch-gui/color-picker/DEACTIVATE_COLOR_PICKER") return;
      addon.tab.redux.removeEventListener("statechanged", onEyeDropperClosed);
      setTimeout(() => {
        document.body.classList.remove("sa-hide-eye-dropper-background");
      }, 50);
    };

    const onEyeDropperOpened = ({
      detail
    }) => {
      if (detail.action.type !== "scratch-gui/color-picker/ACTIVATE_COLOR_PICKER") return;
      addon.tab.redux.removeEventListener("statechanged", onEyeDropperOpened);
      addon.tab.redux.addEventListener("statechanged", onEyeDropperClosed);
      setTimeout(() => {
        addon.tab.redux.dispatch({
          type: "scratch-gui/color-picker/DEACTIVATE_COLOR_PICKER",
          color: hex
        });
      }, 50);
    };

    addon.tab.redux.addEventListener("statechanged", onEyeDropperOpened);
    document.body.classList.add("sa-hide-eye-dropper-background");
    element.click();
  };

  const addColorPicker = () => {
    const element = document.querySelector("button.scratchEyedropper");
    rateLimiter.abort(false);
    addon.tab.redux.initialize();
    const defaultColor = getColor(element);
    const saColorPicker = Object.assign(document.createElement("div"), {
      className: "sa-color-picker sa-color-picker-code"
    });
    const saColorPickerColor = Object.assign(document.createElement("input"), {
      className: "sa-color-picker-color sa-color-picker-code-color",
      type: "color",
      value: defaultColor || "#000000"
    });
    const saColorPickerText = Object.assign(document.createElement("input"), {
      className: addon.tab.scratchClass("input_input-form", {
        others: "sa-color-picker-text sa-color-picker-code-text"
      }),
      type: "text",
      pattern: "^#?([0-9a-fA-F]{3}){1,2}$",
      placeholder: msg("hex"),
      value: defaultColor || ""
    });
    saColorPickerColor.addEventListener("input", () => rateLimiter.limit(() => setColor(saColorPickerText.value = saColorPickerColor.value, element)));
    saColorPickerText.addEventListener("change", () => {
      const {
        value
      } = saColorPickerText;
      if (!Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__["getHexRegex"])().test(value)) return;
      setColor(saColorPickerColor.value = Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__["normalizeHex"])(value), element);
    });
    saColorPicker.appendChild(saColorPickerColor);
    saColorPicker.appendChild(saColorPickerText);
    element.parentElement.insertBefore(saColorPicker, element);
  };

  const ScratchBlocks = await addon.tab.traps.getBlockly();
  const originalShowEditor = ScratchBlocks.FieldColourSlider.prototype.showEditor_;

  ScratchBlocks.FieldColourSlider.prototype.showEditor_ = function (...args) {
    const r = originalShowEditor.call(this, ...args);
    addColorPicker();
    return r;
  };
});

/***/ }),

/***/ "./src/addons/addons/color-picker/paint-editor.js":
/*!********************************************************!*\
  !*** ./src/addons/addons/color-picker/paint-editor.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libraries/common/cs/normalize-color.js */ "./src/addons/libraries/common/cs/normalize-color.js");
/* harmony import */ var _libraries_common_cs_rate_limiter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libraries/common/cs/rate-limiter.js */ "./src/addons/libraries/common/cs/rate-limiter.js");
/* harmony import */ var _libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libraries/thirdparty/cs/tinycolor-min.js */ "./src/addons/libraries/thirdparty/cs/tinycolor-min.js");



/* harmony default export */ __webpack_exports__["default"] = (async ({
  addon,
  console,
  msg
}) => {
  let prevEventHandler; // 250-ms rate limit

  const rateLimiter = new _libraries_common_cs_rate_limiter_js__WEBPACK_IMPORTED_MODULE_1__["default"](250);

  const getColor = element => {
    let fillOrStroke;
    const state = addon.tab.redux.state;

    if (state.scratchPaint.modals.fillColor) {
      fillOrStroke = "fill";
    } else if (state.scratchPaint.modals.strokeColor) {
      fillOrStroke = "stroke";
    } else {
      // fillOrStroke = "ihadastroke";
      return;
    }

    const colorType = state.scratchPaint.fillMode.colorIndex;
    const primaryOrSecondary = ["primary", "secondary"][colorType];
    const color = state.scratchPaint.color["".concat(fillOrStroke, "Color")][primaryOrSecondary];
    if (color === null || color === "scratch-paint/style-path/mixed") return; // This value can be arbitrary - it can be HEX, RGB, etc.
    // Use tinycolor to convert them.

    return Object(_libraries_thirdparty_cs_tinycolor_min_js__WEBPACK_IMPORTED_MODULE_2__["default"])(color).toHexString();
  };

  const setColor = (hex, element) => {
    hex = Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__["normalizeHex"])(hex);
    if (!addon.tab.redux.state || !addon.tab.redux.state.scratchPaint) return; // The only way to reliably set color is to invoke eye dropper via click()
    // then faking that the eye dropper reported the value.

    const onEyeDropperOpened = ({
      detail
    }) => {
      if (detail.action.type !== "scratch-paint/eye-dropper/ACTIVATE_COLOR_PICKER") return;
      addon.tab.redux.removeEventListener("statechanged", onEyeDropperOpened);
      setTimeout(() => {
        const previousTool = addon.tab.redux.state.scratchPaint.color.eyeDropper.previousTool;
        if (previousTool) previousTool.activate();
        addon.tab.redux.state.scratchPaint.color.eyeDropper.callback(hex);
        addon.tab.redux.dispatch({
          type: "scratch-paint/eye-dropper/DEACTIVATE_COLOR_PICKER"
        });
      }, 50);
    };

    addon.tab.redux.addEventListener("statechanged", onEyeDropperOpened);
    element.children[1].children[0].click();
  };

  while (true) {
    const element = await addon.tab.waitForElement('div[class*="color-picker_swatch-row"]', {
      markAsSeen: true,
      reduxCondition: state => state.scratchGui.editorTab.activeTabIndex === 1 && !state.scratchGui.mode.isPlayerOnly
    });
    rateLimiter.abort(false);
    addon.tab.redux.initialize();

    if (addon.tab.redux && typeof prevEventHandler === "function") {
      addon.tab.redux.removeEventListener("statechanged", prevEventHandler);
      prevEventHandler = null;
    }

    if (addon.tab.editorMode !== "editor") continue;
    const defaultColor = getColor(element);
    const saColorPicker = Object.assign(document.createElement("div"), {
      className: "sa-color-picker sa-color-picker-paint"
    });
    const saColorPickerColor = Object.assign(document.createElement("input"), {
      className: "sa-color-picker-color sa-color-picker-paint-color",
      type: "color",
      value: defaultColor || "#000000"
    });
    const inputClass = document.querySelector('[class*="fixed-tools_costume-input"]').className.split(" ")[0];
    const saColorPickerText = Object.assign(document.createElement("input"), {
      className: "sa-color-picker-text sa-color-picker-paint-text ".concat(inputClass),
      type: "text",
      pattern: "^#[0-9a-fA-F]{3,8}$",
      placeholder: msg("hex"),
      value: defaultColor || ""
    });
    saColorPickerColor.addEventListener("input", () => rateLimiter.limit(() => setColor(saColorPickerText.value = saColorPickerColor.value, element)));
    saColorPickerText.addEventListener("change", () => {
      const {
        value
      } = saColorPickerText;
      if (!Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__["getHexRegex"])().test(value)) return;
      setColor(saColorPickerColor.value = Object(_libraries_common_cs_normalize_color_js__WEBPACK_IMPORTED_MODULE_0__["normalizeHex"])(value), element);
    });

    prevEventHandler = ({
      detail
    }) => {
      if (detail.action.type === "scratch-paint/color-index/CHANGE_COLOR_INDEX") {
        setTimeout(() => {
          const color = getColor(element);
          saColorPickerColor.value = color || "#000000";
          saColorPickerText.value = color || "";
        }, 100);
      }
    };

    addon.tab.redux.addEventListener("statechanged", prevEventHandler);
    saColorPicker.appendChild(saColorPickerColor);
    saColorPicker.appendChild(saColorPickerText);
    element.parentElement.insertBefore(saColorPicker, element);
  }
});

/***/ }),

/***/ "./src/addons/addons/color-picker/userscript.js":
/*!******************************************************!*\
  !*** ./src/addons/addons/color-picker/userscript.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _code_editor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-editor.js */ "./src/addons/addons/color-picker/code-editor.js");

/* harmony default export */ __webpack_exports__["default"] = (async api => {
  Object(_code_editor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(api);
});

/***/ }),

/***/ "./src/addons/addons/custom-block-shape/userscript.js":
/*!************************************************************!*\
  !*** ./src/addons/addons/custom-block-shape/userscript.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  var BlocklyInstance = await addon.tab.traps.getBlockly();

  (function (Blockly) {
    const BlockSvg = BlocklyInstance.BlockSvg;
    var vm = addon.tab.traps.vm;
    const {
      GRID_UNIT
    } = BlockSvg;
    var multiplier;
    var cornerSize;
    var notchSize;

    function updateAllBlocks() {
      const workspace = Blockly.getMainWorkspace();

      if (workspace) {
        if (vm.editingTarget) {
          vm.emitWorkspaceUpdate();
        }

        const flyout = workspace.getFlyout();

        if (flyout) {
          const flyoutWorkspace = flyout.getWorkspace();
          Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.Xml.workspaceToDom(flyoutWorkspace), flyoutWorkspace);
          workspace.getToolbox().refreshSelection();
          workspace.toolboxRefreshEnabled_ = true;
        }
      }
    }

    function applyChanges() {
      multiplier = addon.settings.get("paddingSize") / 100;
      cornerSize = addon.settings.get("cornerSize") / 100;
      notchSize = addon.settings.get("notchSize") / 100;
      BlockSvg.SEP_SPACE_Y = 2 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_X = 16 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_X_OUTPUT = 12 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_X_SHADOW_OUTPUT = 10 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_Y = 12 * GRID_UNIT * multiplier;
      BlockSvg.EXTRA_STATEMENT_ROW_Y = 8 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_X_WITH_STATEMENT = 40 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_Y_SINGLE_FIELD_OUTPUT = 8 * GRID_UNIT * multiplier;
      BlockSvg.MIN_BLOCK_Y_REPORTER = 10 * GRID_UNIT * multiplier;
      BlockSvg.MIN_STATEMENT_INPUT_HEIGHT = 6 * GRID_UNIT * multiplier;
      BlockSvg.NOTCH_WIDTH = 8 * GRID_UNIT * multiplier;
      BlockSvg.NOTCH_HEIGHT = 2 * GRID_UNIT * multiplier * notchSize;
      BlockSvg.NOTCH_START_PADDING = 3 * GRID_UNIT; //* multiplier

      BlockSvg.ICON_SEPARATOR_HEIGHT = 10 * GRID_UNIT * multiplier;
      BlockSvg.NOTCH_PATH_LEFT = "c 2,0 3," + 1 * notchSize + " 4," + 2 * notchSize + " l " + 4 * multiplier * notchSize + "," + 4 * multiplier * notchSize + " c 1," + 1 * notchSize + " 2," + 2 * notchSize + " 4," + 2 * notchSize + " h " + 24 * (multiplier - 0.5) + " c 2,0 3,-" + 1 * notchSize + " 4,-" + 2 * notchSize + " l " + 4 * multiplier * notchSize + "," + -4 * multiplier * notchSize + "c 1,-" + 1 * notchSize + " 2,-" + 2 * notchSize + " 4,-" + 2 * notchSize;
      BlockSvg.NOTCH_PATH_RIGHT = "h " + (-4 * (cornerSize - 1) - 5 * (1 - notchSize)) + "c -2,0 -3," + 1 * notchSize + " -4," + 2 * notchSize + " l " + -4 * multiplier * notchSize + "," + 4 * multiplier * notchSize + " c -1," + 1 * notchSize + " -2," + 2 * notchSize + " -4," + 2 * notchSize + " h " + -24 * (multiplier - 0.5) + " c -2,0 -3,-" + 1 * notchSize + " -4,-" + 2 * notchSize + " l " + -4 * multiplier * notchSize + "," + -4 * multiplier * notchSize + "c -1,-" + 1 * notchSize + " -2,-" + 2 * notchSize + " -4,-" + 2 * notchSize;
      BlockSvg.INPUT_SHAPE_HEXAGONAL = "M " + 4 * GRID_UNIT * multiplier + ",0 " + " h " + 4 * GRID_UNIT + " l " + 4 * GRID_UNIT * multiplier + "," + 4 * GRID_UNIT * multiplier + " l " + -4 * GRID_UNIT * multiplier + "," + 4 * GRID_UNIT * multiplier + " h " + -4 * GRID_UNIT + " l " + -4 * GRID_UNIT * multiplier + "," + -4 * GRID_UNIT * multiplier + " l " + 4 * GRID_UNIT * multiplier + "," + -4 * GRID_UNIT * multiplier + " z";
      BlockSvg.INPUT_SHAPE_HEXAGONAL_WIDTH = 12 * GRID_UNIT * multiplier;
      BlockSvg.INPUT_SHAPE_ROUND = "M " + 4 * GRID_UNIT + ",0" + " h " + 4 * GRID_UNIT + " a " + 4 * GRID_UNIT + " " + 4 * GRID_UNIT + " 0 0 1 0 " + 8 * GRID_UNIT + " h " + -4 * GRID_UNIT + " a " + 4 * GRID_UNIT + " " + 4 * GRID_UNIT + " 0 0 1 0 -" + 8 * GRID_UNIT + " z";
      BlockSvg.INPUT_SHAPE_ROUND_WIDTH = 12 * GRID_UNIT * multiplier;
      BlockSvg.INPUT_SHAPE_HEIGHT = 8 * GRID_UNIT * multiplier;
      BlockSvg.FIELD_HEIGHT = 8 * GRID_UNIT * multiplier; // NOTE: Determines string input heights

      BlockSvg.FIELD_WIDTH = 6 * GRID_UNIT * Math.min(multiplier, 1) + 10 * GRID_UNIT * Math.max(multiplier - 1, 0);
      BlockSvg.FIELD_DEFAULT_CORNER_RADIUS = 4 * GRID_UNIT * multiplier;
      BlockSvg.EDITABLE_FIELD_PADDING = 1.5 * GRID_UNIT * multiplier;
      BlockSvg.BOX_FIELD_PADDING = 2 * GRID_UNIT * multiplier;
      BlockSvg.DROPDOWN_ARROW_PADDING = 2 * GRID_UNIT * multiplier;
      BlockSvg.FIELD_WIDTH_MIN_EDIT = 8 * GRID_UNIT * multiplier;
      BlockSvg.INPUT_AND_FIELD_MIN_X = 12 * GRID_UNIT * multiplier;
      BlockSvg.INLINE_PADDING_Y = 1 * GRID_UNIT * multiplier; // For when reporters are inside reporters

      BlockSvg.SHAPE_IN_SHAPE_PADDING[1][0] = 5 * GRID_UNIT * multiplier;
      BlockSvg.SHAPE_IN_SHAPE_PADDING[1][2] = 5 * GRID_UNIT * multiplier;
      BlockSvg.SHAPE_IN_SHAPE_PADDING[1][3] = 5 * GRID_UNIT * multiplier;
      var originalDropdownObject = BlocklyInstance.FieldDropdown.prototype.positionArrow;

      BlocklyInstance.FieldDropdown.prototype.positionArrow = function (x) {
        this.arrowY_ = 11 * multiplier;
        return originalDropdownObject.call(this, x);
      }; //Corner setting


      BlockSvg.CORNER_RADIUS = 1 * GRID_UNIT * addon.settings.get("cornerSize") / 100;
      BlockSvg.TOP_LEFT_CORNER_START = "m 0," + BlockSvg.CORNER_RADIUS;
      BlockSvg.TOP_LEFT_CORNER = "A " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS + " 0 0,1 " + BlockSvg.CORNER_RADIUS + ",0";
      BlockSvg.TOP_RIGHT_CORNER = "a " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS + " 0 0,1 " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS;
      BlockSvg.BOTTOM_RIGHT_CORNER = " a " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS + " 0 0,1 -" + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS;
      BlockSvg.BOTTOM_LEFT_CORNER = "a " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS + " 0 0,1 -" + BlockSvg.CORNER_RADIUS + ",-" + BlockSvg.CORNER_RADIUS;
      BlockSvg.INNER_TOP_LEFT_CORNER = " a " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS + " 0 0,0 -" + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS;
      BlockSvg.INNER_BOTTOM_LEFT_CORNER = "a " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS + " 0 0,0 " + BlockSvg.CORNER_RADIUS + "," + BlockSvg.CORNER_RADIUS;
      BlockSvg.TOP_RIGHT_CORNER_DEFINE_HAT = "a " + BlockSvg.DEFINE_HAT_CORNER_RADIUS + "," + BlockSvg.DEFINE_HAT_CORNER_RADIUS + " 0 0,1 " + BlockSvg.DEFINE_HAT_CORNER_RADIUS + "," + BlockSvg.DEFINE_HAT_CORNER_RADIUS + " v " + (1 * GRID_UNIT - BlockSvg.CORNER_RADIUS);
      BlockSvg.STATEMENT_INPUT_INNER_SPACE = 2.8 * GRID_UNIT - 0.9 * GRID_UNIT * cornerSize;
    }

    function applyAndUpdate() {
      applyChanges();
      updateAllBlocks();
    }

    addon.settings.addEventListener("change", function () {
      applyAndUpdate();
    });
    applyAndUpdate();
  })(window.Blockly);
});

/***/ }),

/***/ "./src/addons/addons/custom-zoom/userscript.js":
/*!*****************************************************!*\
  !*** ./src/addons/addons/custom-zoom/userscript.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  await addon.tab.traps.getBlockly();
  let controlsRect;
  let previousIsHovered = false;
  const speeds = {
    none: "0s",
    short: "0.25s",
    default: "0.5s",
    long: "1s"
  };
  const customZoomAreaElement = document.createElement("div");
  customZoomAreaElement.className = "sa-custom-zoom-area";

  function update() {
    document.removeEventListener("mousemove", onMouseMove);
    if (addon.tab.editorMode !== "editor") return;
    Blockly.getMainWorkspace().options.zoomOptions.maxScale = addon.settings.get("maxZoom") / 100;
    Blockly.getMainWorkspace().options.zoomOptions.minScale = addon.settings.get("minZoom") / 100;
    Blockly.getMainWorkspace().options.zoomOptions.startScale = addon.settings.get("startZoom") / 100;
    Blockly.getMainWorkspace().options.zoomOptions.scaleSpeed = 1 + 0.2 * (addon.settings.get("zoomSpeed") / 100);
    const svgGroup = getZoomControls();
    const autohide = addon.settings.get("autohide");
    if (svgGroup) svgGroup.classList.toggle("sa-custom-zoom-hidden", autohide);

    if (autohide) {
      const injectionDiv = document.querySelector(".injectionDiv");
      injectionDiv.appendChild(customZoomAreaElement);
      updateRect();
      document.addEventListener("mousemove", onMouseMove);
    }
  }

  function getZoomControls() {
    const zoomControls = Blockly.getMainWorkspace().zoomControls_;
    if (zoomControls) return zoomControls.svgGroup_;
    return null;
  }

  function onMouseMove(e) {
    const isHovered = e.x > controlsRect.left && e.x < controlsRect.right && e.y > controlsRect.top && e.y < controlsRect.bottom;

    if (isHovered !== previousIsHovered) {
      previousIsHovered = isHovered;
      const svgGroup = getZoomControls();

      if (svgGroup) {
        svgGroup.style.setProperty("--sa-custom-zoom-speed", speeds[addon.settings.get("speed")]);
        svgGroup.classList.toggle("sa-custom-zoom-hidden", !isHovered);
      }
    }
  }

  function updateRect() {
    controlsRect = customZoomAreaElement.getBoundingClientRect();
  }

  function onResize() {
    if (addon.tab.editorMode === "editor" && addon.settings.get("autohide")) {
      updateRect();
    }
  }

  await addon.tab.waitForElement(".blocklyZoom");

  if (document.querySelector('[class^="backpack_backpack-container"]')) {
    window.dispatchEvent(new Event("resize"));
  }

  update();
  addon.tab.addEventListener("urlChange", update);
  addon.settings.addEventListener("change", update);
  window.addEventListener("resize", onResize);
});

/***/ }),

/***/ "./src/addons/addons/data-category-tweaks-v2/userscript.js":
/*!*****************************************************************!*\
  !*** ./src/addons/addons/data-category-tweaks-v2/userscript.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg,
  safeMsg
}) {
  const ScratchBlocks = await addon.tab.traps.getBlockly();
  const SMALL_GAP = 8;
  const BIG_GAP = 24;
  const vm = addon.tab.traps.vm; // Used in setting change handler. Updated in getBlocksXML.
  // (Yes this is weird but it's how it was originally and I'm too scared to change it)

  let hasSeparateListCategory = false;

  const separateVariablesByType = toolboxXML => {
    const listButtonIndex = toolboxXML.findIndex(i => i.getAttribute("callbackkey") === "CREATE_LIST" || i.getAttribute("type") === "data_addtolist");
    return {
      variables: toolboxXML.slice(0, listButtonIndex),
      lists: toolboxXML.slice(listButtonIndex, toolboxXML.length)
    };
  };

  const separateLocalVariables = (workspace, toolboxXML) => {
    const {
      variables,
      lists
    } = separateVariablesByType(toolboxXML);

    const makeLabel = l10n => {
      const label = document.createElement("label");
      label.setAttribute("text", msg(l10n));
      return label;
    };

    const fixGaps = variables => {
      if (variables.length > 0) {
        for (var i = 0; i < variables.length - 1; i++) {
          variables[i].setAttribute("gap", SMALL_GAP);
        }

        variables[i].setAttribute("gap", BIG_GAP);
      }
    };

    const separateVariablesByScope = xml => {
      const before = [];
      const global = [];
      const local = [];
      const after = [];

      for (const blockXML of xml) {
        if (blockXML.hasAttribute("id")) {
          const id = blockXML.getAttribute("id");
          const variable = workspace.getVariableById(id);

          if (!variable || !variable.isLocal) {
            global.push(blockXML);
          } else {
            local.push(blockXML);
          }
        } else if (global.length || local.length) {
          after.push(blockXML);
        } else {
          before.push(blockXML);
        }
      }

      const result = before;

      if (global.length) {
        result.push(makeLabel("for-all-sprites"));
        fixGaps(global);
        result.push(...global);
      }

      if (local.length) {
        result.push(makeLabel("for-this-sprite-only"));
        fixGaps(local);
        result.push(...local);
      }

      return result.concat(after);
    };

    return separateVariablesByScope(variables).concat(separateVariablesByScope(lists));
  };

  const moveReportersDown = toolboxXML => {
    const {
      variables,
      lists
    } = separateVariablesByType(toolboxXML);

    const moveReportersToEnd = xml => {
      const reporters = [];
      const everythingElse = [];

      for (const blockXML of xml) {
        if (blockXML.hasAttribute("id") || blockXML.tagName === "BUTTON") {
          // Round reporters and the create variable button
          reporters.push(blockXML);
        } else {
          // Everything else like "change variable by 1"
          everythingElse.push(blockXML);
        }
      }

      if (everythingElse.length) {
        everythingElse[everythingElse.length - 1].setAttribute("gap", BIG_GAP);
      }

      return everythingElse.concat(reporters);
    };

    return moveReportersToEnd(variables).concat(moveReportersToEnd(lists));
  };

  const DataCategory = ScratchBlocks.DataCategory;
  let variableCategory;
  let listCategory;

  const variableCategoryCallback = workspace => {
    let result = DataCategory(workspace);

    if (addon.settings.get("moveReportersDown")) {
      result = moveReportersDown(result);
    }

    if (addon.settings.get("separateLocalVariables")) {
      result = separateLocalVariables(workspace, result);
    }

    if (!hasSeparateListCategory) {
      return result;
    }

    const {
      variables,
      lists
    } = separateVariablesByType(result);
    variableCategory = variables;
    listCategory = lists;
    return variableCategory;
  };

  const listCategoryCallback = () => {
    // Computed in variable category callback, which should be called before this method.
    return listCategory;
  }; // Each time a new workspace is made, these callbacks are reset, so re-register whenever a flyout is shown.
  // https://github.com/LLK/scratch-blocks/blob/61f02e4cac0f963abd93013842fe536ef24a0e98/core/flyout_base.js#L469


  const oldShow = ScratchBlocks.Flyout.prototype.show;

  ScratchBlocks.Flyout.prototype.show = function (xmlList) {
    this.workspace_.registerToolboxCategoryCallback("VARIABLE", variableCategoryCallback);
    this.workspace_.registerToolboxCategoryCallback("LIST", listCategoryCallback);
    return oldShow.call(this, xmlList);
  }; // Use Scratch's extension category mechanism to replace the data category with our own.
  // https://github.com/LLK/scratch-gui/blob/ddd2fa06f2afa140a46ec03be91796ded861e65c/src/containers/blocks.jsx#L344
  // https://github.com/LLK/scratch-gui/blob/2ceab00370ad7bd8ecdf5c490e70fd02152b3e2a/src/lib/make-toolbox-xml.js#L763
  // https://github.com/LLK/scratch-vm/blob/a0c11d6d8664a4f2d55632e70630d09ec6e9ae28/src/engine/runtime.js#L1381


  const originalGetBlocksXML = vm.runtime.getBlocksXML;

  vm.runtime.getBlocksXML = function (target) {
    const result = originalGetBlocksXML.call(this, target);
    hasSeparateListCategory = addon.settings.get("separateListCategory");

    if (hasSeparateListCategory) {
      result.push({
        id: "data",
        xml: "\n        <category\n          name=\"%{BKY_CATEGORY_VARIABLES}\"\n          id=\"variables\"\n          colour=\"#FF8C1A\"\n          secondaryColour=\"#DB6E00\"\n          custom=\"VARIABLE\">\n        </category>\n        <category\n          name=\"".concat(safeMsg("list-category"), "\"\n          id=\"lists\"\n          colour=\"#FF661A\"\n          secondaryColour=\"#FF5500\"\n          custom=\"LIST\">\n        </category>")
      });
    }

    return result;
  }; // If editingTarget is set, the editor has already rendered and we have to tell it to rerender.


  if (vm.editingTarget) {
    vm.emitWorkspaceUpdate();
  }

  addon.settings.addEventListener("change", e => {
    // When the separate list category option changes, we need to do a workspace update.
    // For all other options, just refresh the toolbox.
    // Always doing both of these in response to a settings change causes many issues.
    if (addon.settings.get("separateListCategory") !== hasSeparateListCategory) {
      if (vm.editingTarget) {
        vm.emitWorkspaceUpdate();
      }
    } else {
      const workspace = Blockly.getMainWorkspace();

      if (workspace) {
        workspace.refreshToolboxSelection_();
      }
    }
  });
});

/***/ }),

/***/ "./src/addons/addons/debugger/add.svg":
/*!********************************************!*\
  !*** ./src/addons/addons/debugger/add.svg ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/455223e1a9618fe4f791df0e4551169d.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/debug-unread.svg":
/*!*****************************************************!*\
  !*** ./src/addons/addons/debugger/debug-unread.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/d0441b753c807751826d68d84895782b.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/debug.svg":
/*!**********************************************!*\
  !*** ./src/addons/addons/debugger/debug.svg ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/8d6ca9b4f4cc4dc9092037a605c33778.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/delete.svg":
/*!***********************************************!*\
  !*** ./src/addons/addons/debugger/delete.svg ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/42331b999633094b4072c9c67e5d14e4.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/download-white.svg":
/*!*******************************************************!*\
  !*** ./src/addons/addons/debugger/download-white.svg ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/6c2d79195b3f2cc87e6155b166674a25.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/error.svg":
/*!**********************************************!*\
  !*** ./src/addons/addons/debugger/error.svg ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/76b6cb627b95d79705c0b41664064f0e.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/play.svg":
/*!*********************************************!*\
  !*** ./src/addons/addons/debugger/play.svg ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/22e4dbb6a50a0e9f7409245d5983a5c9.svg";

/***/ }),

/***/ "./src/addons/addons/debugger/userscript.js":
/*!**************************************************!*\
  !*** ./src/addons/addons/debugger/userscript.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add.svg */ "./src/addons/addons/debugger/add.svg");
/* harmony import */ var _add_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_add_svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _debug_unread_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-unread.svg */ "./src/addons/addons/debugger/debug-unread.svg");
/* harmony import */ var _debug_unread_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_debug_unread_svg__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _debug_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug.svg */ "./src/addons/addons/debugger/debug.svg");
/* harmony import */ var _debug_svg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_debug_svg__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _delete_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delete.svg */ "./src/addons/addons/debugger/delete.svg");
/* harmony import */ var _delete_svg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_delete_svg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _download_white_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./download-white.svg */ "./src/addons/addons/debugger/download-white.svg");
/* harmony import */ var _download_white_svg__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_download_white_svg__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _error_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./error.svg */ "./src/addons/addons/debugger/error.svg");
/* harmony import */ var _error_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_error_svg__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _play_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./play.svg */ "./src/addons/addons/debugger/play.svg");
/* harmony import */ var _play_svg__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_play_svg__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _warning_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./warning.svg */ "./src/addons/addons/debugger/warning.svg");
/* harmony import */ var _warning_svg__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_warning_svg__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _libraries_common_cs_download_blob_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../libraries/common/cs/download-blob.js */ "./src/addons/libraries/common/cs/download-blob.js");
/* harmony import */ var _pause_module_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../pause/module.js */ "./src/addons/addons/pause/module.js");
/* inserted by pull.js */









const _twGetAsset = path => {
  if (path === "/add.svg") return _add_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  if (path === "/debug-unread.svg") return _debug_unread_svg__WEBPACK_IMPORTED_MODULE_1___default.a;
  if (path === "/debug.svg") return _debug_svg__WEBPACK_IMPORTED_MODULE_2___default.a;
  if (path === "/delete.svg") return _delete_svg__WEBPACK_IMPORTED_MODULE_3___default.a;
  if (path === "/download-white.svg") return _download_white_svg__WEBPACK_IMPORTED_MODULE_4___default.a;
  if (path === "/error.svg") return _error_svg__WEBPACK_IMPORTED_MODULE_5___default.a;
  if (path === "/play.svg") return _play_svg__WEBPACK_IMPORTED_MODULE_6___default.a;
  if (path === "/warning.svg") return _warning_svg__WEBPACK_IMPORTED_MODULE_7___default.a;
  throw new Error("Unknown asset: ".concat(path));
};



/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  let showingConsole, ScratchBlocks;
  const vm = addon.tab.traps.vm;
  const container = document.createElement("div");
  container.className = "sa-debugger-container";
  const buttonContainer = document.createElement("div");
  buttonContainer.className = addon.tab.scratchClass("button_outlined-button", "stage-header_stage-button");
  const buttonContent = document.createElement("div");
  buttonContent.className = addon.tab.scratchClass("button_content");
  const buttonImage = document.createElement("img");
  buttonImage.className = addon.tab.scratchClass("stage-header_stage-button-icon");
  buttonImage.draggable = false;
  buttonImage.src = _twGetAsset("/debug.svg");
  buttonContent.appendChild(buttonImage);
  buttonContainer.appendChild(buttonContent);
  container.appendChild(buttonContainer);
  buttonContainer.addEventListener("click", () => toggleConsole(true));

  const pause = () => {
    Object(_pause_module_js__WEBPACK_IMPORTED_MODULE_9__["setPaused"])(!_pause_module_js__WEBPACK_IMPORTED_MODULE_9__["paused"]);
    const pauseAddonButton = document.querySelector(".pause-btn");
    if (!pauseAddonButton || getComputedStyle(pauseAddonButton).display === "none") toggleConsole(true);
  };

  addon.tab.addBlock("\u200B\u200Bbreakpoint\u200B\u200B", [], pause);
  addon.tab.addBlock("\u200B\u200Blog\u200B\u200B %s", ["content"], ({
    content
  }, thread) => {
    addItem(content, thread, "log");
  });
  addon.tab.addBlock("\u200B\u200Bwarn\u200B\u200B %s", ["content"], ({
    content
  }, thread) => {
    addItem(content, thread, "warn");
  });
  addon.tab.addBlock("\u200B\u200Berror\u200B\u200B %s", ["content"], ({
    content
  }, thread) => {
    addItem(content, thread, "error");
  });
  const consoleWrapper = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_card", {
      others: "debug"
    })
  });
  const consoleTitle = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_header-buttons")
  });
  const consoleText = Object.assign(document.createElement("h1"), {
    innerText: msg("console")
  });
  const extraContainer = Object.assign(document.createElement("div"), {
    className: "extra-log-container"
  });

  const goToBlock = (targetId, blockId) => {
    const workspace = Blockly.getMainWorkspace();
    const offsetX = 32,
          offsetY = 32;

    if (targetId !== vm.editingTarget.id) {
      // note: this is O(n) so don't call it if unnecessary!
      if (vm.runtime.getTargetById(targetId)) {
        vm.setEditingTarget(targetId); // Should not cause recursion

        setTimeout(() => goToBlock(targetId, blockId), 300);
      }

      return;
    }

    const block = workspace.getBlockById(blockId);
    if (!block) return; // Don't scroll to blocks in the flyout

    if (block.workspace.isFlyout) return; // Make sure the code tab is active

    if (addon.tab.redux.state.scratchGui.editorTab.activeTabIndex !== 0) {
      addon.tab.redux.dispatch({
        type: "scratch-gui/navigation/ACTIVATE_TAB",
        activeTabIndex: 0
      });
    } // Copied from devtools. If it's code gets improved for this function, bring those changes here too.


    let root = block.getRootBlock();
    let base = block;

    while (base.getOutputShape() && base.getSurroundParent()) {
      base = base.getSurroundParent();
    }

    let ePos = base.getRelativeToSurfaceXY(),
        // Align with the top of the block
    rPos = root.getRelativeToSurfaceXY(),
        // Align with the left of the block 'stack'
    scale = workspace.scale,
        x = rPos.x * scale,
        y = ePos.y * scale,
        xx = block.width + x,
        // Turns out they have their x & y stored locally, and they are the actual size rather than scaled or including children...
    yy = block.height + y,
        s = workspace.getMetrics();

    if (x < s.viewLeft + offsetX - 4 || xx > s.viewLeft + s.viewWidth || y < s.viewTop + offsetY - 4 || yy > s.viewTop + s.viewHeight) {
      let sx = x - s.contentLeft - offsetX,
          sy = y - s.contentTop - offsetY;
      workspace.scrollbar.set(sx, sy);
    } // Flashing


    const myFlash = {
      block: null,
      timerID: null,
      colour: null
    };

    if (myFlash.timerID > 0) {
      clearTimeout(myFlash.timerID);
      myFlash.block.setColour(myFlash.colour);
    }

    let count = 4;
    let flashOn = true;
    myFlash.colour = block.getColour();
    myFlash.block = block;

    function _flash() {
      if (!myFlash.block.svgPath_) {
        myFlash.timerID = count = 0;
        flashOn = true;
        return;
      }

      myFlash.block.svgPath_.style.fill = flashOn ? "#ffff80" : myFlash.colour;
      flashOn = !flashOn;
      count--;

      if (count > 0) {
        myFlash.timerID = setTimeout(_flash, 200);
      } else {
        myFlash.timerID = 0;
      }
    }

    _flash();
  };

  extraContainer.addEventListener("click", e => {
    const elem = e.target;
    if (elem.classList.contains("deletedTarget")) return;
    const targetId = elem.dataset.targetId;
    const blockId = elem.dataset.blockId;
    if (targetId && blockId) goToBlock(targetId, blockId);
  });
  const consoleList = Object.assign(document.createElement("div"), {
    className: "logs"
  });
  const buttons = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_header-buttons-right")
  });
  const unpauseButton = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_shrink-expand-button", {
      others: "sa-debugger-unpause"
    }),
    draggable: false
  });
  const unpauseImg = Object.assign(document.createElement("img"), {
    src: _twGetAsset("/play.svg")
  });
  const unpauseText = Object.assign(document.createElement("span"), {
    innerText: msg("unpause")
  });
  const exportButton = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_shrink-expand-button"),
    title: msg("export-desc"),
    draggable: false
  });
  const exportImg = Object.assign(document.createElement("img"), {
    src: _twGetAsset("/download-white.svg")
  });
  const exportText = Object.assign(document.createElement("span"), {
    innerText: msg("export")
  });
  const trashButton = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_shrink-expand-button"),
    draggable: false
  });
  const trashImg = Object.assign(document.createElement("img"), {
    src: _twGetAsset("/delete.svg")
  });
  const trashText = Object.assign(document.createElement("span"), {
    innerText: msg("clear")
  });
  const closeButton = Object.assign(document.createElement("div"), {
    className: addon.tab.scratchClass("card_remove-button"),
    draggable: false
  });
  const closeImg = Object.assign(document.createElement("img"), {
    className: addon.tab.scratchClass("close-button_close-icon"),
    src: _twGetAsset("/add.svg")
  });
  const closeText = Object.assign(document.createElement("span"), {
    innerText: msg("close")
  });
  consoleTitle.append(consoleText, buttons);
  buttons.append(unpauseButton, exportButton, trashButton, closeButton);
  trashButton.append(trashImg, trashText);
  closeButton.append(closeImg, closeText);
  exportButton.append(exportImg, exportText);
  unpauseButton.append(unpauseImg, unpauseText);
  extraContainer.append(consoleList);
  consoleWrapper.append(consoleTitle, extraContainer);
  document.body.append(consoleWrapper);
  consoleTitle.addEventListener("mousedown", dragMouseDown);
  let isScrolledToEnd = true;
  extraContainer.addEventListener("wheel", e => {
    // When user scrolls up, stop automatically scrolling down
    if (e.deltaY < 0) {
      isScrolledToEnd = false;
    }
  }, {
    passive: true
  });
  extraContainer.addEventListener("scroll", () => {
    isScrolledToEnd = extraContainer.scrollTop + 5 >= extraContainer.scrollHeight - extraContainer.clientHeight;
  }, {
    passive: true
  });

  const getTargetInfo = (id, cache = null) => {
    if (cache && cache[id]) return cache[id];
    const target = vm.runtime.getTargetById(id);
    let item;

    if (target) {
      item = {
        name: target.getName(),
        isDeleted: false
      };
    } else {
      item = {
        name: msg("deleted-sprite"),
        isDeleted: true
      };
    }

    if (cache) cache[id] = item;
    return item;
  };

  let mouseOffsetX = 0;
  let mouseOffsetY = 0;
  let lastX = 0;
  let lastY = 0;

  function dragMouseDown(e) {
    e.preventDefault();
    mouseOffsetX = e.clientX - consoleWrapper.offsetLeft;
    mouseOffsetY = e.clientY - consoleWrapper.offsetTop;
    lastX = e.clientX;
    lastY = e.clientY;
    document.addEventListener("mouseup", closeDragElement);
    document.addEventListener("mousemove", elementDrag);
  }

  function dragConsole(x, y) {
    lastX = x;
    lastY = y;
    const width = document.documentElement.clientWidth || document.body.clientWidth;
    const height = document.documentElement.clientHeight || document.body.clientHeight;
    const clampedX = Math.max(0, Math.min(x - mouseOffsetX, width - consoleWrapper.offsetWidth));
    const clampedY = Math.max(0, Math.min(y - mouseOffsetY, height - consoleWrapper.offsetHeight));
    consoleWrapper.style.left = clampedX + "px";
    consoleWrapper.style.top = clampedY + "px";
  }

  function elementDrag(e) {
    e.preventDefault();
    dragConsole(e.clientX, e.clientY);
  }

  window.addEventListener("resize", () => {
    dragConsole(lastX, lastY);
  });

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.removeEventListener("mouseup", closeDragElement);
    document.removeEventListener("mousemove", elementDrag);
  }

  trashButton.addEventListener("click", () => {
    document.querySelectorAll(".log").forEach((log, i) => log.remove());
    closeDragElement();
    logs = [];
    isScrolledToEnd = true;
  });
  trashButton.addEventListener("mouseup", () => {
    closeDragElement();
  });
  closeButton.addEventListener("click", () => toggleConsole(false));
  closeButton.addEventListener("mouseup", () => closeDragElement());

  let download = (filename, text) => Object(_libraries_common_cs_download_blob_js__WEBPACK_IMPORTED_MODULE_8__["default"])(filename, new Blob([text], {
    type: "text/plain"
  }));

  unpauseButton.addEventListener("click", () => Object(_pause_module_js__WEBPACK_IMPORTED_MODULE_9__["setPaused"])(false));
  if (!_pause_module_js__WEBPACK_IMPORTED_MODULE_9__["paused"]) unpauseButton.style.display = "none";
  Object(_pause_module_js__WEBPACK_IMPORTED_MODULE_9__["onPauseChanged"])(newPauseValue => unpauseButton.style.display = newPauseValue ? "" : "none");
  exportButton.addEventListener("click", e => {
    const defaultFormat = "{sprite}: {content} ({type})";
    const exportFormat = e.shiftKey ? prompt(msg("enter-format"), defaultFormat) : defaultFormat;
    if (!exportFormat) return;
    closeDragElement();
    const targetInfoCache = Object.create(null);
    let file = logs.map(({
      targetId,
      type,
      content
    }) => exportFormat.replace(/\{(sprite|type|content)\}/g, (_, match) => ({
      sprite: getTargetInfo(targetId, targetInfoCache).name,
      type,
      content
    })[match])).join("\n");
    download("logs.txt", file);
  });
  let logs = [];
  let scrollQueued = false;

  const addItem = (content, thread, type) => {
    const wrapper = document.createElement("div");

    const span = (text, cl = "") => {
      let s = document.createElement("span");
      s.innerText = text;
      s.className = cl;
      return s;
    };

    const target = thread.target;
    const parentTarget = target.isOriginal ? target : target.sprite.clones[0];
    const targetId = parentTarget.id;
    wrapper.className = "log";
    wrapper.classList.add(type);
    consoleList.append(wrapper);

    if (type !== "log") {
      const imageURL = _twGetAsset(type === "error" ? "/error.svg" : "/warning.svg");

      const icon = document.createElement("img");
      icon.src = imageURL;
      icon.alt = icon.title = msg("icon-" + type);
      icon.className = "logIcon";
      wrapper.appendChild(icon);
    }

    const blockId = thread.peekStack();
    const block = target.blocks.getBlock(blockId);

    if (block && ScratchBlocks) {
      var _Object$values$;

      const inputId = (_Object$values$ = Object.values(block.inputs)[0]) === null || _Object$values$ === void 0 ? void 0 : _Object$values$.block;
      const inputBlock = target.blocks.getBlock(inputId);

      if (inputBlock && inputBlock.opcode !== "text") {
        let text, category;

        if (inputBlock.opcode === "data_variable" || inputBlock.opcode === "data_listcontents") {
          text = Object.values(inputBlock.fields)[0].value;
          category = inputBlock.opcode === "data_variable" ? "data" : "list";
        } else {
          // Try to call things like https://github.com/LLK/scratch-blocks/blob/develop/blocks_vertical/operators.js
          let jsonData;
          const fakeBlock = {
            jsonInit(data) {
              jsonData = data;
            }

          };
          const blockConstructor = ScratchBlocks.Blocks[inputBlock.opcode];

          if (blockConstructor) {
            try {
              blockConstructor.init.call(fakeBlock);
            } catch (e) {// ignore
            }
          }

          if (jsonData && jsonData.message0 && !jsonData.args0) {
            text = jsonData.message0;
            category = jsonData.category;
          }
        }

        if (text && category) {
          const inputSpan = document.createElement("span");
          inputSpan.textContent = text;
          inputSpan.className = "console-variable";
          inputSpan.dataset.category = category === "list" ? "data-lists" : category;
          inputSpan.style.backgroundColor = ScratchBlocks.Colours[category === "list" ? "data_lists" : category].primary;
          wrapper.append(inputSpan);
        }
      }
    }

    logs.push({
      targetId,
      type,
      content
    });
    wrapper.append(span(content));
    let link = document.createElement("a");
    link.textContent = target.isOriginal ? target.getName() : msg("clone-of", {
      spriteName: parentTarget.getName()
    });
    link.className = "logLink";
    link.dataset.blockId = blockId;
    link.dataset.targetId = targetId;

    if (!target.isOriginal) {
      link.dataset.isClone = "true";
    }

    wrapper.appendChild(link);

    if (!scrollQueued && isScrolledToEnd) {
      scrollQueued = true;
      queueMicrotask(scrollToEnd);
    }

    if (!showingConsole) {
      const unreadImage = _twGetAsset("/debug-unread.svg");

      if (buttonImage.src !== unreadImage) buttonImage.src = unreadImage;
    }
  };

  const scrollToEnd = () => {
    scrollQueued = false;
    extraContainer.scrollTop = extraContainer.scrollHeight;
  };

  const toggleConsole = (show = !showingConsole) => {
    showingConsole = show;
    consoleWrapper.style.display = show ? "flex" : "";

    if (show) {
      buttonImage.src = _twGetAsset("/debug.svg");
      const cacheObj = Object.create(null);

      for (const logLinkElem of document.getElementsByClassName("logLink")) {
        const targetId = logLinkElem.dataset.targetId;
        if (!targetId) return;
        const tInfo = getTargetInfo(targetId, cacheObj);
        logLinkElem.textContent = tInfo.name;

        if (tInfo.isDeleted) {
          logLinkElem.classList.add("deletedTarget");
        } else if (logLinkElem.dataset.isClone) {
          logLinkElem.textContent = msg("clone-of", {
            spriteName: tInfo.name
          });
        }
      }

      if (isScrolledToEnd) {
        scrollToEnd();
      }
    }
  };

  while (true) {
    const stageHeaderSizeControls = await addon.tab.waitForElement('[class*="stage-header_stage-size-row"]', {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "scratch-gui/mode/SET_FULL_SCREEN", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });

    if (addon.tab.editorMode === "editor") {
      ScratchBlocks = await addon.tab.traps.getBlockly();
      stageHeaderSizeControls.insertBefore(container, stageHeaderSizeControls.firstChild);
    } else {
      toggleConsole(false);
    }
  }
});

/***/ }),

/***/ "./src/addons/addons/debugger/warning.svg":
/*!************************************************!*\
  !*** ./src/addons/addons/debugger/warning.svg ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/0e009d6e684951615b31a267baa37636.svg";

/***/ }),

/***/ "./src/addons/addons/drag-drop/userscript.js":
/*!***************************************************!*\
  !*** ./src/addons/addons/drag-drop/userscript.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  const DRAG_OVER_CLASS = "sa-dragged-over";
  const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set;

  const reactAwareSetValue = (el, value) => {
    nativeInputValueSetter.call(el, value);
    el.dispatchEvent(new Event("change", {
      bubbles: true
    }));
  };

  const globalHandleDragOver = e => {
    if (!e.dataTransfer.types.includes("Files")) {
      return;
    }

    let el;
    let callback;

    if ((el = e.target.closest('div[class*="sprite-selector_sprite-selector"]')) || (el = e.target.closest('div[class*="stage-selector_stage-selector"]')) || (el = e.target.closest('div[class*="selector_wrapper"]'))) {
      callback = files => {
        const fileInput = el.querySelector('input[class*="action-menu_file-input"]');
        fileInput.files = files;
        fileInput.dispatchEvent(new Event("change", {
          bubbles: true
        }));
      };
    } else if (el = e.target.closest('div[class*="monitor_list-monitor"]')) {
      callback = files => {
        const contextMenuBefore = document.querySelector("body > .react-contextmenu.react-contextmenu--visible"); // Simulate a right click on the list monitor

        el.dispatchEvent(new MouseEvent("contextmenu", {
          bubbles: true
        })); // Get the right click menu that opened (monitor context menus are
        // children of <body>)

        const contextMenuAfter = document.querySelector("body > .react-contextmenu.react-contextmenu--visible"); // `contextMenuAfter` is only null if the context menu was already open
        // for the list monitor, in which case we can use the context menu from
        // before the simulated right click

        const contextMenu = contextMenuAfter === null ? contextMenuBefore : contextMenuAfter; // Sometimes the menu flashes open, so force hide it.

        contextMenu.style.display = "none"; // Override DOM methods to import the text file directly
        // See: https://github.com/LLK/scratch-gui/blob/develop/src/lib/import-csv.js#L21-L22

        const appendChild = document.body.appendChild;

        document.body.appendChild = fileInput => {
          // Restore appendChild to <body>
          document.body.appendChild = appendChild;

          if (fileInput instanceof HTMLInputElement) {
            document.body.appendChild(fileInput); // Prevent Scratch from opening the file input dialog

            fileInput.click = () => {}; // Insert files from the drop event into the file input


            fileInput.files = files;
            fileInput.dispatchEvent(new Event("change"));
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                contextMenu.style.display = null;
                contextMenu.style.opacity = 0;
                contextMenu.style.pointerEvents = "none";
              });
            });
          } else {
            // The next call for `appendChild` SHOULD be the file input, but if
            // it's not, then make `appendChild` behave as normal.
            console.error('File input was not immediately given to appendChild upon clicking "Import"!');
            return appendChild(fileInput);
          }
        }; // Simulate clicking on the "Import" option


        contextMenu.children[0].click();
      };
    } else if (el = e.target.closest('div[class*="question_question-input"] > input[class*="input_input-form_l9eYg"]')) {
      callback = async files => {
        const text = (await Promise.all(Array.from(files, file => file.text()))).join("") // Match pasting behaviour: remove all newline characters at the end
        .replace(/[\r\n]+$/, "").replace(/\r?\n|\r/g, " ");
        const selectionStart = el.selectionStart;
        reactAwareSetValue(el, el.value.slice(0, selectionStart) + text + el.value.slice(el.selectionEnd));
        el.setSelectionRange(selectionStart, selectionStart + text.length);
      };
    }

    if (!el) {
      return;
    }

    e.preventDefault();

    if (el.classList.contains(DRAG_OVER_CLASS)) {
      return;
    }

    el.classList.add(DRAG_OVER_CLASS);

    const handleDrop = e => {
      e.preventDefault();
      cleanup();

      if (e.dataTransfer.types.includes("Files") && e.dataTransfer.files.length > 0) {
        callback(e.dataTransfer.files);
      }
    };

    const handleDragOver = e => {
      e.preventDefault();
    };

    const handleDragLeave = e => {
      e.preventDefault();
      cleanup();
    };

    const cleanup = () => {
      el.classList.remove(DRAG_OVER_CLASS);
      el.removeEventListener("dragover", handleDragOver);
      el.removeEventListener("dragleave", handleDragLeave);
      el.removeEventListener("drop", handleDrop);
    };

    el.addEventListener("dragover", handleDragOver);
    el.addEventListener("dragleave", handleDragLeave);
    el.addEventListener("drop", handleDrop);
  };

  document.addEventListener("dragover", globalHandleDragOver, true);
});

/***/ }),

/***/ "./src/addons/addons/editor-colored-context-menus/userscript.js":
/*!**********************************************************************!*\
  !*** ./src/addons/addons/editor-colored-context-menus/userscript.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  document.body.addEventListener("mousedown", handleClick, true);
});

function handleClick(e) {
  if (e.button !== 2) {
    return;
  }

  const widgetDiv = document.querySelector(".blocklyWidgetDiv");

  if (!widgetDiv) {
    return;
  }

  let target = e.target;

  if (target.closest(".blocklyMainBackground") || target.closest(".blocklyBubbleCanvas")) {
    widgetDiv.classList.remove("u-contextmenu-colored");
    return;
  }

  let block = target.closest("[data-id]");

  if (!block) {
    // When right clicking on the boundaries of a block in the flyout,
    // the click event can happen on a background rectangle and not on the actual block for some reason.
    // In this case, the block group should immediately follow the rect.
    if (target.tagName === "rect") {
      target = target.nextSibling;
      block = target && target.closest("[data-id]");
    }

    if (!block) {
      return;
    }
  }

  let blocklyBlock = Blockly.getMainWorkspace().getBlockById(block.dataset.id); // Keep jumping to the parent block until we find a non-shadow block.

  while (blocklyBlock && blocklyBlock.isShadow()) {
    blocklyBlock = blocklyBlock.getParent();
  }

  if (!blocklyBlock) {
    return;
  }

  const background = blocklyBlock.svgPath_;

  if (!background) {
    return;
  }

  const fill = window.getComputedStyle(background).getPropertyValue("fill");

  if (!fill) {
    return;
  }

  const fillHex = fill.substr(1);
  const rgb = parseInt(fillHex, 16);
  const hsl = rgb2hsl(rgb);
  hsl[2] = Math.max(hsl[2] - 15, 0);
  const border = "hsl(" + hsl[0] + ", " + hsl[1] + "%, " + hsl[2] + "%)";
  widgetDiv.classList.add("u-contextmenu-colored");
  widgetDiv.style.setProperty("--u-contextmenu-bg", fill);
  widgetDiv.style.setProperty("--u-contextmenu-border", border);
}

function rgb2hsl(rgb) {
  const r = (rgb >> 16 & 0xff) / 0xff;
  const g = (rgb >> 8 & 0xff) / 0xff;
  const b = (rgb & 0xff) / 0xff;
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);

  if (min === max) {
    return [0, 0, r * 100];
  }

  const c = max - min;
  const l = (min + max) / 2;
  const s = c / (1 - Math.abs(2 * l - 1));
  var h;

  switch (max) {
    case r:
      h = ((g - b) / c + 6) % 6;
      break;

    case g:
      h = (b - r) / c + 2;
      break;

    case b:
      h = (r - g) / c + 4;
      break;
  }

  h *= 60;
  return [h, s * 100, l * 100];
}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/BlockInstance.js":
/*!************************************************************!*\
  !*** ./src/addons/addons/editor-devtools/BlockInstance.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockInstance; });
/**
 * Encapsulates a block (either in this sprite or another / Blockly, or native JSON block
 */
class BlockInstance {
  constructor(target, block) {
    this.targetId = target.id;
    this.id = block.id;
  }

}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/BlockItem.js":
/*!********************************************************!*\
  !*** ./src/addons/addons/editor-devtools/BlockItem.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockItem; });
class BlockItem {
  constructor(cls, procCode, labelID, y) {
    this.cls = cls;
    this.procCode = procCode;
    this.labelID = labelID;
    this.y = y;
    this.lower = procCode.toLowerCase();
    /**
     * An Array of block ids
     * @type {Array.<string>}
     */

    this.clones = null;
    this.eventName = null;
  }
  /**
   * True if the blockID matches a black represented by this BlockItem
   * @param id
   * @returns {boolean}
   */


  matchesID(id) {
    if (this.labelID === id) {
      return true;
    }

    if (this.clones) {
      for (const cloneID of this.clones) {
        if (cloneID === id) {
          return true;
        }
      }
    }

    return false;
  }

}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/DevTools.js":
/*!*******************************************************!*\
  !*** ./src/addons/addons/editor-devtools/DevTools.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DevTools; });
/* harmony import */ var _blockly_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockly/Utils.js */ "./src/addons/addons/editor-devtools/blockly/Utils.js");
/* harmony import */ var _DomHelpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomHelpers.js */ "./src/addons/addons/editor-devtools/DomHelpers.js");
/* harmony import */ var _BlockInstance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BlockInstance.js */ "./src/addons/addons/editor-devtools/BlockInstance.js");
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./XML.js */ "./src/addons/addons/editor-devtools/XML.js");
/* harmony import */ var _BlockItem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BlockItem.js */ "./src/addons/addons/editor-devtools/BlockItem.js");
/* harmony import */ var _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./blockly/UndoGroup.js */ "./src/addons/addons/editor-devtools/blockly/UndoGroup.js");
// import ShowBroadcast from "./show-broadcast.js";






class DevTools {
  constructor(addon, msg, m, helpHTML) {
    this.addon = addon;
    this.msg = msg;
    this.m = m;
    /**
     * @type {VirtualMachine}
     */

    this.vm = addon.tab.traps.vm;
    this.utils = new _blockly_Utils_js__WEBPACK_IMPORTED_MODULE_0__["default"](addon);
    this.domHelpers = new _DomHelpers_js__WEBPACK_IMPORTED_MODULE_1__["default"](addon);
    this.multi = new Multi(this.utils);
    this._helpHTML = helpHTML;
    this.find = null;
    this.findInp = null;
    this.ddOut = null;
    this.dd = null;
    this.codeTab = null;
    this.costTab = null;
    this.costTabBody = null;
    this.selVarID = null;
    this.floatInp = null;
    this.blockCursor = null;
    this.canShare = false;
    this.mouseXY = {
      x: 0,
      y: 0
    };
  }

  init() {
    setTimeout(() => this.initInner(), 500);
  }

  isScriptEditor() {
    return this.codeTab.className.indexOf("gui_is-selected") >= 0;
  }

  isCostumeEditor() {
    return this.costTab.className.indexOf("gui_is-selected") >= 0;
  }

  eventClickHelp(e) {
    if (!document.getElementById("s3devHelpPop")) {
      document.body.insertAdjacentHTML("beforeend", this._helpHTML);
      document.getElementById("s3devHelpPop").addEventListener("mousedown", function (e) {
        if (e.target.id === "s3devHelpPop") {
          e.target.remove();
        }
      });
      document.querySelector("#s3devHelpPop .close-button").addEventListener("click", function (e) {
        document.getElementById("s3devHelpPop").remove();
      });
    }

    e.preventDefault();
  }

  getScratchCostumes() {
    let costumes = this.costTabBody.querySelectorAll("div[class^='sprite-selector-item_sprite-name']"); // this.costTab[0].click();

    let myBlocks = [];
    let myBlocksByProcCode = {};
    /**
     * @param cls
     * @param txt
     * @param root
     * @returns BlockItem
     */

    function addBlock(cls, txt, root) {
      let id = root.className;
      let items = new _BlockItem_js__WEBPACK_IMPORTED_MODULE_4__["default"](cls, txt, id, 0);
      myBlocks.push(items);
      myBlocksByProcCode[txt] = items;
      return items;
    }

    let i = 0;

    for (const costume of costumes) {
      addBlock("costume", costume.innerText, costume).y = i;
      i++;
    }

    return {
      procs: myBlocks
    };
  }
  /**
   * Fetch the scratch 3 block list
   * @returns jsonFetch object
   */


  getScratchBlocks() {
    // Access Blockly!
    let myBlocks = [];
    let myBlocksByProcCode = {}; // todo - get blockyly from an svg???

    let wksp = this.utils.getWorkspace();
    let topBlocks = wksp.getTopBlocks(); // console.log(topBlocks);

    /**
     * @param cls
     * @param txt
     * @param root
     * @returns BlockItem
     */

    function addBlock(cls, txt, root) {
      let id = root.id ? root.id : root.getId ? root.getId() : null;
      let clone = myBlocksByProcCode[txt];

      if (clone) {
        if (!clone.clones) {
          clone.clones = [];
        }

        clone.clones.push(id);
        return clone;
      }

      let items = new _BlockItem_js__WEBPACK_IMPORTED_MODULE_4__["default"](cls, txt, id, 0);
      items.y = root.getRelativeToSurfaceXY ? root.getRelativeToSurfaceXY().y : null;
      myBlocks.push(items);
      myBlocksByProcCode[txt] = items;
      return items;
    }

    function getDescFromField(root) {
      let fields = root.inputList[0];
      let desc;

      for (const fieldRow of fields.fieldRow) {
        desc = (desc ? desc + " " : "") + fieldRow.getText();
      }

      return desc;
    }

    for (const root of topBlocks) {
      if (root.type === "procedures_definition") {
        let fields = root.inputList[0];
        let typeDesc = fields.fieldRow[0].getText();
        let label = root.getChildren()[0];
        let procCode = label.getProcCode();

        if (!procCode) {
          continue;
        }

        addBlock("define", typeDesc + " " + procCode, root);
        continue;
      }

      if (root.type === "event_whenflagclicked") {
        addBlock("flag", getDescFromField(root), root); // "When Flag Clicked"

        continue;
      }

      if (root.type === "event_whenbroadcastreceived") {
        try {
          // let wksp2 = Blockly.getMainWorkspace().getTopBlocks()[2].inputList[0].fieldRow[1];
          let fields = root.inputList[0]; // let typeDesc = fields.fieldRow[0].getText();

          let eventName = fields.fieldRow[1].getText(); // addBlock('receive', typeDesc + ' ' + eventName, root).eventName = eventName;

          addBlock("receive", "event " + eventName, root).eventName = eventName;
        } catch (e) {// eat
        }

        continue;
      }

      if (root.type.substr(0, 10) === "event_when") {
        addBlock("event", getDescFromField(root), root); // "When Flag Clicked"

        continue;
      }

      if (root.type === "control_start_as_clone") {
        addBlock("event", getDescFromField(root), root); // "when I start as a clone"

        continue;
      }
    }

    let map = wksp.getVariableMap();
    let vars = map.getVariablesOfType("");

    for (const row of vars) {
      addBlock(row.isLocal ? "var" : "VAR", (row.isLocal ? "var " : "VAR ") + row.name, row);
    }

    let lists = map.getVariablesOfType("list");

    for (const row of lists) {
      addBlock(row.isLocal ? "list" : "LIST", (row.isLocal ? "list " : "LIST ") + row.name, row);
    }

    const events = this.getCallsToEvents();

    for (const event of events) {
      addBlock("receive", "event " + event.eventName, event.block).eventName = event.eventName;
    }
    /*
                  const runtime = vm.runtime;
                  // Now let's also add event broadcasts (not just hat blocks)
                  const target = runtime.getEditingTarget();
                  const blocks = target.blocks;
                  if (blocks._blocks) {
                      for (const id in blocks._blocks) {
                          if (!blocks._blocks.hasOwnProperty(id)) {
                              continue;
                          }
                          const block = blocks._blocks[id];
                          if (block.opcode === 'event_broadcast_menu') {
                               debugger;
                               // Now get the parent block that is the actual broadcast or broadcast and wait
                              const broadcastBlock = blocks.getBlock(block.parent);
                              let b = new BlockInstance(target, broadcastBlock);
                               const fieldName = block.fields.BROADCAST_OPTION.value;
                              addBlock('receive', 'event ' + fieldName, b).eventName = broadcastBlock.eventName;
                               //
                              // let fields = root.inputList[0];
                              // let typeDesc = fields.fieldRow[0].getText();
                              // let eventName = fields.fieldRow[1].getText();
                              // addBlock('receive', 'event ' + eventName, root).eventName = eventName;
                          }
                      }
                  }
          */


    const clsOrder = {
      flag: 0,
      receive: 1,
      event: 2,
      define: 3,
      var: 4,
      VAR: 5,
      list: 6,
      LIST: 7
    };
    myBlocks.sort((a, b) => {
      let t = clsOrder[a.cls] - clsOrder[b.cls];

      if (t !== 0) {
        return t;
      }

      if (a.lower < b.lower) {
        return -1;
      }

      if (a.lower > b.lower) {
        return 1;
      }

      return a.y - b.y;
    });
    return {
      procs: myBlocks
    };
  }

  showDropDown(e, focusID, instanceBlock) {
    clearTimeout(rhdd);
    rhdd = 0;

    if (!focusID && this.ddOut.classList.contains("vis")) {
      return;
    } // special '' vs null... - null forces a reevaluation


    prevVal = focusID ? "" : null; // Clear the previous value of the input search

    this.ddOut.classList.add("vis");
    let scratchBlocks = this.isCostumeEditor() ? this.getScratchCostumes() : this.getScratchBlocks();
    this.dom_removeChildren(this.dd);
    let foundLi = null;
    /**
     * @type {[BlockItem]}
     */

    const procs = scratchBlocks.procs;

    for (const proc of procs) {
      let li = document.createElement("li");
      li.innerText = proc.procCode;
      li.data = proc;
      li.className = proc.cls;

      if (focusID) {
        if (proc.matchesID(focusID)) {
          foundLi = li;
          li.classList.add("sel");
        } else {
          li.style.display = "none";
        }
      }

      this.dd.appendChild(li);
    }

    let label = document.getElementById("s3devFindLabel");
    this.utils.offsetX = this.ddOut.getBoundingClientRect().right - label.getBoundingClientRect().left + 26;
    this.utils.offsetY = 32;

    if (foundLi) {
      this.clickDropDownRow(foundLi, this.utils.getWorkspace(), instanceBlock);
    }
  }

  hideDropDown() {
    clearTimeout(rhdd);
    rhdd = setTimeout(() => this.reallyHideDropDown(), 250);
  }

  reallyHideDropDown() {
    // Check focus of find box
    if (this.findInp === document.activeElement) {
      this.hideDropDown();
      return;
    } // document.getElementById('s3devReplace').classList.add('s3devHide');


    this.ddOut.classList.remove("vis");
    rhdd = 0;
  }

  hideFloatDropDown() {
    clearTimeout(rhdd2);
    rhdd2 = setTimeout(() => this.reallyHideFloatDropDown(), 50);
  }

  reallyHideFloatDropDown(force) {
    // Check focus of find box
    if (!force && this.floatInp === document.activeElement) {
      this.hideFloatDropDown();
      return;
    }

    let float = document.getElementById("s3devFloatingBar");

    if (float) {
      float.remove();
    }

    this.floatInp = null;
    rhdd2 = 0;
  }

  dom_removeChildren(myNode) {
    while (myNode.firstChild) {
      myNode.removeChild(myNode.firstChild);
    }
  }
  /**
   * A nicely ordered version of the top blocks
   * @returns {[Blockly.Block]}
   */


  getTopBlocks() {
    let result = this.getOrderedTopBlockColumns();
    let columns = result.cols;
    /**
     * @type {[[Blockly.Block]]}
     */

    let topBlocks = [];

    for (const col of columns) {
      topBlocks = topBlocks.concat(col.blocks);
    }

    return topBlocks;
  }

  hidePopups(wksp) {
    // Fire fake mouse events to trick the popup into hiding.
    const element = wksp.getToolbox().HtmlDiv;
    element.dispatchEvent(new MouseEvent("mousedown", {
      relatedTarget: element,
      bubbles: true
    }));
    element.dispatchEvent(new MouseEvent("mouseup", {
      relatedTarget: element,
      bubbles: true
    }));
  }
  /**
   * A much nicer way of laying out the blocks into columns
   */


  doCleanUp(e, dataId) {
    let workspace = this.utils.getWorkspace();

    if (e) {
      e.cancelBubble = true;
      e.preventDefault();
      this.hidePopups(workspace);
      setTimeout(() => this.doCleanUp(undefined, dataId), 0);
      return;
    }

    let makeSpaceForBlock = dataId && workspace.getBlockById(dataId);
    makeSpaceForBlock = makeSpaceForBlock && makeSpaceForBlock.getRootBlock();
    _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].startUndoGroup(workspace);
    let result = this.getOrderedTopBlockColumns(true);
    let columns = result.cols;
    let orphanCount = result.orphans.blocks.length;

    if (orphanCount > 0 && !dataId) {
      let message = this.msg("orphaned", {
        count: orphanCount
      });

      if (confirm(message)) {
        for (const block of result.orphans.blocks) {
          block.dispose();
        }
      } else {
        columns.unshift(result.orphans);
      }
    }

    let cursorX = 48;
    let maxWidths = result.maxWidths;

    for (const column of columns) {
      let cursorY = 64;
      let maxWidth = 0;

      for (const block of column.blocks) {
        let extraWidth = block === makeSpaceForBlock ? 380 : 0;
        let extraHeight = block === makeSpaceForBlock ? 480 : 72;
        let xy = block.getRelativeToSurfaceXY();

        if (cursorX - xy.x !== 0 || cursorY - xy.y !== 0) {
          block.moveBy(cursorX - xy.x, cursorY - xy.y);
        }

        let heightWidth = block.getHeightWidth();
        cursorY += heightWidth.height + extraHeight;
        let maxWidthWithComments = maxWidths[block.id] || 0;
        maxWidth = Math.max(maxWidth, Math.max(heightWidth.width + extraWidth, maxWidthWithComments));
      }

      cursorX += maxWidth + 96;
    }

    let topComments = workspace.getTopComments();

    for (const comment of topComments) {
      if (comment.setVisible) {
        comment.setVisible(false);
        comment.needsAutoPositioning_ = true;
        comment.setVisible(true);
      }
    }

    setTimeout(() => {
      // Locate unused local variables...
      let workspace = this.utils.getWorkspace();
      let map = workspace.getVariableMap();
      let vars = map.getVariablesOfType("");
      let unusedLocals = [];

      for (const row of vars) {
        if (row.isLocal) {
          let usages = map.getVariableUsesById(row.getId());

          if (!usages || usages.length === 0) {
            unusedLocals.push(row);
          }
        }
      }

      if (unusedLocals.length > 0 && !dataId) {
        const unusedCount = unusedLocals.length;
        let message = this.msg("unused-var", {
          count: unusedCount
        });

        for (let i = 0; i < unusedLocals.length; i++) {
          let orphan = unusedLocals[i];

          if (i > 0) {
            message += ", ";
          }

          message += orphan.name;
        }

        if (confirm(message)) {
          for (const orphan of unusedLocals) {
            workspace.deleteVariableById(orphan.getId());
          }
        }
      }

      _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].endUndoGroup(workspace);
    }, 100);
  }
  /**
   * Badly Ophaned - might want to delete these!
   * @param topBlock
   * @returns {boolean}
   */


  isBlockAnOrphan(topBlock) {
    return !!topBlock.outputConnection;
  }
  /**
   * Split the top blocks into ordered columns
   * @param separateOrphans true to keep all orphans separate
   * @returns {{orphans: {blocks: [Block], x: number, count: number}, cols: [Col]}}
   */


  getOrderedTopBlockColumns(separateOrphans) {
    let w = this.utils.getWorkspace();
    let topBlocks = w.getTopBlocks();
    let maxWidths = {};

    if (separateOrphans) {
      let topComments = w.getTopComments(); // todo: tie comments to blocks... find widths and width of block stack row...

      for (const comment of topComments) {
        // comment.autoPosition_();
        // Hiding and showing repositions the comment right next to it's block - nice!
        if (comment.setVisible) {
          comment.setVisible(false);
          comment.needsAutoPositioning_ = true;
          comment.setVisible(true); // let bb = comment.block_.svgPath_.getBBox();

          let right = comment.getBoundingRectangle().bottomRight.x; // Get top block for stack...

          let root = comment.block_.getRootBlock();
          let left = root.getBoundingRectangle().topLeft.x;
          maxWidths[root.id] = Math.max(right - left, maxWidths[root.id] || 0);
        }
      }
    } // Default scratch ordering is horrid... Lets try something more clever.

    /**
     * @type {Col[]}
     */


    let cols = [];
    const TOLERANCE = 256;
    let orphans = {
      x: -999999,
      count: 0,
      blocks: []
    };

    for (const topBlock of topBlocks) {
      // let r = b.getBoundingRectangle();
      let position = topBlock.getRelativeToSurfaceXY();
      /**
       * @type {Col}
       */

      let bestCol = null;
      let bestError = TOLERANCE;

      if (separateOrphans && this.isBlockAnOrphan(topBlock)) {
        orphans.blocks.push(topBlock);
        continue;
      } // Find best columns


      for (const col of cols) {
        let err = Math.abs(position.x - col.x);

        if (err < bestError) {
          bestError = err;
          bestCol = col;
        }
      }

      if (bestCol) {
        // We found a column that we fitted into
        bestCol.x = (bestCol.x * bestCol.count + position.x) / ++bestCol.count; // re-average the columns as more items get added...

        bestCol.blocks.push(topBlock);
      } else {
        // Create a new column
        cols.push(new Col(position.x, 1, [topBlock]));
      }
    } // if (orphans.blocks.length > 0) {
    //     cols.push(orphans);
    // }
    // Sort columns, then blocks inside the columns


    cols.sort((a, b) => a.x - b.x);

    for (const col of cols) {
      col.blocks.sort((a, b) => a.getRelativeToSurfaceXY().y - b.getRelativeToSurfaceXY().y);
    }

    return {
      cols: cols,
      orphans: orphans,
      maxWidths: maxWidths
    };
  }
  /**
   * Find all the uses of a named variable.
   * @param {string} id ID of the variable to find.
   * @return {!Array.<!Blockly.Block>} Array of block usages.
   */


  getVariableUsesById(id) {
    let uses = [];
    let topBlocks = this.getTopBlocks(true); // todo: Confirm this was the right getTopBlocks?

    for (const topBlock of topBlocks) {
      /** @type {!Array<!Blockly.Block>} */
      let kids = topBlock.getDescendants();

      for (const block of kids) {
        /** @type {!Array<!Blockly.VariableModel>} */
        let blockVariables = block.getVarModels();

        if (blockVariables) {
          for (const blockVar of blockVariables) {
            if (blockVar.getId() === id) {
              uses.push(block);
            }
          }
        }
      }
    }

    return uses;
  }
  /**
   * Find all the uses of a named procedure.
   * @param {string} id ID of the variable to find.
   * @return {!Array.<!Blockly.Block>} Array of block usages.
   */


  getCallsToProcedureById(id) {
    let w = this.utils.getWorkspace();
    let procBlock = w.getBlockById(id);
    let label = procBlock.getChildren()[0];
    let procCode = label.getProcCode();
    let uses = [procBlock]; // Definition First, then calls to it

    let topBlocks = this.getTopBlocks(true);

    for (const topBlock of topBlocks) {
      /** @type {!Array<!Blockly.Block>} */
      let kids = topBlock.getDescendants();

      for (const block of kids) {
        if (block.type === "procedures_call") {
          if (block.getProcCode() === procCode) {
            uses.push(block);
          }
        }
      }
    }

    return uses;
  }
  /**
   * Find all the uses of a named procedure.
   * @param {string} name name of the variable to find.
   * @return {!Array.<!Blockly.Block>} Array of block usages.
   */


  getCallsToEventsByName(name) {
    let uses = []; // Definition First, then calls to it

    const runtime = this.vm.runtime;
    const targets = runtime.targets; // The sprites / stage

    for (const target of targets) {
      if (!target.isOriginal) {
        continue; // Skip clones
      }

      const blocks = target.blocks;

      if (!blocks._blocks) {
        continue;
      }

      for (const id of Object.keys(blocks._blocks)) {
        const block = blocks._blocks[id]; // To find event broadcaster blocks, we look for the nested "event_broadcast_menu" blocks first that match the event name

        if (block.opcode === "event_broadcast_menu" && block.fields.BROADCAST_OPTION.value === name) {
          // Now get the parent block that is the actual broadcast or broadcast and wait
          const broadcastBlock = blocks.getBlock(block.parent);
          uses.push(new _BlockInstance_js__WEBPACK_IMPORTED_MODULE_2__["default"](target, broadcastBlock));
        } else if (block.opcode === "event_whenbroadcastreceived" && block.fields.BROADCAST_OPTION.value === name) {
          uses.push(new _BlockInstance_js__WEBPACK_IMPORTED_MODULE_2__["default"](target, block));
        }
      }
    }

    return uses;
  }
  /**
   * Find all the evern broadcasters.
   * @return {[{eventName:string, block:Block}]} Array of event names and blocks.
   */


  getCallsToEvents() {
    const uses = []; // Definition First, then calls to it

    const found = {};
    let topBlocks = this.getTopBlocks(true);

    for (const topBlock of topBlocks) {
      /** @type {!Array<!Blockly.Block>} */
      let kids = topBlock.getDescendants();

      for (const block of kids) {
        if (block.type === "event_broadcast" || block.type === "event_broadcastandwait") {
          const eventName = block.getChildren()[0].inputList[0].fieldRow[0].getText();

          if (!found[eventName]) {
            found[eventName] = block;
            uses.push({
              eventName: eventName,
              block: block
            });
          }
        }
      }
    }

    return uses;
  }

  buildNavigationCarousel(nav, li, blocks, instanceBlock) {
    if (nav && nav.parentNode === li) {
      // Same control... click again to go to next
      this.multi.navRight();
    } else {
      if (nav) {
        nav.remove();
      }

      li.insertAdjacentHTML("beforeend", "\n                    <span id=\"s3devMulti\" class=\"s3devMulti\">\n                        <span id=\"s3devMultiLeft\" class=\"s3devNav\">\u25C0</span><span id=\"s3devMultiCount\"></span><span id=\"s3devMultiRight\" class=\"s3devNav\">\u25B6</span>\n                    </span>\n                ");
      document.getElementById("s3devMultiLeft").addEventListener("mousedown", (...e) => this.multi.navLeft(...e));
      document.getElementById("s3devMultiRight").addEventListener("mousedown", (...e) => this.multi.navRight(...e));
      this.multi.idx = 0;

      if (instanceBlock) {
        for (let i = 0; i < blocks.length; i++) {
          const block = blocks[i];

          if (block.id === instanceBlock.id) {
            this.multi.idx = i;
            break;
          }
        } // multi.idx = blocks.indexOf(instanceBlock);

      }

      this.multi.blocks = blocks;
      this.multi.update();

      if (this.multi.idx < blocks.length) {
        this.centerTop(blocks[this.multi.idx]);
      }
    }
  }
  /**
   * Move a costume to the top or bottom of the list
   * @param top true for the top, false for the bottom
   * @param selected optional parameter to pass in the costume div to be moved
   */


  moveCostumeTo(top, selected) {
    let isSelected = !selected || selected.className.indexOf("sprite-selector-item_is-selected") >= 0;

    if (!selected) {
      selected = this.costTabBody.querySelectorAll("div[class*='sprite-selector-item_is-selected']");

      if (selected.length === 0) {
        return;
      }

      selected = selected[0].querySelectorAll("div[class^='sprite-selector-item_sprite-name']")[0];
    }

    let costumes = this.costTabBody.querySelectorAll("div[class^='sprite-selector-item_sprite-name']"); // First scroll sprite view to reveal top or bottom otherwise this won't work.

    let scroller = selected.closest("div[class*=selector_list-area]");
    let lastScroll = scroller.scrollTop;
    scroller.scrollTop = top ? 0 : scroller.scrollHeight;
    this.domHelpers.triggerDragAndDrop(selected, costumes[top ? 0 : costumes.length - 1], undefined);

    if (!isSelected) {
      // Restore Scroll position
      scroller.scrollTop = lastScroll;
    }
  }
  /**
   *
   * @param li
   * @param workspace
   * @param instanceBlock the instance to be highlighted (or null)
   */


  clickDropDownRow(li, workspace, instanceBlock) {
    let nav = document.getElementById("s3devMulti");
    let cls = li.data.cls;

    if (cls === "costume") {
      // Viewing costumes - jump to selected costume
      let costumes = this.costTabBody.querySelectorAll("div[class^='sprite-selector-item_sprite-name']");
      let costume = costumes[li.data.y];

      if (costume) {
        costume.click();
        setTimeout(() => {
          let wrapper = costume.closest("div[class*=gui_flex-wrapper]");
          costume.parentElement.parentElement.scrollIntoView({
            behavior: "auto",
            block: "center",
            inline: "start"
          });
          wrapper.scrollTop = 0;
        }, 10);
      }
    } else if (cls === "var" || cls === "VAR" || cls === "list" || cls === "LIST") {
      // Search now for all instances
      // let wksp = getWorkspace();
      // let blocks = wksp.getVariableUsesById(li.data.labelID);
      let blocks = this.getVariableUsesById(li.data.labelID);
      this.buildNavigationCarousel(nav, li, blocks, instanceBlock);
    } else if (cls === "define") {
      let blocks = this.getCallsToProcedureById(li.data.labelID);
      this.buildNavigationCarousel(nav, li, blocks, instanceBlock);
    } else if (cls === "receive") {
      /*
                          let blocks = [workspace.getBlockById(li.data.labelID)];
                          if (li.data.clones) {
                              for (const cloneID of li.data.clones) {
                                  blocks.push(workspace.getBlockById(cloneID))
                              }
                          }
                          blocks = blocks.concat(getCallsToEventsByName(li.data.eventName));
              */
      // Now, fetch the events from the scratch runtime instead of blockly
      let blocks = this.getCallsToEventsByName(li.data.eventName);

      if (!instanceBlock) {
        // Can we start by selecting the first block on 'this' sprite
        const currentTargetID = this.utils.getEditingTarget().id;

        for (const block of blocks) {
          if (block.targetId === currentTargetID) {
            instanceBlock = block;
            break;
          }
        }
      }

      this.buildNavigationCarousel(nav, li, blocks, instanceBlock);
    } else if (li.data.clones) {
      let blocks = [workspace.getBlockById(li.data.labelID)];

      for (const cloneID of li.data.clones) {
        blocks.push(workspace.getBlockById(cloneID));
      }

      this.buildNavigationCarousel(nav, li, blocks, instanceBlock);
    } else {
      this.multi.blocks = null;
      this.centerTop(li.data.labelID);

      if (nav) {
        nav.remove();
      }
    }
  }

  dropDownClick(e) {
    // console.log(e);
    let workspace = this.utils.getWorkspace();

    if (prevVal === null) {
      prevVal = this.findInp.value; // Hack to stop filter change if not entered data into edt box, but clicked on row
    }

    let li = e.target;

    for (;;) {
      if (!li || li === this.dd) {
        return;
      }

      if (li.data) {
        break;
      }

      li = li.parentNode;
    } // If this was a mouse click, unselect the keyboard selection
    // e.navKey is set when this is called from the keyboard handler...


    if (!e.navKey) {
      let sel = this.dd.getElementsByClassName("sel");
      sel = sel.length > 0 ? sel[0] : null;

      if (sel && sel !== li) {
        try {
          sel.classList.remove("sel");
        } catch (e) {
          console.log(sel);
          console.error(e);
        }
      }

      if (li !== sel) {
        li.classList.add("sel");
      }
    }

    this.clickDropDownRow(li, workspace);

    if (e && e.preventDefault) {
      e.preventDefault();
      e.cancelBubble = true;
    }

    return false;
  }
  /**
   * Based on wksp.centerOnBlock(li.data.labelID);
   * @param e
   * @param force if true, the view always moves, otherwise only move if the selected element is not entirely visible
   */


  centerTop(e, force) {
    this.utils.scrollBlockIntoView(e, force);
  }

  inputChange(e) {
    if (!this.ddOut.classList.contains("vis")) {
      this.showDropDown();
      this.hideDropDown(); // Start timer to hide if not got focus
    } // Filter the list...


    let val = (this.findInp.value || "").toLowerCase();

    if (val === prevVal) {
      // No change so don't re-filter
      return;
    }

    prevVal = val;
    this.multi.blocks = null; //
    // Hide items in list that do not contain filter text, and highlight the parts of words that match the filter text

    let listLI = this.dd.getElementsByTagName("li");

    for (const li of listLI) {
      let procCode = li.data.procCode;
      let i = li.data.lower.indexOf(val);

      if (i >= 0) {
        li.style.display = "block";
        this.dom_removeChildren(li);

        if (i > 0) {
          li.appendChild(document.createTextNode(procCode.substring(0, i)));
        }

        let bText = document.createElement("b");
        bText.appendChild(document.createTextNode(procCode.substr(i, val.length)));
        li.appendChild(bText);

        if (i + val.length < procCode.length) {
          li.appendChild(document.createTextNode(procCode.substr(i + val.length)));
        } // li.innerHTML = enc(procCode.substring(0, i)) + '<b>' + enc(procCode.substr(i, val.length)) + "</b>" + enc(procCode.substr(i + val.length));

      } else {
        li.style.display = "none";
      }
    }
  }
  /**
   * Select previous or next item in the drop down filter list
   * @param dir direction of navigation: -1=up, 1=down
   */


  navigateFilter(dir) {
    let sel = this.dd.getElementsByClassName("sel");
    let nxt;

    if (sel.length > 0 && sel[0].style.display !== "none") {
      nxt = dir === -1 ? sel[0].previousSibling : sel[sel.length - 1].nextSibling;
    } else {
      nxt = this.dd.children[0];
      dir = 1;
    }

    while (nxt && nxt.style.display === "none") {
      nxt = dir === -1 ? nxt.previousSibling : nxt.nextSibling;
    }

    if (nxt) {
      for (const i of sel) {
        i.classList.remove("sel");
      }

      nxt.classList.add("sel");
      this.dropDownClick({
        target: nxt,
        navKey: true
      }); // centerTop(nxt.data.labelID);
    }
  }

  inputKeyDown(e) {
    // Up Arrow
    if (e.keyCode === 38) {
      this.navigateFilter(-1);
      e.preventDefault();
      return;
    } // Down Arrow


    if (e.keyCode === 40) {
      this.navigateFilter(1);
      e.preventDefault();
      return;
    } // Left Arrow


    if (e.keyCode === 37) {
      let sel = this.dd.getElementsByClassName("sel");

      if (sel && this.multi.blocks) {
        this.multi.navLeft(e);
      }
    } // Right Arrow


    if (e.keyCode === 39) {
      let sel = this.dd.getElementsByClassName("sel");

      if (sel && this.multi.blocks) {
        this.multi.navRight(e);
      }
    } // Enter


    if (e.keyCode === 13) {
      // Any selected on enter? if not select now
      let sel = this.dd.getElementsByClassName("sel");

      if (sel.length === 0) {
        this.navigateFilter(1);
      } // noinspection JSUnresolvedFunction


      document.activeElement.blur();
      e.preventDefault();
      return;
    } // Escape


    if (e.keyCode === 27) {
      if (this.findInp.value.length > 0) {
        this.findInp.value = ""; // Clear search first, then close on second press

        this.inputChange(e);
      } else {
        // noinspection JSUnresolvedFunction
        document.activeElement.blur();
      }

      e.preventDefault();
      return;
    }
  }
  /*
    function deepSearch(e) {
      document.body.insertAdjacentHTML(
        "beforeend",
        `
              <div id="s3devOverlay">
              </div>
          `
      );
       let overlay = document.getElementById("s3devOverlay");
      overlay.addEventListener("click", function (e) {
        overlay.remove();
      });
       // todo: use scratch runtime instead!
       const runtime = vm.runtime;
      const targets = runtime.targets; // The sprites / stage
       let dict = {};
       for (const target of targets) {
        if (!target.isOriginal) {
          continue; // Skip clones
        }
         const name = target.getName();
        const isStage = target.isStage;
        const blocks = target.blocks;
        const scripts = blocks.getScripts();
         let divElement = document.createElement("div");
        divElement.appendChild(document.createTextNode("Searching in " + name));
        divElement.appendChild(document.createTextNode(", Top Scripts x" + scripts.length));
        overlay.appendChild(divElement);
         const sprite = (dict[name] = {});
        sprite.scripts = [];
         for (const script of scripts) {
          const block = blocks.getBlock(script);
          const top = { id: script, opcode: block.opcode, block: block };
          sprite.scripts.push(top);
        }
      }
       e.preventDefault();
      return true;
    }
  */

  /**
   * Quick and dirty replace all instances of one variable / list with another variable / list
   * @param varId original variable name
   * @param newVarName new variable name
   * @param type type of variable ("" = variable, anything else is a list?
   */


  doReplaceVariable(varId, newVarName, type) {
    let wksp = this.utils.getWorkspace();
    let v = wksp.getVariable(newVarName, type);

    if (!v) {
      alert(this.msg("var-not-exist"));
      return;
    }

    let newVId = v.getId();
    _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].startUndoGroup(wksp);
    let blocks = this.getVariableUsesById(varId);

    for (const block of blocks) {
      try {
        if (type === "") {
          block.getField("VARIABLE").setValue(newVId);
        } else {
          block.getField("LIST").setValue(newVId);
        }
      } catch (e) {// ignore
      }
    }

    _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].endUndoGroup(wksp);
  }
  /*
    function doInjectScripts(codeString) {
      let w = getWorkspace();
      let xml = new XML(); // document.implementation.createDocument(null, "xml");
      let x = xml.xmlDoc.firstChild;
       let tree = math.parse(codeString);
      console.log(tree);
       const binaryOperatorTypes = {
        add: "operator_add",
        subtract: "operator_subtract",
        this.multiply: "operator_multiply",
        divide: "operator_divide",
      };
       const BLOCK_TYPE = {
        number: "math_number",
        text: "text",
      };
       function translateMathToXml(x, tree, shadowType) {
        let xShadowField = null;
        if (shadowType) {
          let xShadow = xml.newXml(x, "shadow", { type: shadowType });
          if (shadowType === BLOCK_TYPE.number) {
            xShadowField = xml.newXml(xShadow, "field", { name: "NUM" });
          } else if (shadowType === BLOCK_TYPE.text) {
            xShadowField = xml.newXml(xShadow, "field", { name: "TEXT" });
          }
        }
         if (!tree || !tree.type) {
          return;
        }
         if (tree.type === "OperatorNode") {
          let operatorType = binaryOperatorTypes[tree.fn];
          if (operatorType) {
            let xOp = newXml(x, "block", { type: operatorType });
            translateMathToXml(xml.newXml(xOp, "value", { name: "NUM1" }), tree.args[0], BLOCK_TYPE.number);
            translateMathToXml(xml.newXml(xOp, "value", { name: "NUM2" }), tree.args[1], BLOCK_TYPE.number);
            return;
          }
           return;
        }
         if (tree.type === "ConstantNode") {
          // number or text in quotes
          if (xShadowField) {
            xml.setAttr(xShadowField, { text: tree.value });
          }
          return;
        }
         if (tree.type === "SymbolNode") {
          // variable
          let xVar = xml.newXml(x, "block", { type: "data_variable" });
          xml.newXml(xVar, "field", { name: "VARIABLE", text: tree.name });
          return;
        }
         if (tree.type === "FunctionNode") {
          // Method Call
          if (tree.fn.name === "join") {
            let xOp = newXml(x, "block", { type: "operator_join" });
            translateMathToXml(xml.newXml(xOp, "value", { name: "STRING1" }), tree.args[0], BLOCK_TYPE.text);
            translateMathToXml(xml.newXml(xOp, "value", { name: "STRING2" }), tree.args[1], BLOCK_TYPE.text);
            return;
          }
        }
      }
       translateMathToXml(x, tree);
      console.log(x);
       let ids = Blockly.Xml.domToWorkspace(x, w);
      console.log(ids);
    }
     */

  /*
          function clickCleanUp(e) {
              // if (window.confirm('Griffpatch: Tidy up your scripts?')) {
                  doCleanUp();
              // }
              e.preventDefault();
              return false;
          }
      */

  /*
    function clickInject(e) {
      let codeString = window.prompt("Griffpatch: Enter an expression (i.e. a+2*3)");
      if (codeString) {
        doInjectScripts(codeString);
      }
      e.preventDefault();
      return false;
    }
    */

  /**
   * Click Event Handler - User has clicked the replace variable option - ask for the variable to replace with...
   * @param e the event
   * @returns {boolean} cancelled?
   */


  clickReplace(e) {
    let wksp = this.utils.getWorkspace();
    this.hidePopups(wksp);
    setTimeout(() => {
      let wksp = this.utils.getWorkspace();
      let v = wksp.getVariableById(this.selVarID);
      let varName = window.prompt(this.msg("replace", {
        name: v.name
      }));

      if (varName) {
        this.doReplaceVariable(this.selVarID, varName, v.type);
      }
    }, 0);
    e.preventDefault();
    return false;
  }
  /**
   * Returns a Set of the top blocks in this workspace / sprite
   * @returns {Set<any>} Set of top blocks
   */


  getTopBlockIDs() {
    let wksp = this.utils.getWorkspace();
    let topBlocks = wksp.getTopBlocks();
    let ids = new Set();

    for (const block of topBlocks) {
      ids.add(block.id);
    }

    return ids;
  }
  /**
   * Initiates a drag event for all block stacks except those in the set of ids.
   * But why? - Because we know all the ids of the existing stacks before we paste / duplicate - so we can find the
   * new stack by excluding all the known ones.
   * @param ids Set of previously known ids
   */


  beginDragOfNewBlocksNotInIDs(ids) {
    if (!this.addon.settings.get("enablePasteBlocksAtMouse")) {
      return;
    }

    let wksp = this.utils.getWorkspace();
    let topBlocks = wksp.getTopBlocks();

    for (const block of topBlocks) {
      if (!ids.has(block.id)) {
        // console.log("I found a new block!!! - " + block.id);
        // todo: move the block to the mouse pointer?
        let mouseXYClone = {
          x: this.mouseXY.x,
          y: this.mouseXY.y
        };
        this.domHelpers.triggerDragAndDrop(block.svgPath_, null, mouseXYClone);
      }
    }
  }

  updateMousePosition(e) {
    this.mouseXY.x = e.clientX;
    this.mouseXY.y = e.clientY;
  }

  eventMouseMove(e) {
    this.updateMousePosition(e);
  }

  eventKeyDown(e) {
    function switchCostume(up) {
      // todo: select previous costume
      let selected = this.costTabBody.querySelector("div[class*='sprite-selector-item_is-selected']");
      let node = up ? selected.parentNode.previousSibling : selected.parentNode.nextSibling;

      if (node) {
        let wrapper = node.closest("div[class*=gui_flex-wrapper]");
        node.querySelector("div[class^='sprite-selector-item_sprite-name']").click();
        node.scrollIntoView({
          behavior: "auto",
          block: "center",
          inline: "start"
        });
        wrapper.scrollTop = 0;
      }
    }

    if (document.URL.indexOf("editor") <= 0) {
      return;
    }

    let ctrlKey = e.ctrlKey || e.metaKey;

    if (e.key === "f" && ctrlKey && !e.shiftKey) {
      // Ctrl + F (Override default Ctrl+F find)
      this.findInp.focus();
      this.findInp.select();
      e.cancelBubble = true;
      e.preventDefault();
      return true;
    }

    if (e.key === " " && ctrlKey) {
      // Ctrl + Space (Inject Code)
      this.middleClickWorkspace(e);
      e.cancelBubble = true;
      e.preventDefault();
      return true;
    }

    if (e.keyCode === 37 && ctrlKey) {
      // Ctrl + Left Arrow Key
      if (document.activeElement.tagName === "INPUT") {
        return;
      } // todo: if (!this.addon.settings.get("enableCtrlLeftRightNav")) {
      //         return;
      //       }


      if (this.isScriptEditor()) {
        this.utils.navigationHistory.goBack();
      } else if (this.isCostumeEditor()) {
        switchCostume(true);
      }

      e.cancelBubble = true;
      e.preventDefault();
      return true;
    }

    if (e.keyCode === 39 && ctrlKey) {
      // Ctrl + Right Arrow Key
      if (document.activeElement.tagName === "INPUT") {
        return;
      } // todo: if (!this.addon.settings.get("enableCtrlLeftRightNav")) {
      //         return;
      //       }


      if (this.isScriptEditor()) {
        this.utils.navigationHistory.goForward();
      } else if (this.isCostumeEditor()) {
        switchCostume(false);
      }

      e.cancelBubble = true;
      e.preventDefault();
      return true;
    }

    if (e.keyCode === 86 && ctrlKey && !e.griff) {
      // Ctrl + V
      // Set a timeout so we can take control of the paste after the event
      let ids = this.getTopBlockIDs();
      setTimeout(() => {
        this.beginDragOfNewBlocksNotInIDs(ids);
      }, 10);
    } // if (e.keyCode === 220 && (!document.activeElement || document.activeElement.tagName === 'INPUT')) {
    //
    // }

  }

  eventMouseDown(e) {
    this.updateMousePosition(e);

    if (this.ddOut && this.ddOut.classList.contains("vis") && !e.target.closest("#s3devDDOut")) {
      // If we click outside the dropdown, then instigate the hide code...
      this.hideDropDown();
    }

    if (this.floatInp && !e.target.closest("#s3devIDDOut")) {
      // If we click outside the dropdown, then instigate the hide code...
      this.hideFloatDropDown();
    }

    if (e.button === 1) {
      // Wheel button...
      try {
        this.middleClick(e);
      } catch (x) {
        console.error(x);
      }
    } else if (e.button === 2) {
      // Right click...
      let spriteSelector = e.target.closest("#react-tabs-3 div[class*='sprite-selector-item_sprite-selector-item']");

      if (spriteSelector) {
        let contextMenu = spriteSelector.getElementsByTagName("nav")[0];

        if (!contextMenu.querySelector("div.s3devSTT")) {
          contextMenu.insertAdjacentHTML("beforeend", "\n                            <div class=\"".concat(this.addon.tab.scratchClass("context-menu_menu-item", "context-menu_menu-item-bordered", {
            others: ["react-contextmenu-item", "s3devSTT"]
          }), "\" role=\"menuitem\"\n                                tabindex=\"-1\" aria-disabled=\"false\"><span>").concat(this.m("top"), "</span></div>\n                            <div class=\"").concat(this.addon.tab.scratchClass("context-menu_menu-item", {
            others: ["react-contextmenu-item", "s3devSTT"]
          }), "\" role=\"menuitem\"\n                                tabindex=\"-1\" aria-disabled=\"false\"><span>").concat(this.m("bottom"), "</span></div>\n                        "));
        }
      }

      let blockSvg = e.target.closest("[data-id]");
      let isBackground = !blockSvg && e.target.closest("svg.blocklySvg");

      if (blockSvg || isBackground) {
        let dataId = blockSvg && blockSvg.getAttribute("data-id");

        if (dataId || isBackground) {
          setTimeout(async () => {
            // Is there a popup menu to hi-jack?
            let widget = document.querySelector("div.blocklyWidgetDiv");

            if (!widget) {
              return;
            }

            let blocklyContextMenu = widget.querySelector("div.blocklyContextMenu");

            if (!blocklyContextMenu) {
              return;
            }

            if (isBackground) {
              let cleanupPlus = this.addon.settings.get("enableCleanUpPlus");
              let nodes = blocklyContextMenu.children;
              const realBlockly = await this.addon.tab.traps.getBlockly();

              if (cleanupPlus) {
                for (const node of nodes) {
                  if (node.textContent === realBlockly.Msg.CLEAN_UP) {
                    node.remove();
                    break;
                  }
                }
              }

              let html = cleanupPlus ? "\n                  <div\n                    id=\"s3devCleanUp\"\n                    class=\"goog-menuitem s3dev-mi ".concat(this.addon.tab.direction === "rtl" ? "goog-menuitem-rtl" : "", "\"\n                    role=\"menuitem\"\n                    style=\"user-select: none; border-top: 1px solid hsla(0, 0%, 0%, 0.15);\"\n                  >\n                      <div class=\"goog-menuitem-content\" style=\"user-select: none;\">").concat(this.m("clean-plus"), "</div>\n                  </div>\n              ") : "";
              html += "\n                  <div\n                    id=\"s3devPaste\"\n                    class=\"goog-menuitem s3dev-mi ".concat(this.addon.tab.direction === "rtl" ? "goog-menuitem-rtl" : "", "\"\n                    role=\"menuitem\"\n                    style=\"user-select: none;\"\n                  >\n                      <div class=\"goog-menuitem-content\" style=\"user-select: none;\">").concat(this.m("paste"), "</div>\n                  </div>\n              ");
              blocklyContextMenu.insertAdjacentHTML("beforeend", html);
            } else {
              let wksp = this.utils.getWorkspace();
              let block = wksp.getBlockById(dataId);
              let isFlyOut = block.workspace.isFlyout;
              /* todo - look at this menu code ***** !!!!!
                const BROADCAST_BLOCKS = ["event_whenbroadcastreceived", "event_broadcast", "event_broadcastandwait"];
                if (BROADCAST_BLOCKS.includes(block.type)) {
                  // Show Broadcast
                  const broadcastId = showBroadcastSingleton.getAssociatedBroadcastId(dataId);
                  if (broadcastId) {
                    for (const showKey of ["Senders", "Receivers"]) {
                      const googMenuItemContent = Object.assign(document.createElement("div"), {
                        textContent: this.msg(`show-${showKey}`.toLowerCase()),
                        style: "user-select: none;",
                        className: "goog-menuitem-content",
                      });
                      const googMenuItem = Object.assign(document.createElement("div"), {
                        id: `s3devShow${showKey}`,
                        className: "goog-menuitem s3dev-mi",
                        role: "menuitem",
                        style: "user-select: none;",
                      });
                      googMenuItem.addEventListener("click", () => {
                        hidePopups(wksp);
                        showBroadcastSingleton[`show${showKey}`](broadcastId);
                      });
                      googMenuItem.appendChild(googMenuItemContent);
                      blocklyContextMenu.appendChild(googMenuItem);
                    }
                  }
                }
                */

              if (!isFlyOut) {
                blocklyContextMenu.insertAdjacentHTML("beforeend", "\n                    <div id=\"s3devMakeSpace\" class=\"goog-menuitem s3dev-mi\" role=\"menuitem\" style=\"user-select: none; border-top: 1px solid hsla(0, 0%, 0%, 0.15);\">\n                        <div class=\"goog-menuitem-content\" style=\"user-select: none;\">".concat(this.m("make-space"), "</div>\n                    </div>\n                    <div id=\"s3devCopy\" class=\"goog-menuitem s3dev-mi\" role=\"menuitem\" style=\"user-select: none; border-top: 1px solid hsla(0, 0%, 0%, 0.15);\">\n                        <div class=\"goog-menuitem-content\" style=\"user-select: none;\">").concat(this.m("copy-all"), "</div>\n                    </div>\n                    <div id=\"s3devCopyBlock\" class=\"goog-menuitem s3dev-mi\" role=\"menuitem\" style=\"user-select: none;\">\n                        <div class=\"goog-menuitem-content\" style=\"user-select: none;\">").concat(this.m("copy-block"), "</div>\n                    </div>\n                    <div id=\"s3devCutBlock\" class=\"goog-menuitem s3dev-mi\" role=\"menuitem\" style=\"user-select: none;\">\n                        <div class=\"goog-menuitem-content\" style=\"user-select: none;\">").concat(this.m("cut-block"), "</div>\n                    </div>\n                  "));
              } // Is this a variable or a list?


              if (block && (block.getCategory() === "data" || block.getCategory() === "data-lists")) {
                blocklyContextMenu.insertAdjacentHTML("beforeend", "\n                        <div id=\"s3devReplaceAllVars\" class=\"goog-menuitem s3dev-mi\" role=\"menuitem\" style=\"user-select: none; border-top: 1px solid hsla(0, 0%, 0%, 0.15);\">\n                            <div class=\"goog-menuitem-content\" style=\"user-select: none;\">".concat(this.m("swap", {
                  var: block.getCategory() === "data" ? this.m("variables") : this.m("lists")
                }), "</div>\n                        </div>\n                  "));
                this.selVarID = block.getVars()[0];
              }
            }

            if (blocklyContextMenu.children.length < 15) {
              blocklyContextMenu.style.maxHeight = "none";
              widget.style.height = blocklyContextMenu.getBoundingClientRect().height + 12 + "px";
              blocklyContextMenu.style.maxHeight = "";
            }

            let copyDiv = blocklyContextMenu.querySelector("div#s3devCleanUp");

            if (copyDiv) {
              copyDiv.addEventListener("click", (...e) => this.doCleanUp(...e));
            }

            copyDiv = blocklyContextMenu.querySelector("div#s3devMakeSpace");

            if (copyDiv) {
              copyDiv.addEventListener("click", e => this.doCleanUp(e, dataId));
            }

            copyDiv = blocklyContextMenu.querySelector("div#s3devCopy");

            if (copyDiv) {
              copyDiv.addEventListener("click", (...e) => eventCopyClick(...e));
            }

            copyDiv = blocklyContextMenu.querySelector("div#s3devCopyBlock");

            if (copyDiv) {
              copyDiv.addEventListener("click", e => {
                eventCopyClick(e, 1);
              });
            }

            copyDiv = blocklyContextMenu.querySelector("div#s3devCutBlock");

            if (copyDiv) {
              copyDiv.addEventListener("click", e => {
                eventCopyClick(e, 2);
              });
            }

            copyDiv = blocklyContextMenu.querySelector("div#s3devReplaceAllVars");

            if (copyDiv) {
              copyDiv.addEventListener("click", (...e) => this.clickReplace(...e));
            }

            let devTools = this;

            function eventCopyClick(e, blockOnly) {
              let wksp = devTools.utils.getWorkspace();
              devTools.hidePopups(wksp);
              let block = wksp.getBlockById(dataId);

              if (block) {
                block.select();
                let next = blockOnly ? block.getNextBlock() : null;

                if (next) {
                  next.unplug(false); // setParent(null);
                } // separate child temporarily


                document.dispatchEvent(new KeyboardEvent("keydown", {
                  keyCode: 67,
                  ctrlKey: true
                }));

                if (next || blockOnly === 2) {
                  setTimeout(() => {
                    if (next) {
                      wksp.undo(); // undo the unplug above...
                    }

                    if (blockOnly === 2) {
                      let block = wksp.getBlockById(dataId);
                      _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].startUndoGroup(wksp);
                      block.dispose(true);
                      _blockly_UndoGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].endUndoGroup(wksp);
                    }
                  }, 0);
                }
              }
            }

            let pasteDiv = blocklyContextMenu.querySelector("div#s3devPaste");

            if (pasteDiv) {
              pasteDiv.addEventListener("click", function () {
                let wksp = devTools.utils.getWorkspace();
                devTools.hidePopups(wksp);
                let ids = devTools.getTopBlockIDs();
                document.dispatchEvent(new KeyboardEvent("keydown", {
                  keyCode: 86,
                  ctrlKey: true,
                  griff: true
                }));
                setTimeout(() => {
                  devTools.beginDragOfNewBlocksNotInIDs(ids);
                }, 10);
              });
            }
          }, 1);
        }
      }
    } else {
      let chk = e.target;

      if (chk && chk.tagName !== "BUTTON" && chk.getAttribute && !chk.getAttribute("role")) {
        chk = chk.parentNode;

        if (chk && chk.tagName !== "BUTTON" && chk.getAttribute && !chk.getAttribute("role")) {
          chk = chk.parentNode;
        }
      }

      if (chk && chk.className && chk.className.indexOf) {
        if (chk.className.indexOf("see-inside-button") >= 0) {
          // Try to re-inject GUI after rebuild
          setTimeout(() => this.initInner(), 200);
        }

        if (!this.canShare && chk.className.indexOf("share-button") >= 0) {
          // Commented for ScratchAddons

          /*e.cancelBubble = true;
                      e.preventDefault();
                       if (confirm("Griffpatch: Are you sure you want to share?")) {
                          // action the share!
                          canShare = true;
                          chk.click();
                      }*/
          return;
        }
      }

      chk = e.target.tagName === "SPAN" ? e.target.parentNode : e.target;

      if (chk.classList.contains("s3devSTT")) {
        if (chk.textContent === this.m("top") || chk.textContent === this.m("bottom")) {
          let spriteSelector = e.target.closest("div[class*='sprite-selector-item_sprite-selector-item']");
          this.moveCostumeTo(chk.textContent === this.m("top"), spriteSelector);
          e.cancelBubble = true;
          e.preventDefault();
        }
      }
    }
  }

  eventMouseUp(e) {
    this.updateMousePosition(e);

    if (e.button === 1 && e.target.closest("svg.blocklySvg")) {
      // On Linux systems, middle click is often treated as a paste.
      // We do not want this as we assign our own functionality to middle mouse.
      e.preventDefault();
    }
  }

  middleClickWorkspace(e) {
    if (!this.isScriptEditor()) {
      return;
    } // todo: if (!this.addon.settings.get("enableBlockInjector")) {
    //         return;
    //       }


    e.cancelBubble = true;
    e.preventDefault();
    let floatBar = document.getElementById("s3devFloatingBar");

    if (floatBar) {
      floatBar.remove();
    } // Popup new input box for block injection


    document.body.insertAdjacentHTML("beforeend", "\n            <div id=\"s3devFloatingBar\" dir=\"".concat(this.addon.tab.direction, "\">\n                <label class='title s3devLabel' id=s3devInsertLabel>\n                    <span style=\"display:none;\">").concat(this.m("insert"), " </span>\n                    <span id=s3devInsert class=\"s3devWrap\">\n                        <div id='s3devIDDOut' class=\"s3devDDOut\">\n                            <input id='s3devIInp' class=\"").concat(this.addon.tab.scratchClass("input_input-form", {
      others: "s3devInp"
    }), "\" type='search' placeholder='").concat(this.m("start-typing"), "' autocomplete='off'>\n                            <ul id='s3devIDD' class=\"s3devDD\"></ul>\n                        </div>\n                    </span>\n                </label>\n            </div>\n        "));
    floatBar = document.getElementById("s3devFloatingBar");
    floatBar.style.left = this.mouseXY.x + 16 + "px";
    floatBar.style.top = this.mouseXY.y - 8 + "px";
    this.floatInp = document.getElementById("s3devIInp");
    this.floatInp.focus(); // Build Filter List...

    this.buildFloatingFilterList(e, floatBar);
    const ddOut = document.getElementById("s3devIDDOut");
    ddOut.addEventListener("mousedown", (...e) => this.dropDownFloatClick(...e));
    this.floatInp.addEventListener("keyup", (...e) => this.floatInputChange(...e));
    this.floatInp.addEventListener("focus", (...e) => this.floatInputChange(...e));
    this.floatInp.addEventListener("keydown", (...e) => this.floatInputKeyDown(...e));
  }

  middleClick(e) {
    // Intercept clicks to allow jump to...?
    let blockSvg = e.target.closest("[data-id]");

    if (!blockSvg) {
      // Ok, so no selection... are we at least clicking on the workspace?
      if (e.target.closest("svg.blocklySvg")) {
        this.blockCursor = null; // Clear the cursor if using the mouse

        this.middleClickWorkspace(e);
      }

      return;
    }

    if (!this.addon.settings.get("enableMiddleClickFinder")) {
      return;
    }

    let w = this.utils.getWorkspace();
    let dataId = blockSvg.getAttribute("data-id");
    let block = w.getBlockById(dataId);

    if (!block) {
      return;
    } // Move outwards until we reach a block we can take action on


    for (; block; block = block.getSurroundParent()) {
      if (block.type === "procedures_call") {
        e.cancelBubble = true;
        e.preventDefault(); // todo: navigate to definition

        let findProcCode = block.getProcCode();
        let wksp = this.utils.getWorkspace();
        let topBlocks = wksp.getTopBlocks();

        for (const root of topBlocks) {
          if (root.type === "procedures_definition") {
            let label = root.getChildren()[0];
            let procCode = label.getProcCode();

            if (procCode && procCode === findProcCode) {
              // Found... navigate to it!
              this.centerTop(root);
              return;
            }
          }
        }
      }

      if (block.type === "procedures_definition") {
        let id = block.id ? block.id : block.getId ? block.getId() : null;
        this.findInp.focus();
        this.showDropDown(null, id); // findInp.select();

        e.cancelBubble = true;
        e.preventDefault();
        return;
      }

      if (block.type === "data_variable" || block.type === "data_changevariableby" || block.type === "data_setvariableto") {
        let id = block.getVars()[0];
        this.findInp.focus();
        this.showDropDown(null, id, block); // let button = document.getElementById('s3devReplace');

        this.selVarID = id; // button.classList.remove('s3devHide');

        e.cancelBubble = true;
        e.preventDefault();
        return;
      }

      if (block.type === "event_whenbroadcastreceived" || block.type === "event_broadcastandwait" || block.type === "event_broadcast") {
        // todo: actually index the broadcasts...!
        let id = block.id;
        this.findInp.focus();
        this.showDropDown(null, id, block);
        this.selVarID = id;
        e.cancelBubble = true;
        e.preventDefault();
        return;
      }
    }

    e.cancelBubble = true;
    e.preventDefault();
  }

  getEdgeTypeClass(block) {
    switch (block.edgeShape_) {
      case 1:
        return "boolean";

      case 2:
        return "reporter";

      default:
        return block.startHat_ ? "hat" : "block";
    }
  }

  buildFloatingFilterList(e, floatBar) {
    // todo: Iterate through the toolbox?
    let options = [];
    let t = this.utils.getWorkspace().getToolbox();
    let blocks = t.flyout_.getWorkspace().getTopBlocks(); // 107 blocks, not in order... but we can sort by y value or description right :)

    let fullDom = Blockly.Xml.workspaceToDom(t.flyout_.getWorkspace());
    const doms = {};

    for (const x of fullDom.children) {
      if (x.tagName === "BLOCK") {
        // let type = x.getAttribute('type');
        let id = x.getAttribute("id");
        doms[id] = x;
      }
    }

    for (const block of blocks) {
      this.getBlockText(block, options, doms);
    } // Griffpatch - on second thoughts - lets sort blocks by length so that shortest ones appear at the top.


    options.sort((a, b) => a.desc.length < b.desc.length ? -1 : a.desc.length > b.desc.length ? 1 : a.desc.localeCompare(b.desc)); // Previous sort was just alphabetical
    // options.sort((a, b) => a.desc.localeCompare(b.desc));

    const dd = document.getElementById("s3devIDD");
    let count = 0; //DROPDOWN_BLOCK_LIST_MAX_ROWS

    for (const option of options) {
      const li = document.createElement("li");
      const desc = option.desc; // bType = hat block reporter boolean

      let bType = this.getEdgeTypeClass(option.block);
      count++;
      li.innerText = desc;
      li.data = {
        text: desc,
        lower: " " + desc.toLowerCase(),
        option: option
      };
      li.className = "var " + (option.block.isScratchExtension ? "extension" : option.block.getCategory()) + " " + bType; // proc.cls;

      if (count > DROPDOWN_BLOCK_LIST_MAX_ROWS) {
        // Limit maximum number of rows to prevent lag when no filter is applied
        li.style.display = "none";
      }

      dd.appendChild(li);
    }

    const ddOut = document.getElementById("s3devIDDOut");
    ddOut.classList.add("vis"); // console.log(options);
  }
  /**
   * Flesh out a blocks description - duplicate up blocks with contained picklists (like list drop downs)
   * @param block
   * @param options
   * @param doms
   * @returns {string}
   */


  getBlockText(block, options, doms) {
    // block.type;  "looks_nextbackdrop"
    let desc;
    let picklist, pickField;
    let dom = doms[block.id]; // dom = doms[block.type];

    const process = block => {
      for (const input of block.inputList) {
        // input.name = "", input.type = 5
        let fields = input.fieldRow;

        for (const field of fields) {
          // field --- Blockly.FieldLabel .className = "blocklyText"
          // Blockly.FieldDropdown --- .className = "blocklyText blocklyDropdownText"
          let text;

          if (!picklist && field.className_ === "blocklyText blocklyDropdownText") {
            picklist = field.getOptions();
            pickField = field.name;

            if (picklist && picklist.length > 0) {
              text = "^^";
            } else {
              text = field.getText();
            }
          } else {
            text = field.getText();
          }

          desc = (desc ? desc + " " : "") + text;
        }

        if (input.connection) {
          let innerBlock = input.connection.targetBlock();

          if (innerBlock) {
            process(innerBlock); // Recursive process connected child blocks...
          }
        }
      }
    };

    process(block);

    if (picklist) {
      for (const item of picklist) {
        let code = item[1];

        if (typeof code !== "string" || // Audio Record is a function!
        code === "DELETE_VARIABLE_ID" || code === "RENAME_VARIABLE_ID" || code === "NEW_BROADCAST_MESSAGE_ID" || code === "NEW_BROADCAST_MESSAGE_ID") {
          continue; // Skip these
        }

        options.push({
          desc: desc.replace("^^", item[0]),
          block: block,
          dom: dom,
          option: item,
          pickField: pickField
        });
      }
    } else {
      options.push({
        desc: desc,
        block: block,
        dom: dom
      });
    }

    return desc;
  }

  floatInputKeyDown(e) {
    if (e.keyCode === 38) {
      this.navigateFloatFilter(-1);
      e.preventDefault();
      return;
    }

    if (e.keyCode === 40) {
      this.navigateFloatFilter(1);
      e.preventDefault();
      return;
    }

    if (e.keyCode === 13) {
      // Enter
      let dd = document.getElementById("s3devIDD");
      let sel = dd.querySelector(".sel");

      if (sel) {
        this.dropDownFloatClick(e);
      }

      e.cancelBubble = true;
      e.preventDefault();
      return;
    }

    if (e.keyCode === 27) {
      // Escape
      let findInp = document.getElementById("s3devIInp");

      if (findInp.value.length > 0) {
        findInp.value = ""; // Clear search first, then close on second press

        this.floatInputChange(e);
      } else {
        this.reallyHideFloatDropDown(true);
      }

      e.preventDefault();
      return;
    }
  }

  navigateFloatFilter(dir) {
    let dd = document.getElementById("s3devIDD");
    let sel = dd.getElementsByClassName("sel");
    let nxt;

    if (sel.length > 0 && sel[0].style.display !== "none") {
      nxt = dir === -1 ? sel[0].previousSibling : sel[sel.length - 1].nextSibling;
    } else {
      nxt = dd.children[0];
      dir = 1;
    }

    while (nxt && nxt.style.display === "none") {
      nxt = dir === -1 ? nxt.previousSibling : nxt.nextSibling;
    }

    if (nxt) {
      for (const i of sel) {
        i.classList.remove("sel");
      }

      nxt.classList.add("sel"); // centerTop(nxt.data.labelID);
    }
  }
  /**
   * This is a feature in progress - can we have a virtual cursor that allows the next injected element position be automated
   * @param block a blockly block
   * @param typ type
   */


  findNextHole(block, typ) {
    /*
      const inputs = block.inputList;
      if (inputs) {
        /!** Blockly.Input *!/
        for (const input of inputs) {
          const fieldRow = input.fieldRow;
          if (fieldRow) {
            /!** Blockly.FieldNumber *!/
            for (const field of fieldRow) {
              if (field.argType_ && field.argType_.includes(typ)) {
              }
            }
          }
        }
      }
    */
  }
  /**
   * Inject the selected block into the script
   * @param e
   */


  dropDownFloatClick(e) {
    e.cancelBubble = true;

    if (!e.target.closest("input")) {
      e.preventDefault();
    }

    let wksp = this.utils.getWorkspace();
    let sel = e && e.target;

    if (sel.tagName === "B") {
      sel = sel.parentNode;
    }

    if (e instanceof MouseEvent && sel.tagName !== "LI") {
      // Mouse clicks need to be on a block...
      return;
    }

    if (!sel || !sel.data) {
      let dd = document.getElementById("s3devIDD");
      sel = dd.querySelector(".sel");
    }

    if (!sel) {
      return;
    }

    const xml = new _XML_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    let x = xml.xmlDoc.firstChild;
    let option = sel.data.option; // block:option.block, dom:option.dom, option:option.option

    if (option.option) {
      // We need to tweak the dropdown in this xml...
      let field = option.dom.querySelector("field[name=" + option.pickField + "]");

      if (field.getAttribute("id")) {
        field.innerText = option.option[0];
        field.setAttribute("id", option.option[1] + "-" + option.option[0]);
      } else {
        field.innerText = option.option[1]; // griffpatch - oops! option.option[1] not 0?
      }
    }

    x.appendChild(option.dom);
    let ids = Blockly.Xml.domToWorkspace(x, wksp);
    this.reallyHideFloatDropDown(true);
    let block = wksp.getBlockById(ids[0]);

    if (this.blockCursor) {
      // What sort of block did we just inject?
      let typ = this.getEdgeTypeClass(option.block);

      if (typ === "boolean") {
        this.findNextHole(this.blockCursor, "");
      } else if (typ === "reporter") {
        this.findNextHole(this.blockCursor, typ);
      }
    }

    this.domHelpers.triggerDragAndDrop(block.svgPath_, null, {
      x: this.mouseXY.x,
      y: this.mouseXY.y
    });
    this.blockCursor = block;
  }

  floatInputChange(e) {
    let ddOut = document.getElementById("s3devIDDOut");

    if (!ddOut.classList.contains("vis")) {// showDropDown();
      // hideDropDown(); // Start timer to hide if not got focus
    }

    let findInp = document.getElementById("s3devIInp"); // Filter the list...

    let val = (findInp.value || "").toLowerCase();

    if (val === prevVal) {
      return;
    }

    prevVal = val;
    this.multi.blocks = null;
    let dd = document.getElementById("s3devIDD");
    let p = dd.parentNode;
    dd.remove();
    let count = 0;
    let split = val.split(" ");
    let listLI = dd.getElementsByTagName("li");

    for (const li of listLI) {
      const procCode = li.data.text;
      const lower = li.data.lower; // let i = li.data.lower.indexOf(val);
      // let array = regExp.exec(li.data.lower);

      let im = 0;
      let match = [];

      for (let si = 0; si < split.length; si++) {
        let find = " " + split[si];
        let idx = lower.indexOf(find, im);

        if (idx === -1) {
          match = null;
          break;
        }

        match.push(idx);
        im = idx + find.length;
      }

      if (count < DROPDOWN_BLOCK_LIST_MAX_ROWS && match) {
        li.style.display = "block";
        this.dom_removeChildren(li);
        let i = 0;

        for (let iM = 0; iM < match.length; iM++) {
          let im = match[iM];

          if (im > i) {
            li.appendChild(document.createTextNode(procCode.substring(i, im)));
            i = im;
          }

          let bText = document.createElement("b");
          let len = split[iM].length;
          bText.appendChild(document.createTextNode(procCode.substr(i, len)));
          li.appendChild(bText);
          i += len;
        }

        if (i < procCode.length) {
          li.appendChild(document.createTextNode(procCode.substr(i)));
        }

        if (count === 0) {
          li.classList.add("sel");
        } else {
          li.classList.remove("sel");
        }

        count++;
      } else {
        li.style.display = "none";
        li.classList.remove("sel");
      }
    }

    p.append(dd);
  } // Loop until the DOM is ready for us...


  initInner() {
    let root = document.querySelector("ul[class*=gui_tab-list_]");
    let guiTabs = root && root.childNodes;

    if (!guiTabs || guiTabs.length < 3) {
      setTimeout(() => this.initInner(), 1000);
      return;
    }

    if (this.codeTab && guiTabs[0] !== this.codeTab) {
      // We have been CHANGED!!! - Happens when going to project page, and then back inside again!!!
      this.domHelpers.unbindAllEvents();
    }

    this.codeTab = guiTabs[0];
    this.costTab = guiTabs[1];
    this.costTabBody = document.querySelector("div[aria-labelledby=" + this.costTab.id + "]");

    if (!document.getElementById("s3devFind")) {
      // noinspection JSUnresolvedVariable
      root.insertAdjacentHTML("beforeend", "\n                <div id=\"s3devToolBar\">\n                    <label class='title s3devLabel' id=s3devFindLabel>\n                        <span>".concat(this.m("find"), " ").concat(this.addon.self._isDevtoolsExtension ? "" : '<a href="#" class="s3devAction" id="s3devHelp" style="/*s-a*/ margin-left: 0; font-size: 10px; /*s-a*/">(?)</a>', " </span>\n                        <span id=s3devFind class=\"s3devWrap\">\n                            <div id='s3devDDOut' class=\"s3devDDOut\">\n                                <input id='s3devInp' class=\"").concat(this.addon.tab.scratchClass("input_input-form", {
        others: "s3devInp"
      }), "\" type='search' placeholder='").concat(this.m("find-placeholder"), "' autocomplete='off'>\n                                <ul id='s3devDD' class=\"s3devDD\"></ul>\n                            </div>\n                        </span>\n                        <a id=\"s3devDeep\" class=\"s3devAction s3devHide\" href=\"#\">").concat(this.m("deep"), "</a>\n                        <div ").concat(this.addon.self._isDevtoolsExtension ? "" : 'style="display: none;"', "><a href=\"#\" class=\"s3devAction\" id=\"s3devHelp\"><b>").concat(this.m("help"), "</b></a>\n                        <a href=\"https://www.youtube.com/griffpatch\" class=\"s3devAction\" target=\"_blank\" id=\"s3devHelp\" rel=\"noreferrer noopener\">").concat(this.m("tutorials"), "</a></div>\n                    </label>\n<!--                    <a id=\"s3devCleanUp\" class=\"s3devAction\" href=\"#\">Clean Up</a>-->\n<!--                    <a id=\"s3devReplace\" class=\"s3devAction s3devHide\" href=\"#\">Replace All</a>-->\n                </div>\n            "));
      this.find = document.getElementById("s3devFind");
      this.findInp = document.getElementById("s3devInp");
      this.ddOut = document.getElementById("s3devDDOut");
      this.domHelpers.bindOnce(this.ddOut, "mousedown", (...e) => this.dropDownClick(...e), undefined);
      this.dd = document.getElementById("s3devDD"); // bindOnce(find, 'mouseenter', showDropDown);
      // bindOnce(find, 'mouseleave', hideDropDown);

      this.domHelpers.bindOnce(this.findInp, "keyup", (...e) => this.inputChange(...e), undefined);
      this.domHelpers.bindOnce(this.findInp, "keydown", (...e) => this.inputKeyDown(...e), undefined);
      this.domHelpers.bindOnce(this.findInp, "focus", (...e) => this.inputChange(...e), undefined);
      this.domHelpers.bindOnce(document.getElementById("s3devHelp"), "click", (...e) => this.eventClickHelp(...e), undefined);
      this.domHelpers.bindOnce(document, "keydown", (...e) => this.eventKeyDown(...e), true);
    }

    this.domHelpers.bindOnce(document, "mousemove", (...e) => this.eventMouseMove(...e), true);
    this.domHelpers.bindOnce(document, "mousedown", (...e) => this.eventMouseDown(...e), true); // true to capture all mouse downs 'before' the dom events handle them

    this.domHelpers.bindOnce(document, "mouseup", (...e) => this.eventMouseUp(...e), true); // bindOnce(document.getElementById("s3devDeep"), "click", deepSearch);
    // bindOnce(document.getElementById('s3devCleanUp'),'click', clickCleanUp);
    // bindOnce(document.getElementById("s3devInject"), "click", clickInject);
    // bindOnce(document.getElementById('s3devReplace'), 'click', clickReplace);
  }

}

class Multi {
  constructor(utils) {
    this.idx = 0;
    this.blocks = null;
    this.selID = null;
    /**
     * @type {Utils}
     */

    this.utils = utils;
  }

  update() {
    const count = document.getElementById("s3devMultiCount");
    count.innerText = this.blocks && this.blocks.length > 0 ? enc(this.idx + 1 + " / " + this.blocks.length) : "0";
    this.selID = this.idx < this.blocks.length ? this.blocks[this.idx].id : null;
  }

  navLeft(e) {
    return this.navSideways(e, -1);
  }

  navRight(e) {
    return this.navSideways(e, 1);
  }

  navSideways(e, dir) {
    if (this.blocks && this.blocks.length > 0) {
      this.idx = (this.idx + dir + this.blocks.length) % this.blocks.length; // + length to fix negative modulo js issue.

      this.update();
      this.utils.scrollBlockIntoView(this.blocks[this.idx]);
    }

    if (e) {
      e.cancelBubble = true;
      e.preventDefault();
    }

    return false;
  }

}

class Col {
  /**
   * @param x {Number} x position (for ordering)
   * @param count {Number}
   * @param blocks {[Block]}
   */
  constructor(x, count, blocks) {
    /**
     * x position (for ordering)
     * @type {Number}
     */
    this.x = x;
    /**
     * @type {Number}
     */

    this.count = count;
    /**
     * @type {[Blockly.Block]}
     */

    this.blocks = blocks;
  }

}

const DROPDOWN_BLOCK_LIST_MAX_ROWS = 25;
let rhdd = 0;
let rhdd2 = 0;
let prevVal = "";

function enc(str) {
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/DomHelpers.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/editor-devtools/DomHelpers.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DomHelpers; });
class DomHelpers {
  constructor(addon) {
    this.addon = addon;
    this.vm = addon.tab.traps.vm;
    /**
     * @type {eventDetails[]}
     */

    this.events = [];
  }
  /**
   * Simulate a drag and drop programmatically through javascript
   * @param selectorDrag
   * @param selectorDrop
   * @param mouseXY
   * @returns {boolean}
   */


  triggerDragAndDrop(selectorDrag, selectorDrop, mouseXY) {
    // function for triggering mouse events
    let fireMouseEvent = function fireMouseEvent(type, elem, centerX, centerY) {
      let evt = document.createEvent("MouseEvents");
      evt.initMouseEvent(type, true, true, window, 1, 1, 1, centerX, centerY, false, false, false, false, 0, elem);
      elem.dispatchEvent(evt);
    }; // fetch target elements


    let elemDrag = selectorDrag; // document.querySelector(selectorDrag);

    let elemDrop = selectorDrop; // document.querySelector(selectorDrop);

    if (!elemDrag
    /* || !elemDrop*/
    ) {
        return false;
      } // calculate positions


    let pos = elemDrag.getBoundingClientRect();
    let center1X = Math.floor((pos.left + pos.right) / 2);
    let center1Y = Math.floor((pos.top + pos.bottom) / 2); // mouse over dragged element and mousedown

    fireMouseEvent("mouseover", elemDrag, center1X, center1Y);
    fireMouseEvent("mousedown", elemDrag, center1X, center1Y); // start dragging process over to drop target

    fireMouseEvent("dragstart", elemDrag, center1X, center1Y);
    fireMouseEvent("drag", elemDrag, center1X, center1Y);
    fireMouseEvent("mousemove", elemDrag, center1X, center1Y);

    if (!elemDrop) {
      if (mouseXY) {
        // console.log(mouseXY);
        let center2X = mouseXY.x;
        let center2Y = mouseXY.y;
        fireMouseEvent("drag", elemDrag, center2X, center2Y);
        fireMouseEvent("mousemove", elemDrag, center2X, center2Y);
      }

      return false;
    }

    pos = elemDrop.getBoundingClientRect();
    let center2X = Math.floor((pos.left + pos.right) / 2);
    let center2Y = Math.floor((pos.top + pos.bottom) / 2);
    fireMouseEvent("drag", elemDrag, center2X, center2Y);
    fireMouseEvent("mousemove", elemDrop, center2X, center2Y); // trigger dragging process on top of drop target

    fireMouseEvent("mouseenter", elemDrop, center2X, center2Y);
    fireMouseEvent("dragenter", elemDrop, center2X, center2Y);
    fireMouseEvent("mouseover", elemDrop, center2X, center2Y);
    fireMouseEvent("dragover", elemDrop, center2X, center2Y); // release dragged element on top of drop target

    fireMouseEvent("drop", elemDrop, center2X, center2Y);
    fireMouseEvent("dragend", elemDrag, center2X, center2Y);
    fireMouseEvent("mouseup", elemDrag, center2X, center2Y);
    return true;
  }

  bindOnce(dom, event, func, capture) {
    capture = !!capture;
    dom.removeEventListener(event, func, capture);
    dom.addEventListener(event, func, capture);
    this.events.push(new eventDetails(dom, event, func, capture));
  }

  unbindAllEvents() {
    for (const event of this.events) {
      event.dom.removeEventListener(event.event, event.func, event.capture);
    }

    this.events = [];
  }

}
/**
 * A record of an event
 */

class eventDetails {
  constructor(dom, event, func, capture) {
    this.dom = dom;
    this.event = event;
    this.func = func;
    this.capture = capture;
  }

}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/XML.js":
/*!**************************************************!*\
  !*** ./src/addons/addons/editor-devtools/XML.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XML; });
/**
 * A fake XML class to use in place of the real XML for faking things?
 */
class XML {
  constructor() {
    this.xmlDoc = document.implementation.createDocument(null, "xml");
  }

  newXml(x, tagName, attrs) {
    let xAdd = this.xmlDoc.createElement(tagName);
    x.appendChild(xAdd);
    return this.setAttr(xAdd, attrs);
  }

  setAttr(x, attrs) {
    if (attrs) {
      for (const key of Object.keys(attrs)) {
        if (key === "text") {
          x.appendChild(this.xmlDoc.createTextNode(attrs[key]));
        } else {
          x.setAttribute(key, attrs[key]);
        }
      }
    }

    return x;
  }

}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/blockly/BlockFlasher.js":
/*!*******************************************************************!*\
  !*** ./src/addons/addons/editor-devtools/blockly/BlockFlasher.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockFlasher; });
/**
 * Helper class to flash a Blockly scratch block in the users workspace
 */
class BlockFlasher {
  /**
   * FLash a block 3 times
   * @param block the block to flash
   */
  static flash(block) {
    if (myFlash.timerID > 0) {
      clearTimeout(myFlash.timerID);

      if (myFlash.block.svgPath_) {
        myFlash.block.svgPath_.style.fill = "";
      }
    }

    let count = 4;
    let flashOn = true;
    myFlash.block = block;
    /**
     * Internal method to switch the colour of a block between light yellow and it's original colour
     * @private
     */

    function _flash() {
      if (myFlash.block.svgPath_) {
        myFlash.block.svgPath_.style.fill = flashOn ? "#ffff80" : "";
      }

      flashOn = !flashOn;
      count--;

      if (count > 0) {
        myFlash.timerID = setTimeout(_flash, 200);
      } else {
        myFlash.timerID = 0;
        myFlash.block = null;
      }
    }

    _flash();
  }

}
const myFlash = {
  block: null,
  timerID: null
};

/***/ }),

/***/ "./src/addons/addons/editor-devtools/blockly/UndoGroup.js":
/*!****************************************************************!*\
  !*** ./src/addons/addons/editor-devtools/blockly/UndoGroup.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoGroup; });
/**
 * This class is dedicated to maintaining the Undo stack of Blockly
 * It allows us to initiate an undo group such that all subsequent operations are recorded as a single
 * undoable transaction.
 */
class UndoGroup {
  /**
   * Start an Undo group - begin recording
   * @param workspace the workspace
   */
  static startUndoGroup(workspace) {
    const undoStack = workspace.undoStack_;

    if (undoStack.length) {
      undoStack[undoStack.length - 1]._devtoolsLastUndo = true;
    }
  }
  /**
   * End an Undo group - stops recording
   * @param workspace the workspace
   */


  static endUndoGroup(workspace) {
    const undoStack = workspace.undoStack_; // Events (responsible for undoStack updates) are delayed with a setTimeout(f, 0)
    // https://github.com/LLK/scratch-blocks/blob/f159a1779e5391b502d374fb2fdd0cb5ca43d6a2/core/events.js#L182

    setTimeout(() => {
      const group = generateUID();

      for (let i = undoStack.length - 1; i >= 0 && !undoStack[i]._devtoolsLastUndo; i--) {
        undoStack[i].group = group;
      }
    }, 0);
  }

}
/**
 * https://github.com/LLK/scratch-blocks/blob/f159a1779e5391b502d374fb2fdd0cb5ca43d6a2/core/events.js#L182
 * @returns {string}
 * @private
 */

function generateUID() {
  const CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%()*+,-./:;=?@[]^_`{|}~";
  let result = "";

  for (let i = 0; i < 20; i++) {
    result += CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
  }

  return result;
}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/blockly/Utils.js":
/*!************************************************************!*\
  !*** ./src/addons/addons/editor-devtools/blockly/Utils.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Utils; });
/* harmony import */ var _BlockInstance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BlockInstance.js */ "./src/addons/addons/editor-devtools/BlockInstance.js");
/* harmony import */ var _BlockFlasher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BlockFlasher.js */ "./src/addons/addons/editor-devtools/blockly/BlockFlasher.js");

 // A file to split Editor Devtools by features.

class Utils {
  constructor(addon) {
    this.addon = addon;
    /**
     * Scratch Virtual Machine
     * @type {null|*}
     */

    this.vm = this.addon.tab.traps.vm; // this._myFlash = { block: null, timerID: null, colour: null };

    this.offsetX = 32;
    this.offsetY = 32;
    this.navigationHistory = new NavigationHistory(this);
    /**
     * The workspace
     */

    this._workspace = null;
  }
  /**
   * Get the Scratch Editing Target
   * @returns {?Target} the scratch editing target
   */


  getEditingTarget() {
    return this.vm.runtime.getEditingTarget();
  }
  /**
   * Set the current workspace (switches sprites)
   * @param targetID {string}
   */


  setEditingTarget(targetID) {
    if (this.getEditingTarget().id !== targetID) {
      this.vm.setEditingTarget(targetID);
    }
  }
  /**
   * Returns the main workspace
   * @returns !Blockly.Workspace
   */


  getWorkspace() {
    const currentWorkspace = Blockly.getMainWorkspace();

    if (currentWorkspace.getToolbox()) {
      // Sadly get get workspace does not always return the 'real' workspace... Not sure how to get that at the moment,
      //  but we can work out whether it's the right one by whether it has a toolbox.
      this._workspace = currentWorkspace;
    }

    return this._workspace;
  }
  /**
   * Based on wksp.centerOnBlock(li.data.labelID);
   * @param blockOrId {Blockly.Block|{id}|BlockInstance} A Blockly Block, a block id, or a BlockInstance
   * @param [force] {boolean} if true, the view always moves, otherwise only move if the selected element is not entirely visible
   */


  scrollBlockIntoView(blockOrId, force) {
    let workspace = this.getWorkspace();
    /** @type {Blockly.Block} */

    let block; // or is it really a Blockly.BlockSvg?

    if (blockOrId instanceof _BlockInstance_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      // Switch to sprite
      this.setEditingTarget(blockOrId.targetId); // Highlight the block!

      block = workspace.getBlockById(blockOrId.id);
    } else {
      block = blockOrId && blockOrId.id ? blockOrId : workspace.getBlockById(blockOrId);
    }

    if (!block) {
      return;
    }
    /**
     * !Blockly.Block
     */


    let root = block.getRootBlock();
    let base = this.getTopOfStackFor(block);
    let ePos = base.getRelativeToSurfaceXY(),
        // Align with the top of the block
    rPos = root.getRelativeToSurfaceXY(),
        // Align with the left of the block 'stack'
    scale = workspace.scale,
        x = rPos.x * scale,
        y = ePos.y * scale,
        xx = block.width + x,
        // Turns out they have their x & y stored locally, and they are the actual size rather than scaled or including children...
    yy = block.height + y,
        s = workspace.getMetrics();

    if (x < s.viewLeft + this.offsetX - 4 || xx > s.viewLeft + s.viewWidth || y < s.viewTop + this.offsetY - 4 || yy > s.viewTop + s.viewHeight) {
      // sx = s.contentLeft + s.viewWidth / 2 - x,
      let sx = x - s.contentLeft - this.offsetX,
          // sy = s.contentTop - y + Math.max(Math.min(32, 32 * scale), (s.viewHeight - yh) / 2);
      sy = y - s.contentTop - this.offsetY;
      this.navigationHistory.storeView(this.navigationHistory.peek(), 64); // workspace.hideChaff(),

      workspace.scrollbar.set(sx, sy);
      this.navigationHistory.storeView({
        left: sx,
        top: sy
      }, 64);
    }

    _BlockFlasher_js__WEBPACK_IMPORTED_MODULE_1__["default"].flash(block);
  }
  /**
   * Find the top stack block of a stack
   * @param block a block in a stack
   * @returns {*} a block that is the top of the stack of blocks
   */


  getTopOfStackFor(block) {
    let base = block;

    while (base.getOutputShape() && base.getSurroundParent()) {
      base = base.getSurroundParent();
    }

    return base;
  }

}

class NavigationHistory {
  constructor(utils) {
    this.utils = utils;
    this.views = [];
    this.forward = [];
  }
  /**
   * Keep a record of the scroll and zoom position
   */


  storeView(next, dist) {
    this.forward = [];
    let workspace = this.utils.getWorkspace(),
        s = workspace.getMetrics();
    let pos = {
      left: s.viewLeft,
      top: s.viewTop
    };

    if (!next || distance(pos, next) > dist) {
      this.views.push(pos);
    }
  }

  peek() {
    return this.views.length > 0 ? this.views[this.views.length - 1] : null;
  }

  goBack() {
    const workspace = this.utils.getWorkspace(),
          s = workspace.getMetrics();
    let pos = {
      left: s.viewLeft,
      top: s.viewTop
    };
    let view = this.peek();

    if (!view) {
      return;
    }

    if (distance(pos, view) < 64) {
      // Go back to current if we are already far away from it
      if (this.views.length > 1) {
        this.views.pop();
        this.forward.push(view);
      }
    }

    view = this.peek();

    if (!view) {
      return;
    }

    let sx = view.left - s.contentLeft,
        sy = view.top - s.contentTop; // transform.setTranslate(-600,0);

    workspace.scrollbar.set(sx, sy);
    /*
              let blocklySvg = document.getElementsByClassName('blocklySvg')[0];
              let blocklyBlockCanvas = blocklySvg.getElementsByClassName('blocklyBlockCanvas')[0];
              let transform = blocklyBlockCanvas.transform.baseVal.getItem(0);
              let scale = blocklyBlockCanvas.transform.baseVal.getItem(1);
               let transformMatrix = transform.matrix;
              let scaleMatrix = scale.matrix;
               console.log('Transform - getMetrics', s);
              console.log('sx, sy: ', sx, sy);
              console.log('left, top: ', view.left, view.top);
              console.log('contentLeft, right:', s.contentLeft, s.contentTop);
              console.log('transform, scale matrix: ', transformMatrix, scaleMatrix);
    */
  }

  goForward() {
    let view = this.forward.pop();

    if (!view) {
      return;
    }

    this.views.push(view);
    let workspace = this.utils.getWorkspace(),
        s = workspace.getMetrics();
    let sx = view.left - s.contentLeft,
        sy = view.top - s.contentTop;
    workspace.scrollbar.set(sx, sy);
  }

}

function distance(pos, next) {
  return Math.sqrt(Math.pow(pos.left - next.left, 2) + Math.pow(pos.top - next.top, 2));
}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/icon--close.svg":
/*!***********************************************************!*\
  !*** ./src/addons/addons/editor-devtools/icon--close.svg ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/cb666b99d3528f91b52f985dfb102afa.svg";

/***/ }),

/***/ "./src/addons/addons/editor-devtools/show-broadcast.js":
/*!*************************************************************!*\
  !*** ./src/addons/addons/editor-devtools/show-broadcast.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShowBroadcast; });
// A file to split Editor Devtools by features.
// Unlike userscript.js, this file mainly interacts with VM.
class ShowBroadcast {
  constructor(addon) {
    this.addon = addon;
    this.vm = this.addon.tab.traps.vm;
    this.highlights = {
      timeoutId: 0,
      callback: () => {}
    };
  }

  showSenders(broadcastId) {
    this.highlightTargets(this.getTargetsWithSenders(broadcastId));
  }

  getTargetsWithSenders(broadcastId) {
    const targetWithSenders = [];

    for (const target of this.vm.runtime.targets) {
      if (!target.isOriginal) return;

      for (const blockId of Object.keys(target.blocks._blocks)) {
        const block = target.blocks.getBlock(blockId);

        if (block.inputs.BROADCAST_INPUT) {
          const input = block.inputs.BROADCAST_INPUT; // For results, blocks must NOT be inserted, for convenience.

          if (input.block === input.shadow && target.blocks.getBlock(input.shadow).fields.BROADCAST_OPTION.id === broadcastId) {
            targetWithSenders.push(target);
            break;
          }
        }
      }
    }

    return targetWithSenders;
  }

  showReceivers(broadcastId) {
    this.highlightTargets(this.getTargetsWithReceivers(broadcastId));
  }

  getTargetsWithReceivers(broadcastId) {
    const targetWithReceivers = [];

    for (const target of this.vm.runtime.targets) {
      if (!target.isOriginal) return;

      for (const blockId of Object.keys(target.blocks._blocks)) {
        const block = target.blocks.getBlock(blockId);

        if (block.opcode === "event_whenbroadcastreceived" && block.fields.BROADCAST_OPTION.id === broadcastId) {
          targetWithReceivers.push(target);
          break;
        }
      }
    }

    return targetWithReceivers;
  }

  highlightTargets(targets) {
    if (this.highlights.timeoutId) {
      this.highlights.callback();
      clearTimeout(this.highlights.timeoutId);
      this.highlights = {
        timeoutId: 0,
        callback: () => {}
      };
    }

    const elemPendingToRemoveHighlights = [];

    for (const target of targets) {
      let elem = null;

      if (target.isStage) {
        elem = document.querySelector('div[class*="stage-selector_header"]');
      } else if (target.isOriginal) {
        // This is one of the most ridiculous code I've ever written.
        // This essentially comparses sprite names to textContent so that we can add CSS.
        const possibleElements = document.querySelectorAll('div[class*="sprite-selector-item_sprite-name"]');
        const spriteNameElem = Array.prototype.find.call(possibleElements, elem => elem.textContent === target.getName());
        if (!spriteNameElem) continue;
        elem = spriteNameElem.parentElement;
      }

      elem.dataset.highlighted = "true";
      elemPendingToRemoveHighlights.push(elem);
    }

    const callbackFactory = elemToRemoveHighlights => () => {
      for (const removingElem of elemToRemoveHighlights) {
        if (!removingElem.isConnected) continue;
        removingElem.dataset.highlighted = "false";
      }
    };

    const callback = callbackFactory(elemPendingToRemoveHighlights);
    this.highlights = {
      callback,
      timeoutId: setTimeout(callback, 2000)
    };
  }

  getAssociatedBroadcastId(blockId) {
    const editingTarget = this.vm.editingTarget;
    const block = editingTarget.blocks.getBlock(blockId);

    if (block.opcode === "event_whenbroadcastreceived") {
      return block.fields.BROADCAST_OPTION.id;
    } else {
      const input = block.inputs.BROADCAST_INPUT; // Allow shadow blocks

      return editingTarget.blocks.getBlock(input.shadow).fields.BROADCAST_OPTION.id;
    }
  }

}

/***/ }),

/***/ "./src/addons/addons/editor-devtools/userscript.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/editor-devtools/userscript.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _icon_close_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon--close.svg */ "./src/addons/addons/editor-devtools/icon--close.svg");
/* harmony import */ var _icon_close_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_icon_close_svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DevTools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DevTools.js */ "./src/addons/addons/editor-devtools/DevTools.js");
/* inserted by pull.js */


const _twGetAsset = path => {
  if (path === "/icon--close.svg") return _icon_close_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  throw new Error("Unknown asset: ".concat(path));
};


/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg,
  safeMsg: m
}) {
  const untilInEditor = () => {
    if (addon.tab.editorMode === "editor") return;
    return new Promise((resolve, reject) => {
      const handler = () => {
        if (addon.tab.editorMode === "editor") {
          resolve();
          addon.tab.removeEventListener("urlChange", handler);
        }
      };

      addon.tab.addEventListener("urlChange", handler);
    });
  };

  await untilInEditor();
  const guiDirection = addon.tab.direction;
  const helpHTML = "\n<div id=\"s3devHelpPop\" class=\"".concat(addon.tab.scratchClass("modal_modal-overlay"), "\" dir=\"").concat(guiDirection, "\">\n<div class=\"").concat(addon.tab.scratchClass("modal_modal-content"), "\">\n<div class=\"").concat(addon.tab.scratchClass("modal_header"), "\">\n  <div class=\"").concat(addon.tab.scratchClass("modal_header-item", "modal_header-item-title"), "\">").concat(m("help-title"), "</div>\n  <div class=\"").concat(addon.tab.scratchClass("modal_header-item", "modal_header-item-close"), "\">\n    <div class=\"").concat(addon.tab.scratchClass("close-button_close-button", "close-button_large", {
    others: "close-button"
  }), "\">\n\t  <img class=\"").concat(addon.tab.scratchClass("close-button_close-icon"), "\" src=\"").concat(_twGetAsset("/icon--close.svg"), "\">\n\t</div>\n  </div>\n</div>\n<div id=\"s3devHelpContent\">\n<!-- tw: we don't put this in because including \"Scratch Addons\" would probably violate BE/US policy :(\n<p>").concat(m("help-title"), " ").concat(m("help-by", {
    ndash: "&ndash;",
    url: '<a target="_blank" rel="noreferrer noopener" href="https://www.youtube.com/griffpatch">Griffpatch</a>'
  }), "</p>\n<hr />\n-->\n<h2><strong>").concat(m("code-tab-features"), "</strong></h2>\n<p dir=\"auto\"><strong>").concat(m("interactive-find-bar"), "</strong> &ndash; ").concat(m("interactive-find-bar-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("improved-tidy-up"), "</strong> &ndash; ").concat(m("improved-tidy-up-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("help-make-space"), " ").concat(m("help-new"), "</strong> &ndash; ").concat(m("help-make-space-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("copy-to-clipboard"), "</strong> &ndash; ").concat(m("copy-to-clipboard-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("paste-from-clipboard"), "</strong> &ndash; ").concat(m("paste-from-clipboard-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("swap-variable"), "</strong> &ndash; ").concat(m("swap-variable-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("middleclick"), "</strong> &ndash; ").concat(m("middleclick-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("ctrl-lr"), "</strong> &ndash; ").concat(m("ctrl-lr-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("ctrl-space"), "</strong> &ndash; ").concat(m("ctrl-space-desc"), "</p>\n<hr />\n<h2><strong>").concat(m("costume-tab-features"), "</strong></h2>\n<p dir=\"auto\"><strong>").concat(m("find-bar"), "</strong> &ndash; ").concat(m("find-bar-costume-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("ctrl-lr"), "</strong> &ndash; ").concat(m("ctrl-lr-costume-desc"), "</p>\n<p dir=\"auto\"><strong>").concat(m("send-top-bottom"), "</strong> &ndash; ").concat(m("send-top-bottom-desc"), "</p>\n<hr />\n<p>").concat(m("youtube"), " -&nbsp;<a target=\"_blank\" href=\"https://www.youtube.com/griffpatch\" rel=\"noopener noreferrer\">https://www.youtube.com/user/griffpatch</a></p>\n</div>\n</div>\n</div>\n");
  const devTools = new _DevTools_js__WEBPACK_IMPORTED_MODULE_1__["default"](addon, msg, m, helpHTML);
  devTools.init();
});

/***/ }),

/***/ "./src/addons/addons/editor-searchable-dropdowns/userscript.js":
/*!*********************************************************************!*\
  !*** ./src/addons/addons/editor-searchable-dropdowns/userscript.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  // The hierarchy is:
  // blocklyDropDownDiv (position, background color, etc.) -> blocklyDropDownContent (scrollbar) -> blocklyDropdownMenu (items)
  // The capitalization of dropdown is inconsistent in blockly too.
  let blocklyDropDownDiv = null;
  let blocklyDropDownContent = null;
  let blocklyDropdownMenu = null;

  function createSearchBar(node) {
    blocklyDropdownMenu = node;

    blocklyDropdownMenu.focus = () => {}; // no-op focus() so it can't steal it from the search bar
    // Lock the width of the dropdown before adding the search bar, as sometimes adding the searchbar changes the width.


    blocklyDropDownContent.style.width = getComputedStyle(blocklyDropDownContent).width;
    const searchBar = document.createElement("input");
    addon.tab.displayNoneWhileDisabled(searchBar);
    searchBar.type = "text";
    searchBar.addEventListener("input", handleInputEvent);
    searchBar.addEventListener("keydown", handleKeyDownEvent);
    searchBar.classList.add("u-dropdown-searchbar");
    blocklyDropdownMenu.insertBefore(searchBar, blocklyDropdownMenu.firstChild); // Lock the height of the dropdown after adding the search bar.

    blocklyDropDownContent.style.height = getComputedStyle(blocklyDropDownContent).height; // Compensate for the scroll bar sometimes making the interface taller by pushing the whole dropdown up.

    const hasScrollBar = blocklyDropDownContent.scrollHeight > blocklyDropDownContent.clientHeight;

    if (!hasScrollBar) {
      const blocklyDropDownArrow = blocklyDropDownDiv.querySelector(".blocklyDropDownArrow");

      if (blocklyDropDownArrow.classList.contains("arrowBottom")) {
        const searchBarHeight = searchBar.offsetHeight;
        blocklyDropDownDiv.style.transform += " translateY(-".concat(searchBarHeight, "px)");
        blocklyDropDownArrow.style.transform = "translateY(".concat(searchBarHeight, "px) ").concat(blocklyDropDownArrow.style.transform);
      }
    }

    searchBar.focus();
  }

  function cleanup() {
    blocklyDropdownMenu = null; // Reset all the things we changed about the dropdown menu.
    // This matters because there's other types of dropdowns such as angle selectors where a search bar doesn't make sense.

    blocklyDropDownContent.style.width = "";
    blocklyDropDownContent.style.height = "";
  }

  function closeDropDown() {
    document.querySelector(".blocklyToolboxDiv").dispatchEvent(new MouseEvent("mousedown"));
  }

  function selectItem(item, click) {
    // You can't just use click() or focus() because Blockly uses mousedown and mouseup handlers, not click handlers.
    item.dispatchEvent(new MouseEvent("mousedown", {
      relatedTarget: item,
      bubbles: true
    }));

    if (click) {
      item.dispatchEvent(new MouseEvent("mouseup", {
        relatedTarget: item,
        bubbles: true
      }));
    } // Scroll the item into view if it is offscreen.


    const itemTop = item.offsetTop;
    const itemEnd = itemTop + item.offsetHeight;
    const scrollTop = blocklyDropDownContent.scrollTop;
    const scrollHeight = blocklyDropDownContent.offsetHeight;
    const scrollEnd = scrollTop + scrollHeight;

    if (scrollTop > itemTop) {
      blocklyDropDownContent.scrollTop = itemTop;
    } else if (itemEnd > scrollEnd) {
      blocklyDropDownContent.scrollTop = itemEnd - scrollHeight;
    }
  }

  function handleInputEvent(event) {
    const value = event.target.value.toLowerCase();

    for (const item of getItems()) {
      const text = item.textContent.toLowerCase();
      const hidden = !text.includes(value);
      item.hidden = hidden;
    }
  } // This returns the Blockly block that is currently selected, or null.


  function getSelectedBlock() {
    const selected = document.querySelector(".blocklySelected");

    if (!selected) {
      return null;
    }

    const block = Blockly.getMainWorkspace().getBlockById(selected.dataset.id);
    return block;
  }

  function handleKeyDownEvent(event) {
    if (event.key === "Enter") {
      // Reimplement enter to select item to account for hidden items and default to the top item.
      event.stopPropagation();
      event.preventDefault();
      const selectedItem = blocklyDropdownMenu.querySelector(".goog-menuitem-highlight");

      if (selectedItem && !selectedItem.hidden) {
        selectItem(selectedItem, true);
        return;
      }

      const selectedBlock = getSelectedBlock();
      const items = getItems();

      if (event.target.value === "" && selectedBlock) {
        if (selectedBlock.type === "event_broadcast" || selectedBlock.type === "event_broadcastandwait" || selectedBlock.type === "event_whenbroadcastreceived") {
          // The top item of these dropdowns is always "New message"
          // When pressing enter on an empty search bar, we close the dropdown instead of making a new broadcast.
          closeDropDown();
          return;
        }
      }

      for (const item of items) {
        if (!item.hidden) {
          selectItem(item, true);
          break;
        }
      } // If there is no top value, just leave the dropdown open.

    } else if (event.key === "Escape") {
      closeDropDown();
    } else if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      // Reimplement keyboard navigation to account for hidden items.
      event.preventDefault();
      event.stopPropagation();
      const items = getItems().filter(item => !item.hidden);

      if (items.length === 0) {
        return;
      }

      let selectedIndex = -1;

      for (let i = 0; i < items.length; i++) {
        if (items[i].classList.contains("goog-menuitem-highlight")) {
          selectedIndex = i;
          break;
        }
      }

      const lastIndex = items.length - 1;
      let newIndex = 0;

      if (event.key === "ArrowDown") {
        if (selectedIndex === -1 || selectedIndex === lastIndex) {
          newIndex = 0;
        } else {
          newIndex = selectedIndex + 1;
        }
      } else {
        if (selectedIndex === -1 || selectedIndex === 0) {
          newIndex = lastIndex;
        } else {
          newIndex = selectedIndex - 1;
        }
      }

      selectItem(items[newIndex], false);
    }
  }

  function getItems() {
    if (blocklyDropdownMenu) {
      return Array.from(blocklyDropdownMenu.children).filter(child => child.tagName !== "INPUT");
    }

    return [];
  }

  function findBlocklyDropDownDiv() {
    return addon.tab.waitForElement(".blocklyDropDownDiv", {
      reduxCondition: state => state.scratchGui.editorTab.activeTabIndex === 0 && !state.scratchGui.mode.isPlayerOnly
    });
  }

  blocklyDropDownDiv = await findBlocklyDropDownDiv();
  blocklyDropDownContent = blocklyDropDownDiv.querySelector(".blocklyDropDownContent");
  const observer = new MutationObserver(mutationList => {
    for (const mutation of mutationList) {
      if (mutation.type === "childList") {
        // Look for a dropdown being created.
        for (const node of mutation.addedNodes) {
          if (node.classList && node.classList.contains("blocklyDropdownMenu")) {
            createSearchBar(node);
            break;
          }
        } // Look for a dropdown being removed.


        for (const node of mutation.removedNodes) {
          if (node.classList && node.classList.contains("blocklyDropdownMenu")) {
            cleanup();
            break;
          }
        }
      }
    }
  });
  observer.observe(blocklyDropDownContent, {
    childList: true
  });
});

/***/ }),

/***/ "./src/addons/addons/editor-sounds/userscript.js":
/*!*******************************************************!*\
  !*** ./src/addons/addons/editor-sounds/userscript.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  const ScratchBlocks = await addon.tab.traps.getBlockly();
  const workspace = Blockly.getMainWorkspace(); // Add sounds to the current workspace

  const pathToMedia = workspace.options.pathToMedia;
  ScratchBlocks.inject.loadSounds_(pathToMedia, workspace); // Add sounds to all future workspaces

  const originalInit = ScratchBlocks.init_;

  ScratchBlocks.init_ = function (...args) {
    const wksp = args[0];
    wksp.options.hasSounds = true;
    return originalInit.call(this, ...args);
  };
});

/***/ }),

/***/ "./src/addons/addons/editor-stage-left/fix-share-the-love.js":
/*!*******************************************************************!*\
  !*** ./src/addons/addons/editor-stage-left/fix-share-the-love.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  await addon.tab.traps.getBlockly();
  window.dispatchEvent(new Event("resize"));
  let interval, injected;
  addon.self.addEventListener("disabled", () => {
    clearInterval(interval);
    Blockly.getMainWorkspace().recordCachedAreas();
  });
  addon.self.addEventListener("reenabled", () => {
    if (!injected) tryInjecting();
    Blockly.getMainWorkspace().recordCachedAreas();
  });

  const inject = workspace => {
    injected = true;
    const originalGetClientRect = workspace.toolbox_.getClientRect;

    workspace.toolbox_.getClientRect = function () {
      // we are trying to undo the effect of BIG_NUM in https://github.com/LLK/scratch-blocks/blob/ab26fa2960643fa38fbc7b91ca2956be66055070/core/flyout_vertical.js#L739
      const rect = originalGetClientRect.call(this);
      if (!rect || addon.self.disabled) return rect;
      if (rect.left > 0) return rect;
      rect.left += 1000000000;
      rect.width -= 1000000000;
      return rect;
    };
  };

  function tryInjecting() {
    if (addon.tab.editorMode === "editor") {
      interval = setInterval(() => {
        if (Blockly.getMainWorkspace()) {
          inject(Blockly.getMainWorkspace());
          clearInterval(interval);
        }
      }, 100);
    }

    addon.tab.addEventListener("urlChange", () => {
      if (addon.tab.editorMode === "editor") {
        // Inject even if addon is disabled, will pollute but not change function return value
        inject(Blockly.getMainWorkspace());
      }
    });
  }

  tryInjecting();
});

/***/ }),

/***/ "./src/addons/addons/editor-theme3/theme3.js":
/*!***************************************************!*\
  !*** ./src/addons/addons/editor-theme3/theme3.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libraries_common_cs_text_color_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libraries/common/cs/text-color.esm.js */ "./src/addons/libraries/common/cs/text-color.esm.js");


function updateSettings(addon, newStyle) {
  var stylesheet = "";
  const textMode = addon.settings.get("text");

  if (textMode === "black") {
    stylesheet += "\n      .blocklyText {\n        fill: #575e75;\n      }\n      .blocklyDropdownText {\n        fill: #575e75 !important;\n      }\n      .blocklyDropDownDiv .goog-menuitem,\n      #s3devIDD > li {\n        color: #575e75;\n      }";
  }

  var categories = {
    motion: {
      color: "#4C97FF",
      tertiaryColor: "#3373CC"
    },
    looks: {
      color: "#9966FF",
      tertiaryColor: "#774DCB"
    },
    sounds: {
      color: "#CF63CF",
      tertiaryColor: "#BD42BD",
      alt: "sound"
    },
    events: {
      color: "#DE9E2E",
      tertiaryColor: "#CC9900"
    },
    control: {
      color: "#FFBF00",
      tertiaryColor: "#CF8B17"
    },
    sensing: {
      color: "#5CB1D6",
      tertiaryColor: "#2E8EB8"
    },
    operators: {
      color: "#59C059",
      tertiaryColor: "#389438"
    },
    data: {
      color: "#FF8C1A",
      tertiaryColor: "#DB6E00",
      alt: "variables"
    },
    "data-lists": {
      color: "#FF661A",
      tertiaryColor: "#E64D00",
      alt: "lists",
      var: "dataLists"
    },
    custom: {
      color: "#FF6680",
      tertiaryColor: "#FF6355",
      alt: "myBlocks"
    },
    Pen: {
      // For historical reasons, this is called "Pen".
      color: "#0FBD8C",
      tertiaryColor: "#0B8E69",
      alt: "pen"
    },
    TurboWarp: {
      color: "#ff4c4c",
      tertiaryColor: "#e64444",
      // TODO fix
      alt: "tw",
      var: "tw"
    }
  };

  for (var prop of Object.keys(categories)) {
    var settingName = categories[prop].var ? categories[prop].var : prop;

    if (textMode === "white" || textMode === "black") {
      stylesheet += "g[data-category=\"".concat(prop, "\"] > path.blocklyBlockBackground {\n        fill: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      .scratchCategoryId-").concat(categories[prop].alt ? categories[prop].alt : prop, " > .scratchCategoryItemBubble {\n        background-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n      }\n      .blocklyDropDownDiv[data-category=\"").concat(prop, "\"] {\n        background-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n        border-color: #0003 !important;\n      }\n      .blocklyBubbleCanvas [stroke=\"").concat(categories[prop].tertiaryColor, "\"] {\n        stroke: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      #s3devIDD > li.").concat(prop, " {\n        background-color: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      .console-variable[data-category=\"").concat(prop, "\"] {\n        background-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n      }\n      ");

      if (prop === "custom") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#FF6680\"] {\n          fill: var(--editorTheme3-".concat(prop, "Color);\n        }");
      }

      if (prop === "sensing") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#5CB1D6\"] {\n          fill: var(--editorTheme3-".concat(prop, "Color);\n        }");
      }

      if (prop === "events") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#FFBF00\"] {\n          fill: var(--editorTheme3-".concat(prop, "Color);\n        }\n        .blocklyDropDownDiv[style*=\"rgb(255, 191, 0)\"] {\n          background-color: var(--editorTheme3-").concat(prop, "Color) !important;\n          border-color: #0003 !important;\n        }");
      }

      if (prop === "Pen") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#0FBD8C\"] {\n          fill: var(--editorTheme3-".concat(prop, "Color);\n        }\n        .blocklyDropDownDiv[style*=\"rgb(15, 189, 140)\"] {\n          background-color: var(--editorTheme3-").concat(prop, "Color) !important;\n          border-color: #0003 !important;\n        }");
      }
    } else {
      let background = {
        colorOnWhite: "#fff",
        colorOnBlack: "#282828"
      }[textMode];
      let inputShadow = {
        colorOnWhite: "#00000026",
        colorOnBlack: "#fff3"
      }[textMode];
      let secondary = Object(_libraries_common_cs_text_color_esm_js__WEBPACK_IMPORTED_MODULE_0__["multiply"])(addon.settings.get((prop === "TurboWarp" ? "tw" : prop) + "-color"), {
        a: 0.15
      });
      stylesheet += "g[data-category=\"".concat(prop, "\"] > path.blocklyBlockBackground,\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"dropdown\"] > rect,\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"variable\"] > rect {\n        fill: ").concat(background, ";\n        stroke: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      g[data-category=\"").concat(prop, "\"] > .blocklyText {\n        fill: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"dropdown\"] > .blocklyDropdownText,\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"variable\"] > .blocklyDropdownText,\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"dropdown\"] > g > .blocklyDropdownText {\n        fill: var(--editorTheme3-").concat(settingName, "Color) !important;\n      }\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"dropdown\"] > path,\n      g[data-category=\"").concat(prop, "\"] > g[data-argument-type=\"variable\"] > path,\n      g[data-category=\"").concat(prop, "\"] > path[data-argument-type=\"boolean\"] {\n        fill: ").concat(secondary, ";\n        stroke: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      .scratchCategoryId-").concat(categories[prop].alt ? categories[prop].alt : prop, " > .scratchCategoryItemBubble {\n        background-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n      }\n      .blocklyDropDownDiv[data-category=\"").concat(prop, "\"] {\n        background-color: ").concat(background, " !important;\n        border-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n      }\n      .blocklyDropDownDiv[data-category=\"").concat(prop, "\"] .goog-menuitem {\n        color: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      .blocklyBubbleCanvas [stroke=\"").concat(categories[prop].tertiaryColor, "\"],\n      g[data-category=").concat(prop, "] > g[data-argument-type*=\"text\"] > path,\n      g[data-category=").concat(prop, "] > g > line  {\n        stroke: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      .blocklyWidgetDiv.fieldTextInput[style*=\"box-shadow\"] {\n        box-shadow: 0 0 0 4px ").concat(inputShadow, " !important;\n      }\n      #s3devIDD > li.").concat(prop, " {\n        background-color: ").concat(background, ";\n        color: var(--editorTheme3-").concat(settingName, "Color);\n      }\n      #s3devIDD > li.").concat(prop, ":not(.boolean) {\n        border: 1px solid var(--editorTheme3-").concat(settingName, "Color);\n      }");

      if (prop === "custom") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#FF6680\"] {\n          fill: ".concat(background, ";\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#FF6680\"] ~ .blocklyText,\n        g[data-shapes=\"c-block c-1 hat\"] > g[data-shapes=\"stack\"]:not(.blocklyDraggable) > .blocklyText,\n        .blocklyEditableText > rect[fill=\"#FF3355\"] ~ .blocklyText {\n          fill: var(--editorTheme3-").concat(prop, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#FF6680\"] ~ [data-argument-type=\"text\"] > path {\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        g[data-shapes=\"c-block c-1 hat\"] > g[data-shapes=\"stack\"]:not(.blocklyDraggable) > path,\n        path[data-argument-type=\"boolean\"][fill=\"#FF3355\"] {\n          fill: ").concat(secondary, ";\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        .blocklyEditableText > rect[fill=\"#FF3355\"] {\n          fill: ").concat(secondary, ";\n        }");
      }

      if (prop === "sensing") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#5CB1D6\"],\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#5CB1D6\"],\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#2E8EB8\"] {\n          fill: ".concat(background, ";\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        g[data-argument-type=\"dropdown\"] > path[fill=\"#47A8D1\"],\n        g[data-argument-type=\"dropdown\"] > path[fill=\"#2E8EB8\"] {\n          fill: ").concat(secondary, ";\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#5CB1D6\"] ~ .blocklyText {\n          fill: var(--editorTheme3-").concat(prop, "Color);\n        }\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#5CB1D6\"] ~ .blocklyText,\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#2E8EB8\"] ~ .blocklyText,\n        g[data-argument-type=\"dropdown\"] > path[fill=\"#47A8D1\"] ~ * > .blocklyText,\n        g[data-argument-type=\"dropdown\"] > path[fill=\"#2E8EB8\"] ~ * > .blocklyText {\n          fill: var(--editorTheme3-").concat(prop, "Color) !important;\n        }\n        .blocklyDropDownDiv[style*=\"rgb(92, 177, 214)\"] {\n          background-color: ").concat(background, " !important;\n          border-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n        }\n        .blocklyDropDownDiv[style*=\"rgb(92, 177, 214)\"] .goog-menuitem {\n          color: var(--editorTheme3-").concat(settingName, "Color);\n        }");
      }

      if (prop === "events") {
        stylesheet += "path.blocklyBlockBackground[fill=\"#FFBF00\"],\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#FFBF00\"],\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#CC9900\"] {\n          fill: ".concat(background, ";\n          stroke: var(--editorTheme3-").concat(settingName, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#FFBF00\"] ~ .blocklyText {\n          fill: var(--editorTheme3-").concat(prop, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#FFBF00\"] ~ g[data-argument-type=\"variable\"] > g > .blocklyDropdownText {\n          fill: var(--editorTheme3-").concat(prop, "Color) !important;\n        }\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#FFBF00\"] ~ .blocklyText,\n        g[data-argument-type=\"dropdown\"] > rect[fill=\"#CC9900\"] ~ .blocklyText {\n          fill: var(--editorTheme3-").concat(prop, "Color) !important;\n        }\n        .blocklyDropDownDiv[style*=\"rgb(255, 191, 0)\"] {\n          background-color: ").concat(background, " !important;\n          border-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n        }\n        .blocklyDropDownDiv[style*=\"rgb(255, 191, 0)\"] .goog-menuitem {\n          color: var(--editorTheme3-").concat(settingName, "Color);\n        }");
      }

      if (prop === "Pen") {
        stylesheet += "g[data-category] /* specificity */ > path.blocklyBlockBackground[fill=\"#0FBD8C\"] {\n          fill: ".concat(background, ";\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#0FBD8C\"] ~ .blocklyText {\n          fill: var(--editorTheme3-").concat(prop, "Color);\n        }\n        path.blocklyBlockBackground[fill=\"#0FBD8C\"] ~ g[data-argument-type=\"dropdown\"] > g > .blocklyDropdownText {\n          fill: var(--editorTheme3-").concat(prop, "Color) !important;\n        }\n        g[data-argument-type=\"dropdown\"] > path[fill=\"#0DA57A\"],\n        g[data-argument-type=\"dropdown\"] > path[fill=\"#0B8E69\"] {\n          fill: ").concat(secondary, ";\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        .blocklyDropDownDiv[style*=\"rgb(15, 189, 140)\"] {\n          background-color: ").concat(background, " !important;\n          border-color: var(--editorTheme3-").concat(settingName, "Color) !important;\n        }\n        path.blocklyBlockBackground[fill=\"#0FBD8C\"] ~ [data-argument-type=\"text\"] > path,\n        path.blocklyBlockBackground[fill=\"#0FBD8C\"] ~ g > line  {\n          stroke: var(--editorTheme3-").concat(prop, "Color);\n        }\n        #s3devIDD > li.extension {\n          background-color: ").concat(background, ";\n          color: var(--editorTheme3-").concat(settingName, "Color);\n        }\n        #s3devIDD > li.extension:not(.boolean) {\n          border: 1px solid var(--editorTheme3-").concat(settingName, "Color);\n        }");
      }
    }
  }

  document.documentElement.style.setProperty("--editorTheme3-inputColor-text", Object(_libraries_common_cs_text_color_esm_js__WEBPACK_IMPORTED_MODULE_0__["textColor"])(addon.settings.get("input-color")));
  newStyle.textContent = stylesheet;
}

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  const otherStyle = document.querySelector("[data-addon-id='".concat(addon.self.id, "']"));
  const newStyle = document.createElement("style");
  updateSettings(addon, newStyle);
  addon.settings.addEventListener("change", () => {
    updateSettings(addon, newStyle);
  });
  newStyle.className = "scratch-addons-style";
  newStyle.setAttribute("data-addon-id", addon.self.id);
  newStyle.setAttribute("data-addon-index", otherStyle.getAttribute("data-addon-index"));
  otherStyle.parentElement.insertBefore(newStyle, otherStyle.nextSibling); // Look for reenable event to enable the style. cs.js cannot handle an appended style.

  addon.self.addEventListener("reenabled", () => newStyle.disabled = false);
});

/***/ }),

/***/ "./src/addons/addons/folders/folder.svg":
/*!**********************************************!*\
  !*** ./src/addons/addons/folders/folder.svg ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/b1943d453bad1292a0fdc148c85094bf.svg";

/***/ }),

/***/ "./src/addons/addons/folders/userscript.js":
/*!*************************************************!*\
  !*** ./src/addons/addons/folders/userscript.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _folder_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./folder.svg */ "./src/addons/addons/folders/folder.svg");
/* harmony import */ var _folder_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_folder_svg__WEBPACK_IMPORTED_MODULE_0__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* inserted by pull.js */


const _twGetAsset = path => {
  if (path === "/folder.svg") return _folder_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  throw new Error("Unknown asset: ".concat(path));
};

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  // The basic premise of how this addon works is relative simple.
  // scratch-gui renders the sprite selectors and asset selectors in a hierarchy like this:
  // <SelectorHOC>
  //   <SpriteSelectorItem />
  //   <SpriteSelectorItem />
  //   <SpriteSelectorItem />
  //   <SpriteSelectorItem />
  //   ...
  // </SelectorHOC>
  // It's obviously more complicated than that, but there are two important parts:
  // SelectorHOC - We override this to change which items are displayed
  // SpriteSelectorItem - We override this to change how items are displayed.
  //    Folders are just items rendered differently
  // These two components communicate through the `name` property of the items.
  // We touch some things on the VM to make dragging items work properly.
  const REACT_INTERNAL_PREFIX = "__reactInternalInstance$";
  const SVG_NS = "http://www.w3.org/2000/svg";
  const TYPE_SPRITES = 1;
  const TYPE_ASSETS = 2; // We run too early, will be set later

  let vm;
  let reactInternalKey;
  let currentSpriteFolder;
  let currentAssetFolder;
  let currentSpriteItems;
  let currentAssetItems;
  const DIVIDER = "//";
  /**
   * getFolderFromName("B") === null
   * getFolderFromName("A//b") === "A"
   */

  const getFolderFromName = name => {
    const idx = name.indexOf(DIVIDER);

    if (idx === -1 || idx === 0) {
      return null;
    }

    return name.substr(0, idx);
  };
  /**
   * getNameWithoutFolder("B") === "B"
   * getNameWithoutFolder("A//b") === "b"
   */


  const getNameWithoutFolder = name => {
    const idx = name.indexOf(DIVIDER);

    if (idx === -1 || idx === 0) {
      return name;
    }

    return name.substr(idx + DIVIDER.length);
  };
  /**
   * setFolderOfName("B", "y") === "y//B"
   * setFolderOfName("c//B", "y") === "y//B"
   * setFolderOfName("B", null) === "B"
   * setFolderOfName("c//B", null) === "B"
   */


  const setFolderOfName = (name, folder) => {
    const basename = getNameWithoutFolder(name);

    if (folder) {
      return "".concat(folder).concat(DIVIDER).concat(basename);
    }

    return basename;
  };

  const isValidFolderName = name => {
    return !name.includes(DIVIDER) && !name.endsWith("/");
  };

  const RESERVED_NAMES = ["_mouse_", "_stage_", "_edge_", "_myself_", "_random_"];

  const ensureNotReserved = name => {
    if (name === "") return "2";
    if (RESERVED_NAMES.includes(name)) return "".concat(name, "2");
    return name;
  };

  const untilInEditor = () => {
    if (addon.tab.editorMode === "editor") return;
    return new Promise((resolve, reject) => {
      const handler = () => {
        if (addon.tab.editorMode === "editor") {
          resolve();
          addon.tab.removeEventListener("urlChange", handler);
        }
      };

      addon.tab.addEventListener("urlChange", handler);
    });
  };

  const getSortableHOCFromElement = el => {
    const nearestSpriteSelector = el.closest("[class*='sprite-selector_sprite-selector']");

    if (nearestSpriteSelector) {
      return nearestSpriteSelector[reactInternalKey].child.sibling.child.stateNode;
    }

    const nearestAssetPanelWrapper = el.closest('[class*="asset-panel_wrapper"]');

    if (nearestAssetPanelWrapper) {
      return nearestAssetPanelWrapper[reactInternalKey].child.child.stateNode;
    }

    throw new Error("cannot find SortableHOC");
  };

  const getBackpackFromElement = el => {
    const gui = el.closest('[class*="gui_editor-wrapper"]');
    if (!gui) throw new Error("cannot find Backpack");
    return gui[reactInternalKey].child.sibling.child.child.stateNode;
  };

  const clamp = (n, min, max) => {
    return Math.min(Math.max(n, min), max);
  };
  /**
   * @typedef {Object} ItemData
   * @property {string} realName
   * @property {number} realIndex
   * @property {string} inFolder
   * @property {string} folder
   * @property {boolean} folderOpen
   */

  /**
   * @returns {ItemData|null}
   */


  const getItemData = item => {
    if (item && item.name && typeof item.name === "object") {
      return item.name;
    }

    return null;
  };

  const openFolderAsset = {
    assetId: "&__sa_folders_folder",

    encodeDataURI() {
      // Doesn't actually need to be a data: URI
      return _twGetAsset("/folder.svg");
    }

  }; // https://github.com/LLK/scratch-gui/blob/develop/src/components/asset-panel/icon--sound.svg

  const imageIconSource = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"100px\" height=\"100px\" viewBox=\"0 0 20 20\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <g id=\"Sound\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <path d=\"M12.4785058,12.6666667 C12.3144947,12.6666667 12.1458852,12.6272044 11.9926038,12.5440517 C11.537358,12.2960031 11.3856094,11.7562156 11.6553847,11.3376335 C12.1688774,10.5371131 12.1688774,9.54491867 11.6553847,8.74580756 C11.3856094,8.32581618 11.537358,7.78602861 11.9926038,7.53798001 C12.452448,7.29275014 13.0379829,7.43086811 13.3046926,7.84804076 C14.1737981,9.20103311 14.1737981,10.8809986 13.3046926,12.233991 C13.1268862,12.5130457 12.806528,12.6666667 12.4785058,12.6666667 Z M15.3806784,13.8333333 C15.2408902,13.8333333 15.0958763,13.796281 14.9665396,13.7182064 C14.5785295,13.485306 14.4491928,12.9784829 14.6791247,12.5854634 C15.5949331,11.0160321 15.5949331,9.065491 14.6791247,7.49738299 C14.4491928,7.10436352 14.5785295,6.59621712 14.9665396,6.36331669 C15.3558562,6.13438616 15.8549129,6.26274605 16.0848448,6.65444223 C17.3050517,8.74260632 17.3050517,11.3389168 16.0848448,13.4270809 C15.9319924,13.6890939 15.6602547,13.8333333 15.3806784,13.8333333 Z M10.3043478,5.62501557 L10.3043478,13.873675 C10.3043478,14.850934 9.10969849,15.3625101 8.36478311,14.7038052 L6.7566013,13.2797607 C6.18712394,12.7762834 5.44499329,12.4968737 4.67362297,12.4968737 L4.3923652,12.4968737 C3.62377961,12.4968737 3,11.8935108 3,11.1470686 L3,8.36646989 C3,7.62137743 3.62377961,7.01666471 4.3923652,7.01666471 L4.65830695,7.01666471 C5.42967727,7.01666471 6.17180792,6.73725504 6.74128529,6.23377771 L8.36478311,4.79623519 C9.10969849,4.13753026 10.3043478,4.64910643 10.3043478,5.62501557 Z\" id=\"Combined-Shape\" fill=\"#575E75\"></path>\n    </g>\n</svg>";
  const soundIconHref = "data:image/svg+xml;base64,".concat(btoa(imageIconSource));
  let folderColorStylesheet = null;
  const folderColors = Object.create(null);

  const getFolderColorClass = folderName => {
    const mulberry32 = a => {
      // https://stackoverflow.com/a/47593316
      return function () {
        var t = a += 0x6d2b79f5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    };

    const hashCode = str => {
      // Based on Java's String.hashCode
      // https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/String.java#l1452
      let hash = 0;

      for (let i = 0; i < str.length; i++) {
        hash = 31 * hash + str.charCodeAt(i);
        hash = hash | 0;
      }

      return hash;
    };

    const random = str => {
      const seed = hashCode(str);
      const rng = mulberry32(seed); // Run RNG a few times to get more random numbers, otherwise similar seeds tend to give somewhat similar results

      rng();
      rng();
      rng();
      rng();
      return rng();
    };

    if (!folderColors[folderName]) {
      if (!folderColorStylesheet) {
        folderColorStylesheet = document.createElement("style");
        document.head.appendChild(folderColorStylesheet);
      }

      const hue = random(folderName) * 360;
      const color = "hsla(".concat(hue, "deg, 100%, 85%, 0.5)");
      const id = Object.keys(folderColors).length;
      const className = "sa-folders-color-".concat(id);
      folderColors[folderName] = className;
      folderColorStylesheet.textContent += ".".concat(className, "{background-color:").concat(color, " !important;}");
      folderColorStylesheet.textContent += ".".concat(className, "[class*=\"sprite-selector_raised\"]:not([class*=\"sa-folders-folder\"]){background-color:hsla(").concat(hue, "deg, 100%, 77%, 1) !important;}");
    }

    return folderColors[folderName];
  };

  const fixOrderOfItemsInFolders = items => {
    const folders = Object.create(null);
    const result = [];

    for (const item of items) {
      const name = item.getName ? item.getName() : item.name;
      const folder = getFolderFromName(name);

      if (typeof folder === "string") {
        if (!folders[folder]) {
          folders[folder] = [];
          result.push(folders[folder]);
        }

        folders[folder].push(item);
      } else {
        result.push(item);
      }
    }

    const flatResult = result.flat();

    for (let i = 0; i < items.length; i++) {
      if (result[i] !== items[i]) {
        return {
          items: flatResult,
          changed: true
        };
      }
    }

    return {
      items: flatResult,
      changed: false
    };
  };

  const fixTargetOrder = () => {
    const {
      items,
      changed
    } = fixOrderOfItemsInFolders(vm.runtime.targets);

    if (changed) {
      vm.runtime.targets = items;
      vm.emitTargetsUpdate();
    }
  };

  const fixCostumeOrder = (target = vm.editingTarget) => {
    const {
      items,
      changed
    } = fixOrderOfItemsInFolders(target.sprite.costumes);

    if (changed) {
      target.sprite.costumes = items;
      vm.emitTargetsUpdate();
    }
  };

  const fixSoundOrder = (target = vm.editingTarget) => {
    const {
      items,
      changed
    } = fixOrderOfItemsInFolders(target.sprite.sounds);

    if (changed) {
      target.sprite.sounds = items;
      vm.emitTargetsUpdate();
    }
  };

  const verifySortableHOC = sortableHOCInstance => {
    const SortableHOC = sortableHOCInstance.constructor;
    if (Array.isArray(sortableHOCInstance.props.items) && (typeof sortableHOCInstance.props.selectedId === "string" || typeof sortableHOCInstance.props.selectedItemIndex === "number") && typeof sortableHOCInstance.containerBox !== "undefined" && typeof SortableHOC.prototype.componentDidMount === "undefined" && typeof SortableHOC.prototype.componentDidUpdate === "undefined" && typeof SortableHOC.prototype.handleAddSortable === "function" && typeof SortableHOC.prototype.handleRemoveSortable === "function" && typeof SortableHOC.prototype.setRef === "function") return;
    throw new Error("Can not comprehend SortableHOC");
  };

  const verifySpriteSelectorItem = spriteSelectorItemInstance => {
    const SpriteSelectorItem = spriteSelectorItemInstance.constructor;
    if (typeof spriteSelectorItemInstance.props.asset === "object" && typeof spriteSelectorItemInstance.props.name === "string" && typeof spriteSelectorItemInstance.props.dragType === "string" && typeof SpriteSelectorItem.prototype.handleClick === "function" && typeof SpriteSelectorItem.prototype.setRef === "function" && typeof SpriteSelectorItem.prototype.handleDrag === "function" && typeof SpriteSelectorItem.prototype.handleDragEnd === "function" && typeof SpriteSelectorItem.prototype.handleDelete === "function" && typeof SpriteSelectorItem.prototype.handleDuplicate === "function" && typeof SpriteSelectorItem.prototype.handleExport === "function") return;
    throw new Error("Can not comprehend SpriteSelectorItem");
  };

  const verifyVM = vm => {
    const target = vm.runtime.targets[0];
    if (typeof vm.installTargets === "function" && typeof vm.reorderTarget === "function" && typeof target.reorderCostume === "function" && typeof target.reorderSound === "function" && typeof target.addCostume === "function" && typeof target.addSound === "function") return;
    throw new Error("Can not comprehend VM");
  };

  const verifyBackpack = backpackInstance => {
    const Backpack = backpackInstance.constructor;

    if (typeof Backpack.prototype.handleDrop === "function" && typeof Backpack.prototype.componentDidUpdate === "undefined") {
      return;
    }

    throw new Error("Can not comprehend Backpack");
  };

  class Cache {
    constructor() {
      this.map = new Map();
      this.used = [];
    }

    has(id) {
      return this.map.has(id);
    }

    get(id) {
      this.used.push(id);
      return this.map.get(id);
    }

    set(id, value) {
      this.used.push(id);
      this.map.set(id, value);
    }

    start() {
      this.used = [];
    }

    end() {
      for (const id of Array.from(this.map.keys())) {
        if (!this.used.includes(id)) {
          this.map.delete(id);
        }
      }
    }

    clear() {
      this.start();
      this.map.clear();
    }

  }

  const patchSortableHOC = (SortableHOC, type) => {
    // SortableHOC should be: https://github.com/LLK/scratch-gui/blob/29d9851778febe4e69fa5111bf7559160611e366/src/lib/sortable-hoc.jsx#L8
    const itemCache = new Cache();
    const folderItemCache = new Cache();
    const folderAssetCache = new Cache();
    const PREVIEW_SIZE = 80;
    const PREVIEW_POSITIONS = [// x, y
    [0, 0], [PREVIEW_SIZE / 2, 0], [0, PREVIEW_SIZE / 2], [PREVIEW_SIZE / 2, PREVIEW_SIZE / 2]];

    const createFolderPreview = items => {
      const svg = document.createElementNS(SVG_NS, "svg");
      svg.setAttribute("width", PREVIEW_SIZE);
      svg.setAttribute("height", PREVIEW_SIZE);

      for (let i = 0; i < Math.min(PREVIEW_POSITIONS.length, items.length); i++) {
        const item = items[i];
        const image = document.createElementNS(SVG_NS, "image");
        image.setAttribute("width", PREVIEW_SIZE / 2);
        image.setAttribute("height", PREVIEW_SIZE / 2);
        image.setAttribute("x", PREVIEW_POSITIONS[i][0]);
        image.setAttribute("y", PREVIEW_POSITIONS[i][1]);

        if (item.asset) {
          image.setAttribute("href", item.asset.encodeDataURI());
        } else if (item.costume && item.costume.asset) {
          image.setAttribute("href", item.costume.asset.encodeDataURI());
        } else if (item.url) {
          image.setAttribute("href", soundIconHref);
        }

        svg.appendChild(image);
      }

      return "data:image/svg+xml;," + new XMLSerializer().serializeToString(svg);
    };

    const getUniqueIdOfFolderItems = items => {
      let id = "sa_folder&&";

      for (let i = 0; i < Math.min(PREVIEW_POSITIONS.length, items.length); i++) {
        const item = items[i];

        if (item.asset) {
          id += item.asset.assetId;
        } else if (item.costume && item.costume.asset) {
          id += item.costume.asset.assetId;
        } else if (item.url) {
          id += item.url;
        }

        id += "&&";
      }

      return id;
    };

    const processItems = (openFolders, props) => {
      const processItem = item => {
        const itemId = item.name;
        let newItem;
        let itemData;

        if (itemCache.has(itemId)) {
          newItem = itemCache.get(itemId);
          itemData = newItem.name;
        } else {
          itemData = {
            toString() {
              return "_".concat(item.name);
            }

          };
          newItem = {};
          itemCache.set(itemId, newItem);
        }

        const itemFolderName = getFolderFromName(item.name);
        Object.assign(newItem, item);
        itemData.realName = item.name;
        itemData.realIndex = i;
        itemData.inFolder = itemFolderName;
        newItem.name = itemData;
        return {
          newItem,
          itemData
        };
      };

      itemCache.start();
      folderItemCache.start();
      folderAssetCache.start();
      const folderOccurrences = new Map();
      const items = [];
      const result = {
        items
      };
      let i = 0;

      while (i < props.items.length) {
        const item = props.items[i];
        const folderName = getFolderFromName(item.name);

        if (folderName === null) {
          items.push(processItem(item).newItem);

          if (type === TYPE_ASSETS) {
            const isSelected = props.selectedItemIndex === i;

            if (isSelected) {
              result.selectedItemIndex = items.length - 1;
            }
          }
        } else {
          const isOpen = openFolders.indexOf(folderName) !== -1;
          const folderItems = [];

          while (i < props.items.length) {
            const childItem = props.items[i];
            const processedItem = processItem(childItem);

            if (getFolderFromName(childItem.name) !== folderName) {
              break;
            }

            folderItems.push(processedItem.newItem);

            if (type === TYPE_ASSETS) {
              const isSelected = props.selectedItemIndex === i;

              if (isSelected) {
                if (isOpen) {
                  result.selectedItemIndex = items.length + folderItems.length;
                } else {
                  result.selectedItemIndex = -1;
                }
              }
            }

            i++;
          }

          i--;
          const occurrence = folderOccurrences.get(folderName) || 0;
          folderOccurrences.set(folderName, occurrence + 1);
          const baseUniqueId = getUniqueIdOfFolderItems(folderItems);
          const itemUniqueId = "".concat(isOpen, "&").concat(occurrence, "&").concat(folderName, "&").concat(baseUniqueId, "&");
          const reactKey = "&__".concat(occurrence, "_").concat(folderName);
          const assetUniqueId = baseUniqueId;
          let folderItem;
          let folderData;

          if (folderItemCache.has(itemUniqueId)) {
            folderItem = folderItemCache.get(itemUniqueId);
            folderData = folderItem.name;
          } else {
            folderItem = {
              // Can be used as a react key
              id: {
                toString() {
                  return reactKey;
                }

              }
            };
            folderData = {
              // Can be used as a react key
              toString() {
                return reactKey;
              }

            };
            folderItemCache.set(itemUniqueId, folderItem);
          }

          folderData.folder = folderName;
          folderData.folderOpen = isOpen;
          folderItem.items = folderItems;
          folderItem.name = folderData;
          let folderAsset;

          if (isOpen) {
            folderAsset = openFolderAsset;
          } else {
            if (folderAssetCache.has(assetUniqueId)) {
              folderAsset = folderAssetCache.get(assetUniqueId);
            } else {
              folderAsset = {
                assetId: assetUniqueId,

                encodeDataURI() {
                  return createFolderPreview(folderItems);
                }

              };
              folderAssetCache.set(assetUniqueId, folderAsset);
            }
          }

          if (type === TYPE_SPRITES) {
            if (!folderItem.costume) folderItem.costume = {};
            folderItem.costume.asset = folderAsset; // For sprite items, `id` is used as the drag payload and toString is used as a React key

            if (!folderItem.id) folderItem.id = {};
            folderItem.id.sa_folder_items = folderItems;

            folderItem.id.toString = () => reactKey;
          } else {
            folderItem.asset = folderAsset;
            if (!folderItem.dragPayload) folderItem.dragPayload = {};
            folderItem.dragPayload.sa_folder_items = folderItems;
          }

          items.push(folderItem);

          if (isOpen) {
            for (const item of folderItems) {
              items.push(item);
            }
          }
        }

        i++;
      }

      itemCache.end();
      folderItemCache.end();
      folderAssetCache.end();
      return result;
    };

    const getSelectedItem = sortable => {
      if (type === TYPE_SPRITES) {
        const selectedItem = sortable.props.items.find(i => i.id === sortable.props.selectedId);
        return selectedItem;
      } else if (type === TYPE_ASSETS) {
        const selectedItem = sortable.props.items[sortable.props.selectedItemIndex];
        return selectedItem;
      }

      return null;
    };

    SortableHOC.prototype.saInitialSetup = function () {
      itemCache.clear();
      folderItemCache.clear();
      folderAssetCache.clear();
      const folders = [];
      const selectedItem = getSelectedItem(this);

      if (selectedItem && !selectedItem.isStage) {
        const folder = getFolderFromName(selectedItem.name);
        folders.push(folder);

        if (type === TYPE_SPRITES) {
          currentSpriteFolder = folder;
        } else if (type === TYPE_ASSETS) {
          currentAssetFolder = folder;
        }
      }

      this.setState({
        folders
      });
    };

    SortableHOC.prototype.componentDidMount = function () {
      // Do part of componentDidUpdate on mount as well
      const selectedItem = getSelectedItem(this);

      if (selectedItem) {
        const folder = getFolderFromName(selectedItem.name);

        if (type === TYPE_SPRITES) {
          currentSpriteFolder = folder;
        } else if (type === TYPE_ASSETS) {
          currentAssetFolder = folder;
        }
      }

      this.saInitialSetup();
    };

    SortableHOC.prototype.componentDidUpdate = function (prevProps, prevState) {
      const selectedItem = getSelectedItem(this);

      if (selectedItem) {
        const folder = getFolderFromName(selectedItem.name);
        const currentFolder = this.state.folders.includes(folder) ? folder : null;

        if (type === TYPE_SPRITES) {
          currentSpriteFolder = currentFolder;
        } else if (type === TYPE_ASSETS) {
          currentAssetFolder = currentFolder;
        }

        let selectedItemChanged;

        if (this.props.selectedId) {
          selectedItemChanged = this.props.selectedId !== prevProps.selectedId;
        } else {
          selectedItemChanged = this.props.items[this.props.selectedItemIndex] && prevProps.items[prevProps.selectedItemIndex] && this.props.items[this.props.selectedItemIndex].name !== prevProps.items[prevProps.selectedItemIndex].name;
        }

        if (selectedItemChanged) {
          if (!selectedItem.isStage) {
            if (typeof folder === "string" && !this.state.folders.includes(folder)) {
              this.setState(prevState => ({
                folders: [...prevState.folders, folder]
              }));
            }
          }
        }
      }
    };

    const originalSortableHOCRender = SortableHOC.prototype.render;

    SortableHOC.prototype.render = function () {
      const originalProps = this.props;
      this.props = _objectSpread(_objectSpread({}, this.props), processItems(this.state && this.state.folders || [], this.props));

      if (type === TYPE_SPRITES) {
        currentSpriteItems = this.props.items;
      } else if (type === TYPE_ASSETS) {
        currentAssetItems = this.props.items;
      }

      const result = originalSortableHOCRender.call(this);
      this.props = originalProps;
      return result;
    };
  };

  const patchSpriteSelectorItem = SpriteSelectorItem => {
    // SpriteSelectorItem should be: https://github.com/LLK/scratch-gui/blob/29d9851778febe4e69fa5111bf7559160611e366/src/containers/sprite-selector-item.jsx#L16
    const closeContextMenu = () => {
      document.body.dispatchEvent(new MouseEvent("mousedown", {
        relatedTarget: document.body,
        bubbles: true
      }));
    };

    const createMenuItem = (text, callback, border) => {
      const el = document.createElement("div");
      el.className = addon.tab.scratchClass("context-menu_menu-item", border ? "context-menu_menu-item-bordered" : null, {
        others: ["react-contextmenu-item", "sa-folders-contextmenu-item"]
      });
      el.setAttribute("role", "menuitem");
      el.setAttribute("tabindex", "-1");
      el.setAttribute("aria-disabled", "false");
      el.textContent = text;
      el.addEventListener("click", e => {
        e.preventDefault();
        e.stopPropagation();
        closeContextMenu();
        callback();
      }, true);
      return el;
    };

    const getAllFolders = component => {
      const result = new Set();
      let items;

      if (component.props.dragType === "SPRITE") {
        items = currentSpriteItems;
      } else {
        items = currentAssetItems;
      }

      for (const item of items) {
        const data = getItemData(item);

        if (typeof data.folder === "string") {
          result.add(data.folder);
        }
      }

      return Array.from(result);
    };

    const addContextMenuItems = component => {
      const data = getItemData(component.props);

      if (!data) {
        return;
      }

      const menu = component.ref.querySelector("nav[role=menu]");

      if (!menu) {
        return;
      }

      const oldContainer = menu.querySelector(".sa-folders-contextmenu-container");

      if (oldContainer) {
        oldContainer.remove();
      }

      const container = document.createElement("div");
      container.className = "sa-folders-contextmenu-container";
      menu.appendChild(container);

      if (typeof data.folder === "string") {
        menu.setAttribute("sa-folders-context-type", "folder");

        const renameItems = newName => {
          const isOpen = isFolderOpen(component, data.folder);
          setFolderOpen(component, data.folder, false);

          if (isOpen && typeof newName === "string") {
            setFolderOpen(component, newName, true);
          }

          if (component.props.dragType === "SPRITE") {
            for (const target of vm.runtime.targets) {
              if (target.isOriginal) {
                if (getFolderFromName(target.getName()) === data.folder) {
                  vm.renameSprite(target.id, ensureNotReserved(setFolderOfName(target.getName(), newName)));
                }
              }
            }

            vm.emitWorkspaceUpdate();
            fixTargetOrder();
          } else if (component.props.dragType === "COSTUME") {
            for (let i = 0; i < vm.editingTarget.sprite.costumes.length; i++) {
              const costume = vm.editingTarget.sprite.costumes[i];

              if (getFolderFromName(costume.name) === data.folder) {
                vm.renameCostume(i, setFolderOfName(costume.name, newName));
              }
            }

            fixCostumeOrder();
          } else if (component.props.dragType === "SOUND") {
            for (let i = 0; i < vm.editingTarget.sprite.sounds.length; i++) {
              const sound = vm.editingTarget.sprite.sounds[i];

              if (getFolderFromName(sound.name) === data.folder) {
                vm.renameSound(i, setFolderOfName(sound.name, newName));
              }
            }

            fixSoundOrder();
          }
        };

        const renameFolder = () => {
          let newName = prompt(msg("rename-folder-prompt"), data.folder); // Prompt cancelled, do not rename

          if (newName === null) {
            return;
          }

          if (!isValidFolderName(newName)) {
            alert(msg("name-not-allowed"));
            return;
          } // Empty name will remove the folder


          if (!newName) {
            newName = null;
          }

          renameItems(newName);
        };

        const removeFolder = () => {
          renameItems(null);
        };

        container.appendChild(createMenuItem(msg("rename-folder"), renameFolder));
        container.appendChild(createMenuItem(msg("remove-folder"), removeFolder));
      } else {
        menu.setAttribute("sa-folders-context-type", "asset");

        const setFolder = folder => {
          if (component.props.dragType === "SPRITE") {
            const target = vm.runtime.getTargetById(component.props.id);
            vm.renameSprite(component.props.id, ensureNotReserved(setFolderOfName(target.getName(), folder)));
            fixTargetOrder();
            vm.emitWorkspaceUpdate();
          } else if (component.props.dragType === "COSTUME") {
            const data = getItemData(component.props);
            const index = data.realIndex;
            const asset = vm.editingTarget.sprite.costumes[index];
            vm.renameCostume(vm.editingTarget.sprite.costumes.indexOf(asset), setFolderOfName(asset.name, folder));
            fixCostumeOrder();
          } else if (component.props.dragType === "SOUND") {
            const data = getItemData(component.props);
            const index = data.realIndex;
            const asset = vm.editingTarget.sprite.sounds[index];
            vm.renameSound(vm.editingTarget.sprite.sounds.indexOf(asset), setFolderOfName(asset.name, folder));
            fixSoundOrder();
          }
        };

        const createFolder = () => {
          const name = prompt(msg("name-prompt"), getNameWithoutFolder(data.realName));

          if (name === null) {
            return;
          }

          if (!isValidFolderName(name)) {
            alert(msg("name-not-allowed"));
            return;
          }

          setFolder(name);
        };

        container.appendChild(createMenuItem(msg("create-folder"), createFolder, true));
        const currentFolder = data.inFolder;

        if (typeof currentFolder === "string") {
          container.appendChild(createMenuItem(msg("remove-from-folder"), () => setFolder(null)));
        }

        for (const folder of getAllFolders(component)) {
          if (folder !== currentFolder) {
            container.appendChild(createMenuItem(msg("add-to-folder", {
              folder
            }), () => setFolder(folder)));
          }
        }
      }
    };

    const isFolderOpen = (component, folder) => {
      const sortableHOCInstance = getSortableHOCFromElement(component.ref);
      const folders = sortableHOCInstance.state && sortableHOCInstance.state.folders || [];
      return folders.includes(folder);
    };

    const setFolderOpen = (component, folder, open) => {
      const sortableHOCInstance = getSortableHOCFromElement(component.ref);
      sortableHOCInstance.setState(prevState => {
        let folders = prevState && prevState.folders || [];
        folders = folders.filter(i => i !== folder);

        if (open) {
          return {
            folders: [...folders, folder]
          };
        }

        return {
          folders
        };
      });
    };

    for (const method of ["handleDelete", "handleDuplicate", "handleExport"]) {
      const original = SpriteSelectorItem.prototype[method];

      SpriteSelectorItem.prototype[method] = function (...args) {
        if (typeof this.props.id === "number") {
          const itemData = getItemData(this.props);

          if (itemData) {
            const originalProps = this.props;
            this.props = _objectSpread(_objectSpread({}, originalProps), {}, {
              id: itemData.realIndex
            });
            const ret = original.call(this, ...args);
            this.props = originalProps;
            return ret;
          }
        }

        return original.call(this, ...args);
      };
    }

    const originalHandleDragEnd = SpriteSelectorItem.prototype.handleDragEnd;

    SpriteSelectorItem.prototype.handleDragEnd = function (...args) {
      const itemData = getItemData(this.props);

      if (itemData) {
        if (typeof itemData.realIndex === "number" && this.props.dragging) {
          // If the item is being dragged onto another group (eg. costume list -> sprite list)
          // then we fake a drag event to make the `index` be the real index
          const originalIndex = this.props.index;
          const realIndex = itemData.realIndex;

          if (originalIndex !== realIndex) {
            const currentOffset = addon.tab.redux.state.scratchGui.assetDrag.currentOffset;
            const sortableHOCInstance = getSortableHOCFromElement(this.ref);

            if (currentOffset && sortableHOCInstance && sortableHOCInstance.getMouseOverIndex() === null) {
              this.props.index = realIndex;
              this.handleDrag(currentOffset);
              this.props.index = originalIndex;
            }
          }
        }
      }

      return originalHandleDragEnd.call(this, ...args);
    };

    const originalHandleClick = SpriteSelectorItem.prototype.handleClick;

    SpriteSelectorItem.prototype.handleClick = function (...args) {
      const e = args[0];

      if (e && !this.noClick) {
        const itemData = getItemData(this.props);

        if (itemData) {
          if (typeof itemData.folder === "string") {
            e.preventDefault();
            setFolderOpen(this, itemData.folder, !isFolderOpen(this, itemData.folder));
            return;
          }

          if (typeof this.props.number === "number" && typeof itemData.realIndex === "number") {
            e.preventDefault();

            if (this.props.onClick) {
              this.props.onClick(itemData.realIndex);
            }

            return;
          }
        }
      }

      return originalHandleClick.call(this, ...args);
    };

    const originalSetRef = SpriteSelectorItem.prototype.setRef;

    SpriteSelectorItem.prototype.setRef = function (ref) {
      originalSetRef.call(this, ref);

      if (ref) {
        ref.elem.addEventListener("contextmenu", e => {
          addContextMenuItems(this);
        });
      }
    };

    const originalRender = SpriteSelectorItem.prototype.render;

    SpriteSelectorItem.prototype.render = function () {
      const itemData = getItemData(this.props);

      if (itemData) {
        const originalProps = this.props;
        this.props = _objectSpread({}, this.props);

        if (typeof itemData.realName === "string") {
          this.props.name = getNameWithoutFolder(itemData.realName);
        }

        if (typeof this.props.number === "number" && typeof itemData.realIndex === "number") {
          // Convert 0-indexed to 1-indexed
          this.props.number = itemData.realIndex + 1;
        }

        if (typeof itemData.folder === "string") {
          this.props.name = itemData.folder;

          if (itemData.folderOpen) {
            this.props.details = msg("open-folder");
          } else {
            this.props.details = msg("closed-folder");
          }

          this.props.selected = false;
          this.props.number = null;
          this.props.className += " ".concat(getFolderColorClass(itemData.folder), " sa-folders-folder");
        }

        if (typeof itemData.inFolder === "string") {
          this.props.className += " ".concat(getFolderColorClass(itemData.inFolder));
        }

        const result = originalRender.call(this);
        this.props = originalProps;
        return result;
      }

      return originalRender.call(this);
    };
  };

  const patchVM = () => {
    const RenderedTarget = vm.runtime.targets[0].constructor;
    const originalInstallTargets = vm.installTargets;

    vm.installTargets = function (...args) {
      if (currentSpriteFolder !== null) {
        const targets = args[0];
        const wholeProject = args[2];

        if (Array.isArray(targets) && !wholeProject) {
          for (const target of targets) {
            if (target.sprite) {
              target.sprite.name = setFolderOfName(target.sprite.name, currentSpriteFolder);
            }
          }
        }
      }

      return originalInstallTargets.call(this, ...args).then(r => {
        fixTargetOrder();
        return r;
      });
    };

    const originalAddCostume = RenderedTarget.prototype.addCostume;

    RenderedTarget.prototype.addCostume = function (...args) {
      if (currentAssetFolder !== null) {
        const costume = args[0];

        if (costume && typeof getFolderFromName(costume.name) !== "string") {
          costume.name = setFolderOfName(costume.name, currentAssetFolder);
        }
      }

      const r = originalAddCostume.call(this, ...args);
      fixCostumeOrder(this);
      return r;
    };

    const originalAddSound = RenderedTarget.prototype.addSound;

    RenderedTarget.prototype.addSound = function (...args) {
      if (currentAssetFolder !== null) {
        const sound = args[0];

        if (sound && typeof getFolderFromName(sound.name) !== "string") {
          sound.name = setFolderOfName(sound.name, currentAssetFolder);
        }
      }

      const r = originalAddSound.call(this, ...args);
      fixSoundOrder(this);
      return r;
    };

    const abstractReorder = ({
      guiItems,
      getAll,
      set,
      rename,
      getVMItemFromGUIItem,
      zeroIndexed,
      onFolderChanged
    }, itemIndex, newIndex) => {
      itemIndex = clamp(itemIndex, 0, guiItems.length);
      newIndex = clamp(newIndex, 0, guiItems.length);

      if (itemIndex === newIndex) {
        return false;
      }

      let assets = getAll();
      const originalAssets = getAll();
      const targetItem = guiItems[itemIndex - (zeroIndexed ? 0 : 1)];
      const itemAtNewIndex = guiItems[newIndex - (zeroIndexed ? 0 : 1)];
      const targetItemData = getItemData(targetItem);
      const itemAtNewIndexData = getItemData(itemAtNewIndex);

      if (!targetItemData || !itemAtNewIndexData) {
        console.warn("should never happen");
        return false;
      }

      const reorderingItems = typeof targetItemData.folder === "string" ? targetItem.items : [targetItem];
      const reorderingAssets = reorderingItems.map(i => getVMItemFromGUIItem(i, assets)).filter(i => i);

      if (typeof itemAtNewIndexData.realIndex === "number") {
        const newTarget = getVMItemFromGUIItem(itemAtNewIndex, assets);

        if (!newTarget || reorderingAssets.includes(newTarget)) {
          // Dragging folder into itself or target doesn't exist. Ignore.
          return false;
        }
      }

      let newFolder = null;
      assets = assets.filter(i => !reorderingAssets.includes(i));
      let realNewIndex;

      if (newIndex === (zeroIndexed ? 0 : 1)) {
        realNewIndex = zeroIndexed ? 0 : 1;
      } else if (newIndex === guiItems.length - (zeroIndexed ? 1 : 0)) {
        realNewIndex = assets.length;
      } else if (typeof itemAtNewIndexData.realIndex === "number") {
        newFolder = typeof itemAtNewIndexData.inFolder === "string" ? itemAtNewIndexData.inFolder : null;
        let newAsset = getVMItemFromGUIItem(itemAtNewIndex, assets);

        if (!newAsset) {
          console.warn("should never happen");
          return false;
        }

        realNewIndex = assets.indexOf(newAsset);

        if (newIndex > itemIndex) {
          realNewIndex++;
        }
      } else if (typeof itemAtNewIndexData.folder === "string") {
        let item;
        let offset = 0;

        if (newIndex < itemIndex) {
          // A B [C D E] F G
          //    ^----------*
          // A B C [D] E F G
          //      ^--------*
          item = itemAtNewIndex.items[0];
        } else if (itemAtNewIndexData.folderOpen) {
          // A B [C D E] F G
          //   *---^
          item = itemAtNewIndex.items[0];
          newFolder = itemAtNewIndexData.folder;
        } else {
          // A B [C] D E F G
          //   *----^
          item = itemAtNewIndex.items[itemAtNewIndex.items.length - 1];
          offset = 1;
        }

        let newAsset = getVMItemFromGUIItem(item, assets);

        if (newAsset) {
          realNewIndex = assets.indexOf(newAsset) + offset;
        } else {
          // Edge case: Dragging the first item of a list on top of the folder item
          // A B [C D E] F G
          //    ^---*
          newAsset = getVMItemFromGUIItem(item, originalAssets);

          if (!newAsset) {
            console.warn("should never happen");
            return false;
          }

          realNewIndex = originalAssets.indexOf(newAsset) + offset;
        }
      } else {
        console.warn("should never happen");
        return false;
      }

      if (typeof targetItemData.folder === "string" && newFolder !== null) {
        // Cannot drag a folder into another folder
        return;
      }

      if (realNewIndex < (zeroIndexed ? 0 : 1) || realNewIndex > assets.length) {
        console.warn("should never happen");
        return false;
      }

      assets.splice(realNewIndex, 0, ...reorderingAssets);
      set(assets); // If the folder has changed, update item names to match.

      if (typeof targetItemData.folder !== "string" && targetItemData.inFolder !== newFolder) {
        for (const asset of reorderingAssets) {
          const name = asset.getName ? asset.getName() : asset.name;
          rename(asset, setFolderOfName(name, newFolder));
        }

        if (onFolderChanged) {
          onFolderChanged();
        }
      }

      return true;
    };

    vm.constructor.prototype.reorderTarget = function (targetIndex, newIndex) {
      return abstractReorder({
        getAll: () => {
          return this.runtime.targets;
        },
        set: targets => {
          this.runtime.targets = targets;
          this.emitTargetsUpdate();
        },
        rename: (item, name) => {
          this.renameSprite(item.id, ensureNotReserved(name));
        },
        getVMItemFromGUIItem: (item, targets) => {
          return targets.find(i => i.id === item.id);
        },
        onFolderChanged: () => {
          this.emitWorkspaceUpdate();
        },
        guiItems: currentSpriteItems,
        zeroIndexed: false
      }, targetIndex, newIndex);
    };

    RenderedTarget.prototype.reorderCostume = function (costumeIndex, newIndex) {
      return abstractReorder({
        getAll: () => {
          return this.sprite.costumes;
        },
        set: assets => {
          this.sprite.costumes = assets;
        },
        rename: (item, name) => {
          this.renameCostume(this.sprite.costumes.indexOf(item), name);
        },
        getVMItemFromGUIItem: (item, costumes) => {
          const itemData = getItemData(item);
          return costumes.find(c => c.name === itemData.realName);
        },
        guiItems: currentAssetItems,
        zeroIndexed: true
      }, costumeIndex, newIndex);
    };

    RenderedTarget.prototype.reorderSound = function (soundIndex, newIndex) {
      return abstractReorder({
        getAll: () => {
          return this.sprite.sounds;
        },
        set: assets => {
          this.sprite.sounds = assets;
        },
        rename: (item, name) => {
          this.renameSound(this.sprite.sounds.indexOf(item), name);
        },
        getVMItemFromGUIItem: (item, sounds) => {
          const itemData = getItemData(item);
          return sounds.find(c => c.name === itemData.realName);
        },
        guiItems: currentAssetItems,
        zeroIndexed: true
      }, soundIndex, newIndex);
    };
  };

  const patchBackpack = backpackInstance => {
    const Backpack = backpackInstance.constructor;

    Backpack.prototype.sa_loadNextItem = function () {
      if (!this.sa_queuedItems) return;
      const item = this.sa_queuedItems.pop();

      if (item) {
        let payload;
        let type;

        if (item.dragPayload) {
          if (item.url) {
            type = "SOUND";
          } else {
            type = "COSTUME";
          }

          payload = item.dragPayload;
        } else if (item.id) {
          type = "SPRITE";
          payload = item.id;
        }

        if (type && payload) {
          originalHandleDrop.call(this, {
            dragType: type,
            payload: payload
          });
        }
      }
    };

    Backpack.prototype.componentDidUpdate = function (prevProps, prevState) {
      if (!this.state.loading && prevState.loading && !this.state.error) {
        this.sa_loadNextItem();
      }
    };

    const originalHandleDrop = Backpack.prototype.handleDrop;

    Backpack.prototype.handleDrop = function (...args) {
      // When a folder is dropped into the backpack, upload all the items in the folder.
      const dragInfo = args[0];
      const folderItems = dragInfo && dragInfo.payload && dragInfo.payload.sa_folder_items;

      if (Array.isArray(folderItems)) {
        if (confirm(msg("confirm-backpack-folder"))) {
          this.sa_queuedItems = folderItems;
          this.sa_loadNextItem();
        }

        return;
      }

      return originalHandleDrop.call(this, ...args);
    };

    backpackInstance.handleDrop = Backpack.prototype.handleDrop.bind(backpackInstance);
  };

  await untilInEditor(); // Backpack

  {
    const clickListener = e => {
      if (!e.target.closest('[class*="backpack_backpack-header_"]')) {
        return;
      }

      setTimeout(() => {
        const backpackContainer = document.querySelector("[class^='backpack_backpack-list_']");

        if (!backpackContainer) {
          return;
        }

        document.removeEventListener("click", clickListener);
        const backpackInstance = getBackpackFromElement(backpackContainer);
        verifyBackpack(backpackInstance);
        patchBackpack(backpackInstance);
      });
    };

    document.addEventListener("click", clickListener, true);
  } // Sprite list

  {
    const spriteSelectorItemElement = await addon.tab.waitForElement("[class^='sprite-selector_sprite-wrapper']", {
      reduxCondition: state => !state.scratchGui.mode.isPlayerOnly
    });
    vm = addon.tab.traps.vm;
    reactInternalKey = Object.keys(spriteSelectorItemElement).find(i => i.startsWith(REACT_INTERNAL_PREFIX));
    const sortableHOCInstance = getSortableHOCFromElement(spriteSelectorItemElement);
    const spriteSelectorItemInstance = spriteSelectorItemElement[reactInternalKey].child.child.child.stateNode;
    verifySortableHOC(sortableHOCInstance);
    verifySpriteSelectorItem(spriteSelectorItemInstance);
    verifyVM(vm);
    patchSortableHOC(sortableHOCInstance.constructor, TYPE_SPRITES);
    patchSpriteSelectorItem(spriteSelectorItemInstance.constructor);
    sortableHOCInstance.saInitialSetup();
    patchVM();
  } // Costume and sound list

  {
    const selectorListItem = await addon.tab.waitForElement("[class*='selector_list-item']", {
      reduxCondition: state => state.scratchGui.editorTab.activeTabIndex !== 0 && !state.scratchGui.mode.isPlayerOnly
    });
    const sortableHOCInstance = getSortableHOCFromElement(selectorListItem);
    verifySortableHOC(sortableHOCInstance);
    patchSortableHOC(sortableHOCInstance.constructor, TYPE_ASSETS);
    sortableHOCInstance.saInitialSetup();
  }
});

/***/ }),

/***/ "./src/addons/addons/gamepad/active.png":
/*!**********************************************!*\
  !*** ./src/addons/addons/gamepad/active.png ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/bb253918c345ecd72e87fdde9b57c41a.png";

/***/ }),

/***/ "./src/addons/addons/gamepad/close.svg":
/*!*********************************************!*\
  !*** ./src/addons/addons/gamepad/close.svg ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/7ccb0253b8f853a83465bfc2a1c68294.svg";

/***/ }),

/***/ "./src/addons/addons/gamepad/cursor.png":
/*!**********************************************!*\
  !*** ./src/addons/addons/gamepad/cursor.png ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/8cd418f8f584076a4ee8497b0534f45c.png";

/***/ }),

/***/ "./src/addons/addons/gamepad/dot.svg":
/*!*******************************************!*\
  !*** ./src/addons/addons/gamepad/dot.svg ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/dc05dad5bd29cfb425a6315c61be3193.svg";

/***/ }),

/***/ "./src/addons/addons/gamepad/gamepad.svg":
/*!***********************************************!*\
  !*** ./src/addons/addons/gamepad/gamepad.svg ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/cf2bdd182f62aaf82abdc3df183d5229.svg";

/***/ }),

/***/ "./src/addons/addons/gamepad/gamepadlib.js":
/*!*************************************************!*\
  !*** ./src/addons/addons/gamepad/gamepadlib.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
let console = window.console;
/*
Mapping types:

type: "key" maps a button to a keyboard key
All key names will be interpreted as a KeyboardEvent.key value (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
high: "KeyName" is the name of the key to dispatch when a button reads a HIGH value
low: "KeyName" is the name of the key to dispatch when a button reads a LOW value
deadZone: 0.5 controls the minimum value necessary to be read in either + or - to trigger either high or low
The high/low distinction is necessary for axes. Buttons will only use high

type: "mousedown" maps a button to control whether the mouse is down or not
deadZone: 0.5 controls the minimum value to trigger a mousedown

type: "virtual_cursor" maps a button to control the "virtual cursor"
deadZone: 0.5 again controls the minimum value to trigger a movement
sensitivity: 10 controls the speed
high: "+y"/"-y"/"+x"/"-x" defines what happens when an axis reads high
low: "+y"/"-y"/"+x"/"-x" defines what happens when an axis reads low
+y increases y, -y decreases y, +x increases x, -x decreases x.
*/

const defaultAxesMappings = {
  arrows: [{
    type: "key",
    high: "ArrowRight",
    low: "ArrowLeft",
    deadZone: 0.5
  }, {
    type: "key",
    high: "ArrowDown",
    low: "ArrowUp",
    deadZone: 0.5
  }],
  wasd: [{
    type: "key",
    high: "d",
    low: "a",
    deadZone: 0.5
  }, {
    type: "key",
    high: "s",
    low: "w",
    deadZone: 0.5
  }],
  cursor: [{
    type: "virtual_cursor",
    high: "+x",
    low: "-x",
    sensitivity: 0.6,
    deadZone: 0.2
  }, {
    type: "virtual_cursor",
    high: "-y",
    low: "+y",
    sensitivity: 0.6,
    deadZone: 0.2
  }]
};

const emptyMapping = () => ({
  type: "key",
  high: null,
  low: null
});

const transformAndCopyMapping = mapping => {
  if (typeof mapping !== "object" || !mapping) {
    console.warn("invalid mapping", mapping);
    return emptyMapping();
  }

  const copy = Object.assign({}, mapping);

  if (copy.type === "key") {
    if (typeof copy.deadZone === "undefined") {
      copy.deadZone = 0.5;
    }

    if (typeof copy.high === "undefined") {
      copy.high = "";
    }

    if (typeof copy.low === "undefined") {
      copy.low = "";
    }
  } else if (copy.type === "mousedown") {
    if (typeof copy.deadZone === "undefined") {
      copy.deadZone = 0.5;
    }
  } else if (copy.type === "virtual_cursor") {
    if (typeof copy.high === "undefined") {
      copy.high = "";
    }

    if (typeof copy.low === "undefined") {
      copy.low = "";
    }

    if (typeof copy.sensitivity === "undefined") {
      copy.sensitivity = 10;
    }

    if (typeof copy.deadZone === "undefined") {
      copy.deadZone = 0.5;
    }
  } else {
    console.warn("unknown mapping type", copy.type);
    return emptyMapping();
  }

  return copy;
};

const prepareMappingForExport = mapping => Object.assign({}, mapping);

const prepareAxisMappingForExport = prepareMappingForExport;

const prepareButtonMappingForExport = mapping => {
  const copy = prepareMappingForExport(mapping);
  delete copy.deadZone;
  delete copy.low;
  return copy;
};

const padWithEmptyMappings = (array, length) => {
  // Keep adding empty mappings until the list is full
  while (array.length < length) {
    array.push(emptyMapping());
  } // In case the input array is longer than the desired length


  array.length = length;
  return array;
};

const getMovementConfiguration = usedKeys => ({
  usesArrows: usedKeys.has("ArrowUp") || usedKeys.has("ArrowDown") || usedKeys.has("ArrowRight") || usedKeys.has("ArrowLeft"),
  usesWASD: usedKeys.has("w") && usedKeys.has("s") || usedKeys.has("a") && usedKeys.has("d")
});

const getGamepadId = gamepad => "".concat(gamepad.id, " (").concat(gamepad.index, ")");

class GamepadData {
  /**
   * @param {Gamepad} gamepad Source Gamepad
   * @param {GamepadLib} gamepadLib Parent GamepadLib
   */
  constructor(gamepad, gamepadLib) {
    this.gamepad = gamepad;
    this.gamepadLib = gamepadLib;
    this.buttonMappings = this.getDefaultButtonMappings().map(transformAndCopyMapping);
    this.axesMappings = this.getDefaultAxisMappings().map(transformAndCopyMapping);
  }

  getDefaultButtonMappings() {
    let buttons;

    if (this.gamepadLib.hints.importedSettings) {
      buttons = this.gamepadLib.hints.importedSettings.buttons;
    } else {
      const usedKeys = this.gamepadLib.hints.usedKeys;
      const alreadyUsedKeys = new Set();
      const {
        usesArrows,
        usesWASD
      } = getMovementConfiguration(usedKeys);

      if (usesWASD) {
        alreadyUsedKeys.add("w");
        alreadyUsedKeys.add("a");
        alreadyUsedKeys.add("s");
        alreadyUsedKeys.add("d");
      }

      const possiblePauseKeys = [// Restart keys, pause keys, other potentially dangerous keys
      "p", "q", "r"];
      const possibleActionKeys = [" ", "Enter", "e", "f", "z", "x", "c", ...Array.from(usedKeys).filter(i => i.length === 1 && !possiblePauseKeys.includes(i))];

      const findKey = keys => {
        for (const key of keys) {
          if (usedKeys.has(key) && !alreadyUsedKeys.has(key)) {
            alreadyUsedKeys.add(key);
            return key;
          }
        }

        return null;
      };

      const getPrimaryAction = () => {
        if (usesArrows && usedKeys.has("ArrowUp")) {
          return "ArrowUp";
        }

        if (usesWASD && usedKeys.has("w")) {
          return "w";
        }

        return findKey(possibleActionKeys);
      };

      const getSecondaryAction = () => findKey(possibleActionKeys);

      const getPauseKey = () => findKey(possiblePauseKeys);

      const getUp = () => {
        if (usesArrows || !usesWASD) return "ArrowUp";
        return "w";
      };

      const getDown = () => {
        if (usesArrows || !usesWASD) return "ArrowDown";
        return "s";
      };

      const getRight = () => {
        if (usesArrows || !usesWASD) return "ArrowRight";
        return "d";
      };

      const getLeft = () => {
        if (usesArrows || !usesWASD) return "ArrowLeft";
        return "a";
      };

      const action1 = getPrimaryAction();
      let action2 = getSecondaryAction();
      let action3 = getSecondaryAction();
      let action4 = getSecondaryAction(); // When only 1 or 2 action keys are detected, bind the other buttons to the same things.

      if (action1 && !action2 && !action3 && !action4) {
        action2 = action1;
        action3 = action1;
        action4 = action1;
      }

      if (action1 && action2 && !action3 && !action4) {
        action3 = action1;
        action4 = action2;
      } // Set indices "manually" because we don't evaluate them in order.


      buttons = [];
      buttons[0] = {
        /*
        Xbox: A
        SNES-like: B
        */
        type: "key",
        high: action1
      };
      buttons[1] = {
        /*
        Xbox: B
        SNES-like: A
        */
        type: "key",
        high: action2
      };
      buttons[2] = {
        /*
        Xbox: X
        SNES-like: Y
        */
        type: "key",
        high: action3
      };
      buttons[3] = {
        /*
        Xbox: Y
        SNES-like: X
        */
        type: "key",
        high: action4
      };
      buttons[4] = {
        /*
        Xbox: LB
        SNES-like: Left trigger
        */
        type: "mousedown"
      };
      buttons[5] = {
        /*
        Xbox: RB
        */
        type: "mousedown"
      };
      buttons[6] = {
        /*
        Xbox: LT
        */
        type: "mousedown"
      };
      buttons[7] = {
        /*
        Xbox: RT
        SNES-like: Right trigger
        */
        type: "mousedown"
      };
      buttons[9] = {
        /*
        Xbox: Menu
        SNES-like: Start
        */
        type: "key",
        high: getPauseKey()
      };
      buttons[8] = {
        /*
        Xbox: Change view
        SNES-like: Select
        */
        type: "key",
        high: getPauseKey()
      }; // Xbox: Left analog press

      buttons[10] = emptyMapping(); // Xbox: Right analog press

      buttons[11] = emptyMapping();
      buttons[12] = {
        /*
        Xbox: D-pad up
        */
        type: "key",
        high: getUp()
      };
      buttons[13] = {
        /*
        Xbox: D-pad down
        */
        type: "key",
        high: getDown()
      };
      buttons[14] = {
        /*
        Xbox: D-pad left
        */
        type: "key",
        high: getLeft()
      };
      buttons[15] = {
        /*
        Xbox: D-pad right
        */
        type: "key",
        high: getRight()
      };
    }

    return padWithEmptyMappings(buttons, this.gamepad.buttons.length);
  }

  getDefaultAxisMappings() {
    let axes = [];

    if (this.gamepadLib.hints.importedSettings) {
      axes = this.gamepadLib.hints.importedSettings.axes;
    } else {
      // Only return default axis mappings when there are 4 axes, like an xbox controller
      // If there isn't exactly 4, we can't really predict what the axes mean
      // Some controllers map the dpad to *both* buttons and axes at the same time, which would cause conflicts.
      if (this.gamepad.axes.length === 4) {
        const usedKeys = this.gamepadLib.hints.usedKeys;
        const {
          usesArrows,
          usesWASD
        } = getMovementConfiguration(usedKeys);

        if (usesWASD) {
          axes.push(defaultAxesMappings.wasd[0]);
          axes.push(defaultAxesMappings.wasd[1]);
        } else if (usesArrows) {
          axes.push(defaultAxesMappings.arrows[0]);
          axes.push(defaultAxesMappings.arrows[1]);
        } else {
          axes.push(defaultAxesMappings.cursor[0]);
          axes.push(defaultAxesMappings.cursor[1]);
        }

        axes.push(defaultAxesMappings.cursor[0]);
        axes.push(defaultAxesMappings.cursor[1]);
      }
    }

    return padWithEmptyMappings(axes, this.gamepad.axes.length);
  }

}

class GamepadLib extends EventTarget {
  constructor() {
    super();
    /** @type {Map<string, GamepadData>} */

    this.gamepads = new Map();
    this.handleConnect = this.handleConnect.bind(this);
    this.handleDisconnect = this.handleDisconnect.bind(this);
    this.update = this.update.bind(this);
    this.animationFrame = null;
    this.currentTime = null;
    this.deltaTime = 0;
    this.virtualCursor = {
      x: 0,
      y: 0,
      maxX: Infinity,
      minX: -Infinity,
      maxY: Infinity,
      minY: -Infinity,
      modified: false
    };
    this._editor = null;
    this.connectCallbacks = [];
    this.hints = {
      usedKeys: new Set(),
      importedSettings: null,
      generated: false
    };
    this.keysPressedThisFrame = new Set();
    this.oldKeysPressed = new Set();
    this.mouseDownThisFrame = false;
    this.oldMouseDown = false;
    this.addEventHandlers();
  }

  addEventHandlers() {
    window.addEventListener("gamepadconnected", this.handleConnect);
    window.addEventListener("gamepaddisconnected", this.handleDisconnect);
  }

  removeEventHandlers() {
    window.removeEventListener("gamepadconnected", this.handleConnect);
    window.removeEventListener("gamepaddisconnected", this.handleDisconnect);
  }

  gamepadConnected() {
    if (this.gamepads.size > 0) {
      return Promise.resolve();
    }

    return new Promise(resolve => {
      this.connectCallbacks.push(resolve);
    });
  }

  ensureHintsGenerated() {
    if (this.hints.generated) {
      return;
    }

    if (this.getHintsLazily) {
      Object.assign(this.hints, this.getHintsLazily());
    }

    this.hints.generated = true;
  }

  handleConnect(e) {
    this.ensureHintsGenerated();

    for (const callback of this.connectCallbacks) {
      callback();
    }

    this.connectCallbacks = [];
    const gamepad = e.gamepad;
    const id = getGamepadId(gamepad);
    console.log("connected", gamepad);
    const gamepadData = new GamepadData(gamepad, this);
    this.gamepads.set(id, gamepadData);

    if (this.animationFrame === null) {
      this.animationFrame = requestAnimationFrame(this.update);
    }

    this.dispatchEvent(new CustomEvent("gamepadconnected", {
      detail: gamepadData
    }));
  }

  handleDisconnect(e) {
    const gamepad = e.gamepad;
    const id = getGamepadId(gamepad);
    console.log("disconnected", gamepad);
    const gamepadData = this.gamepads.get(id);
    this.gamepads.delete(id);
    this.dispatchEvent(new CustomEvent("gamepaddisconnected", {
      detail: gamepadData
    }));

    if (this.gamepads.size === 0) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
      this.currentTime = null;
    }
  }

  dispatchKey(key, pressed) {
    if (pressed) {
      this.dispatchEvent(new CustomEvent("keydown", {
        detail: key
      }));
    } else {
      this.dispatchEvent(new CustomEvent("keyup", {
        detail: key
      }));
    }
  }

  dispatchMouseDown(down) {
    if (down) {
      this.dispatchEvent(new CustomEvent("mousedown"));
    } else {
      this.dispatchEvent(new CustomEvent("mouseup"));
    }
  }

  dispatchMouseMove(x, y) {
    this.dispatchEvent(new CustomEvent("mousemove", {
      detail: {
        x,
        y
      }
    }));
  }

  updateButton(value, mapping) {
    if (mapping.type === "key") {
      if (value >= mapping.deadZone) {
        if (mapping.high) {
          this.keysPressedThisFrame.add(mapping.high);
        }
      } else if (value <= -mapping.deadZone) {
        if (mapping.low) {
          this.keysPressedThisFrame.add(mapping.low);
        }
      }
    } else if (mapping.type === "mousedown") {
      const isDown = Math.abs(value) >= mapping.deadZone;

      if (isDown) {
        this.mouseDownThisFrame = true;
      }
    } else if (mapping.type === "virtual_cursor") {
      const deadZone = mapping.deadZone;
      let action;
      if (value >= deadZone) action = mapping.high;
      if (value <= -deadZone) action = mapping.low;

      if (action) {
        // an axis value just beyond the deadzone should have a multiplier near 0, a high value should have a multiplier of 1
        const multiplier = (Math.abs(value) - deadZone) / (1 - deadZone);
        const speed = multiplier * multiplier * mapping.sensitivity * this.deltaTime;

        if (action === "+x") {
          this.virtualCursor.x += speed;
        } else if (action === "-x") {
          this.virtualCursor.x -= speed;
        } else if (action === "+y") {
          this.virtualCursor.y += speed;
        } else if (action === "-y") {
          this.virtualCursor.y -= speed;
        }

        this.virtualCursor.modified = true;
      }
    }
  }

  update(time) {
    this.oldKeysPressed = this.keysPressedThisFrame;
    this.oldMouseDown = this.mouseDownThisFrame;
    this.keysPressedThisFrame = new Set();
    this.mouseDownThisFrame = false;

    if (this.currentTime === null) {
      this.deltaTime = 0; // doesn't matter what this is, it's just the first frame
    } else {
      this.deltaTime = time - this.currentTime;
    }

    this.deltaTime = Math.max(Math.min(this.deltaTime, 1000), 0);
    this.currentTime = time;
    this.animationFrame = requestAnimationFrame(this.update);
    const gamepads = navigator.getGamepads();

    for (const gamepad of gamepads) {
      if (gamepad === null) {
        continue;
      }

      const id = getGamepadId(gamepad);
      const data = this.gamepads.get(id);

      for (let i = 0; i < gamepad.buttons.length; i++) {
        const button = gamepad.buttons[i];
        const value = button.value;
        const mapping = data.buttonMappings[i];
        this.updateButton(value, mapping);
      }

      for (let i = 0; i < gamepad.axes.length; i++) {
        const axis = gamepad.axes[i];
        const mapping = data.axesMappings[i];
        this.updateButton(axis, mapping);
      }
    }

    if (this._editor) {
      this._editor.update(gamepads);
    }

    for (const key of this.keysPressedThisFrame) {
      if (!this.oldKeysPressed.has(key)) {
        this.dispatchKey(key, true);
      }
    }

    for (const key of this.oldKeysPressed) {
      if (!this.keysPressedThisFrame.has(key)) {
        this.dispatchKey(key, false);
      }
    }

    if (this.mouseDownThisFrame && !this.oldMouseDown) {
      this.dispatchMouseDown(true);
    } else if (!this.mouseDownThisFrame && this.oldMouseDown) {
      this.dispatchMouseDown(false);
    }

    if (this.virtualCursor.modified) {
      this.virtualCursor.modified = false;

      if (this.virtualCursor.x > this.virtualCursor.maxX) {
        this.virtualCursor.x = this.virtualCursor.maxX;
      }

      if (this.virtualCursor.x < this.virtualCursor.minX) {
        this.virtualCursor.x = this.virtualCursor.minX;
      }

      if (this.virtualCursor.y > this.virtualCursor.maxY) {
        this.virtualCursor.y = this.virtualCursor.maxY;
      }

      if (this.virtualCursor.y < this.virtualCursor.minY) {
        this.virtualCursor.y = this.virtualCursor.minY;
      }

      this.dispatchMouseMove(this.virtualCursor.x, this.virtualCursor.y);
    }
  }

  editor() {
    if (!this._editor) {
      this._editor = new GamepadEditor(this);
    }

    return this._editor;
  }

}

GamepadLib.browserHasBrokenGamepadAPI = () => {
  // Check that the gamepad API is supported at all
  if (!navigator.getGamepads) {
    return true;
  } // Firefox on Linux has a broken gamepad API implementation that results in strange and sometimes unusable mappings
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1643358
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1643835


  if (navigator.userAgent.includes("Firefox") && navigator.userAgent.includes("Linux")) {
    return true;
  } // Firefox on macOS has other bugs that result in strange and unusable mappings
  // eg. https://bugzilla.mozilla.org/show_bug.cgi?id=1434408


  if (navigator.userAgent.includes("Firefox") && navigator.userAgent.includes("Mac OS")) {
    return true;
  }

  return false;
};

GamepadLib.setConsole = n => console = n;

const removeAllChildren = el => {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
};

const buttonHtmlId = index => "gamepadlib-button-".concat(index);

const axisHtmlId = n => "gamepadlib-axis-".concat(n);

class GamepadEditor extends EventTarget {
  constructor(gamepadLib) {
    super();
    /** @type {GamepadLib} */

    this.gamepadLib = gamepadLib;
    this.root = Object.assign(document.createElement("div"), {
      className: "gamepadlib-root"
    });
    this.selector = Object.assign(document.createElement("select"), {
      className: "gamepadlib-selector"
    });
    this.content = Object.assign(document.createElement("div"), {
      className: "gamepadlib-content"
    });
    this.root.appendChild(this.selector);
    this.root.appendChild(this.content);
    this.onSelectorChange = this.onSelectorChange.bind(this);
    this.onGamepadsChange = this.onGamepadsChange.bind(this);
    this.selector.onchange = this.onSelectorChange;
    this.gamepadLib.addEventListener("gamepadconnected", this.onGamepadsChange);
    this.gamepadLib.addEventListener("gamepaddisconnected", this.onGamepadsChange);
    this.buttonIdToElement = new Map();
    this.axisIdToElement = new Map();
    this.hidden = false; // should be overridden later

    this.msg = (id, opts) => id;
  }

  onSelectorChange() {
    this.updateContent();
    this.dispatchEvent(new CustomEvent("gamepad-changed"));
  }

  onGamepadsChange() {
    this.updateAllContent();
    this.dispatchEvent(new CustomEvent("gamepad-changed"));
  }

  updateAllContent() {
    this.updateDropdown();
    this.updateContent();
    this.focus();
  }

  updateDropdown() {
    removeAllChildren(this.selector);
    const gamepads = Array.from(this.gamepadLib.gamepads.entries());

    if (gamepads.length === 0) {
      this.selector.hidden = true;
      return;
    }

    this.selector.hidden = false;

    for (const [id, _] of gamepads) {
      const option = document.createElement("option");
      option.textContent = id;
      option.value = id;
      this.selector.appendChild(option);
    }
  }

  keyToString(key) {
    if (key === " ") return this.msg("key-space");
    if (key === "ArrowUp") return this.msg("key-up");
    if (key === "ArrowDown") return this.msg("key-down");
    if (key === "ArrowLeft") return this.msg("key-left");
    if (key === "ArrowRight") return this.msg("key-right");
    if (key === "Enter") return this.msg("key-enter");
    return key.toUpperCase();
  }

  createButtonMapping(mappingList, index, {
    property = "high",
    allowClick = true
  } = {}) {
    const input = document.createElement("input");
    input.readOnly = true;
    input.className = "gamepadlib-keyinput";
    input.title = this.msg("keyinput-title");
    input.dataset.index = index;

    const update = () => {
      const mapping = mappingList[index];
      input.dataset.empty = false;

      if (mapping.type === "key") {
        if (mapping[property] === null) {
          input.value = this.msg("key-none");
          input.dataset.empty = true;
        } else {
          input.value = this.keyToString(mapping[property]);
        }
      } else if (mapping.type === "mousedown") {
        input.value = this.msg("key-click");
      } else {
        // should never happen
        input.value = "??? ".concat(mapping.type);
      }
    };

    const changedMapping = () => {
      mappingList[index] = transformAndCopyMapping(mappingList[index]);
      isAcceptingInput = false;
      input.blur();
      update();
      input.dispatchEvent(new CustomEvent("mapping-changed"));
      this.changed();
    };

    let isAcceptingInput = false;

    const handleClick = e => {
      e.preventDefault();

      if (isAcceptingInput) {
        if (allowClick) {
          const mapping = mappingList[index];
          mapping.type = "mousedown";
          changedMapping();
        } else {
          handleBlur();
        }
      } else {
        input.value = "...";
        input.dataset.acceptingInput = true;
        isAcceptingInput = true;
      }
    };

    const handleKeyDown = e => {
      if (isAcceptingInput) {
        e.preventDefault();
        const key = e.key;

        if (["Alt", "Shift", "Control"].includes(key)) {
          return;
        }

        const mapping = mappingList[index];

        if (key.length === 1 || ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter"].includes(key)) {
          mapping.type = "key";
          mapping[property] = key;
        } else if (key !== "Escape") {
          mapping.type = "key";
          mapping[property] = null;
        }

        changedMapping();
      } else if (e.key === "Enter") {
        e.preventDefault();
        e.target.click();
      }
    };

    const handleBlur = () => {
      input.dataset.acceptingInput = false;

      if (isAcceptingInput) {
        isAcceptingInput = false;
        update();
      }
    };

    input.addEventListener("click", handleClick);
    input.addEventListener("keydown", handleKeyDown);
    input.addEventListener("blur", handleBlur);
    update();
    return input;
  }

  createAxisMapping(mappingList, index) {
    const selector = document.createElement("select");
    selector.className = "gamepadlib-axis-mapping";
    selector.id = axisHtmlId(index);
    selector.appendChild(Object.assign(document.createElement("option"), {
      textContent: this.msg("axis-none"),
      value: "none"
    }));
    selector.appendChild(Object.assign(document.createElement("option"), {
      textContent: this.msg("axis-cursor"),
      value: "cursor"
    }));
    selector.appendChild(Object.assign(document.createElement("option"), {
      // doesn't really make sense to translate
      textContent: "WASD",
      value: "wasd"
    }));
    selector.appendChild(Object.assign(document.createElement("option"), {
      textContent: this.msg("axis-arrows"),
      value: "arrows"
    }));
    selector.appendChild(Object.assign(document.createElement("option"), {
      textContent: this.msg("axis-custom"),
      value: "custom"
    }));

    const updateDropdownValue = () => {
      if (mappingList[index].type === "key" || mappingList[index].type === "mousedown") {
        if (mappingList[index].high === null && mappingList[index].low === null && mappingList[index + 1].high === null && mappingList[index + 1].low === null) {
          selector.value = "none";
        } else if (mappingList[index].high === defaultAxesMappings.wasd[0].high && mappingList[index].low === defaultAxesMappings.wasd[0].low && mappingList[index + 1].high === defaultAxesMappings.wasd[1].high && mappingList[index + 1].low === defaultAxesMappings.wasd[1].low) {
          selector.value = "wasd";
        } else if (mappingList[index].high === defaultAxesMappings.arrows[0].high && mappingList[index].low === defaultAxesMappings.arrows[0].low && mappingList[index + 1].high === defaultAxesMappings.arrows[1].high && mappingList[index + 1].low === defaultAxesMappings.arrows[1].low) {
          selector.value = "arrows";
        } else {
          selector.value = "custom";
        }
      } else if (mappingList[index].type === "virtual_cursor") {
        selector.value = "cursor";
      } else {
        // should never happen
        selector.value = "none";
      }
    };

    updateDropdownValue();
    const circleOverlay = document.createElement("div");
    circleOverlay.className = "gamepadlib-axis-circle-overlay";

    const updateOverlay = () => {
      removeAllChildren(circleOverlay);

      if (mappingList[index].type === "key") {
        const buttons = [this.createButtonMapping(mappingList, index + 1, {
          property: "low",
          allowClick: false
        }), this.createButtonMapping(mappingList, index, {
          property: "low",
          allowClick: false
        }), this.createButtonMapping(mappingList, index, {
          property: "high",
          allowClick: false
        }), this.createButtonMapping(mappingList, index + 1, {
          property: "high",
          allowClick: false
        })];

        for (const button of buttons) {
          button.classList.add("gamepadlib-axis-mapper");
          button.addEventListener("mapping-changed", updateDropdownValue);
          circleOverlay.appendChild(button);
        }
      }
    };

    updateOverlay();
    selector.addEventListener("change", () => {
      if (selector.value === "custom") {
        // If key mappings already exist, leave them as-is
        if (mappingList[index].type !== "key") {
          mappingList[index] = transformAndCopyMapping(defaultAxesMappings.arrows[0]);
          mappingList[index + 1] = transformAndCopyMapping(defaultAxesMappings.arrows[1]);
        }
      } else if (selector.value === "arrows") {
        mappingList[index] = transformAndCopyMapping(defaultAxesMappings.arrows[0]);
        mappingList[index + 1] = transformAndCopyMapping(defaultAxesMappings.arrows[1]);
      } else if (selector.value === "wasd") {
        mappingList[index] = transformAndCopyMapping(defaultAxesMappings.wasd[0]);
        mappingList[index + 1] = transformAndCopyMapping(defaultAxesMappings.wasd[1]);
      } else if (selector.value === "cursor") {
        mappingList[index] = transformAndCopyMapping(defaultAxesMappings.cursor[0]);
        mappingList[index + 1] = transformAndCopyMapping(defaultAxesMappings.cursor[1]);
      } else {
        mappingList[index] = transformAndCopyMapping(emptyMapping());
        mappingList[index + 1] = transformAndCopyMapping(emptyMapping());
      }

      updateOverlay();
      this.changed();
    });
    return {
      circleOverlay,
      selector
    };
  }

  hasControllerSelected() {
    return !!this.selector.value;
  }

  updateContent() {
    removeAllChildren(this.content);

    if (this.hidden) {
      return;
    }

    const selectedId = this.selector.value;

    if (!selectedId) {
      const message = document.createElement("div");
      message.textContent = this.msg("no-controllers");
      this.content.appendChild(message);
      return;
    }

    const gamepadData = this.gamepadLib.gamepads.get(selectedId);

    if (!gamepadData) {
      // Users should never be able to see this
      const message = document.createElement("div");
      message.textContent = "Cannot find controller: ".concat(selectedId);
      this.content.appendChild(message);
      return;
    }

    this.buttonIdToElement.clear();
    this.axisIdToElement.clear();
    const mappingsContainer = document.createElement("div");
    mappingsContainer.className = "gamepadlib-content-buttons";
    const buttonMappings = gamepadData.buttonMappings;

    for (let i = 0; i < buttonMappings.length; i++) {
      const container = document.createElement("div");
      container.className = "gamepadlib-mapping";
      container.dataset.id = i;
      const label = document.createElement("label");
      label.className = "gamepadlib-mapping-label";
      label.textContent = this.msg("button-n", {
        n: i
      });
      const id = buttonHtmlId(i);
      label.htmlFor = id;
      const options = document.createElement("div");
      options.className = "gamepadlib-mapping-options";
      const mappingInput = this.createButtonMapping(buttonMappings, i);
      mappingInput.id = id;
      options.appendChild(mappingInput);
      container.appendChild(label);
      container.appendChild(options);
      mappingsContainer.appendChild(container);
      this.buttonIdToElement.set(i, container);
    }

    const axesContainer = document.createElement("div");
    axesContainer.className = "gamepadlib-content-axes";
    const axesMappings = gamepadData.axesMappings;

    for (let i = 0; i < axesMappings.length; i += 2) {
      const container = document.createElement("div");
      container.className = "gamepadlib-axis";
      const label = document.createElement("label");
      label.textContent = this.msg("axes-a-b", {
        a: i,
        b: i + 1
      });
      label.htmlFor = axisHtmlId(i);
      const circle = document.createElement("div");
      circle.className = "gamepadlib-axis-circle";
      const {
        circleOverlay,
        selector
      } = this.createAxisMapping(axesMappings, i);
      circle.appendChild(circleOverlay);
      const dot = document.createElement("div");
      dot.className = "gamepadlib-axis-dot";
      circle.appendChild(dot);
      container.appendChild(label);
      container.appendChild(circle);
      container.appendChild(selector);
      axesContainer.appendChild(container);
      this.axisIdToElement.set(i, dot);
    }

    this.content.appendChild(mappingsContainer);
    this.content.appendChild(axesContainer);
  }

  update(gamepads) {
    if (this.hidden) {
      return;
    }

    const selectedId = this.selector.value;

    if (!selectedId) {
      return;
    }

    const gamepad = Array.from(gamepads).find(i => i && getGamepadId(i) === this.selector.value);

    if (!gamepad) {
      return;
    }

    for (let i = 0; i < gamepad.buttons.length; i++) {
      const element = this.buttonIdToElement.get(i);

      if (element) {
        const button = gamepad.buttons[i];
        const value = button.value.toString();

        if (value !== element.dataset.value) {
          element.dataset.value = value;
        }
      }
    }

    for (let i = 0; i < gamepad.axes.length; i += 2) {
      const element = this.axisIdToElement.get(i);

      if (element) {
        const x = gamepad.axes[i];
        const y = gamepad.axes[i + 1] || 0;
        const size = 150 / 2;
        element.style.transform = "translate(-50%, -50%) translate(".concat(x * size, "px, ").concat(y * size, "px)");
      }
    }
  }

  export() {
    const selectedId = this.selector.value;

    if (!selectedId) {
      return null;
    }

    const gamepadData = this.gamepadLib.gamepads.get(selectedId);

    if (!gamepadData) {
      return null;
    }

    return {
      axes: gamepadData.axesMappings.map(prepareAxisMappingForExport),
      buttons: gamepadData.buttonMappings.map(prepareButtonMappingForExport)
    };
  }

  changed() {
    this.dispatchEvent(new CustomEvent("mapping-changed"));
  }

  hide() {
    this.hidden = true;
    this.updateContent();
  }

  focus() {
    if (this.selector.value) {
      this.selector.focus();
    }
  }

  generateEditor() {
    this.hidden = false;
    this.updateAllContent();
    return this.root;
  }

}

/* harmony default export */ __webpack_exports__["default"] = (GamepadLib);

/***/ }),

/***/ "./src/addons/addons/gamepad/userscript.js":
/*!*************************************************!*\
  !*** ./src/addons/addons/gamepad/userscript.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _active_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./active.png */ "./src/addons/addons/gamepad/active.png");
/* harmony import */ var _active_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_active_png__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _close_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./close.svg */ "./src/addons/addons/gamepad/close.svg");
/* harmony import */ var _close_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_close_svg__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cursor_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cursor.png */ "./src/addons/addons/gamepad/cursor.png");
/* harmony import */ var _cursor_png__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cursor_png__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _dot_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dot.svg */ "./src/addons/addons/gamepad/dot.svg");
/* harmony import */ var _dot_svg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_dot_svg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _gamepad_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gamepad.svg */ "./src/addons/addons/gamepad/gamepad.svg");
/* harmony import */ var _gamepad_svg__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_gamepad_svg__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _gamepadlib_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gamepadlib.js */ "./src/addons/addons/gamepad/gamepadlib.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* inserted by pull.js */






const _twGetAsset = path => {
  if (path === "/active.png") return _active_png__WEBPACK_IMPORTED_MODULE_0___default.a;
  if (path === "/close.svg") return _close_svg__WEBPACK_IMPORTED_MODULE_1___default.a;
  if (path === "/cursor.png") return _cursor_png__WEBPACK_IMPORTED_MODULE_2___default.a;
  if (path === "/dot.svg") return _dot_svg__WEBPACK_IMPORTED_MODULE_3___default.a;
  if (path === "/gamepad.svg") return _gamepad_svg__WEBPACK_IMPORTED_MODULE_4___default.a;
  throw new Error("Unknown asset: ".concat(path));
};


/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  const vm = addon.tab.traps.vm; // Wait for the project to finish loading. Renderer and scripts will not be fully available until this happens.

  await new Promise(resolve => {
    if (vm.editingTarget) return resolve();
    vm.runtime.once("PROJECT_LOADED", resolve);
  });

  const vmStarted = () => vm.runtime._steppingInterval !== null;

  const scratchKeyToKey = key => {
    switch (key) {
      case "right arrow":
        return "ArrowRight";

      case "up arrow":
        return "ArrowUp";

      case "left arrow":
        return "ArrowLeft";

      case "down arrow":
        return "ArrowDown";

      case "enter":
        return "Enter";

      case "space":
        return " ";
    }

    return key.toLowerCase().charAt(0);
  };

  const getKeysUsedByProject = () => {
    const allBlocks = [vm.runtime.getTargetForStage(), ...vm.runtime.targets].filter(i => i.isOriginal).map(i => i.blocks);
    const result = new Set();

    for (const blocks of allBlocks) {
      for (const block of Object.values(blocks._blocks)) {
        if (block.opcode === "event_whenkeypressed" || block.opcode === "sensing_keyoptions") {
          // For blocks like "key (my variable) pressed?", the sensing_keyoptions still exists but has a null parent.
          if (block.opcode === "sensing_keyoptions" && !block.parent) {
            continue;
          }

          const key = block.fields.KEY_OPTION.value;
          result.add(scratchKeyToKey(key));
        }
      }
    }

    return result;
  };

  const GAMEPAD_CONFIG_MAGIC = " // _gamepad_";

  const findOptionsComment = () => {
    const target = vm.runtime.getTargetForStage();
    const comments = target.comments;

    for (const comment of Object.values(comments)) {
      if (comment.text.includes(GAMEPAD_CONFIG_MAGIC)) {
        return comment;
      }
    }

    return null;
  };

  const parseOptionsComment = () => {
    const comment = findOptionsComment();

    if (!comment) {
      return null;
    }

    const lineWithMagic = comment.text.split("\n").find(i => i.endsWith(GAMEPAD_CONFIG_MAGIC));

    if (!lineWithMagic) {
      console.warn("Gamepad comment does not contain valid line");
      return null;
    }

    const jsonText = lineWithMagic.substr(0, lineWithMagic.length - GAMEPAD_CONFIG_MAGIC.length);
    let parsed;

    try {
      parsed = JSON.parse(jsonText);

      if (!parsed || typeof parsed !== "object" || !Array.isArray(parsed.buttons) || !Array.isArray(parsed.axes)) {
        throw new Error("Invalid data");
      }
    } catch (e) {
      console.warn("Gamepad comment has invalid JSON", e);
      return null;
    }

    return parsed;
  };

  _gamepadlib_js__WEBPACK_IMPORTED_MODULE_5__["default"].setConsole(console);
  const gamepad = new _gamepadlib_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
  const parsedOptions = parseOptionsComment();

  gamepad.getHintsLazily = () => {
    if (parsedOptions) {
      return {
        importedSettings: parsedOptions
      };
    }

    return {
      usedKeys: getKeysUsedByProject()
    };
  };

  if (addon.settings.get("hide")) {
    await new Promise(resolve => {
      const end = () => {
        addon.settings.removeEventListener("change", listener);
        resolve();
      };

      const listener = () => {
        if (!addon.settings.get("hide")) {
          end();
        }
      };

      gamepad.gamepadConnected().then(end);
      addon.settings.addEventListener("change", listener);
    });
  }

  const renderer = vm.runtime.renderer;
  const width = renderer._xRight - renderer._xLeft;
  const height = renderer._yTop - renderer._yBottom;
  const canvas = renderer.canvas;
  const container = document.createElement("div");
  container.className = "sa-gamepad-container";
  addon.tab.displayNoneWhileDisabled(container, {
    display: "flex"
  });
  const buttonContainer = document.createElement("span");
  buttonContainer.className = addon.tab.scratchClass("button_outlined-button", "stage-header_stage-button");
  const buttonContent = document.createElement("div");
  buttonContent.className = addon.tab.scratchClass("button_content");
  const buttonImage = document.createElement("img");
  buttonImage.className = addon.tab.scratchClass("stage-header_stage-button-icon");
  buttonImage.draggable = false;
  buttonImage.src = _twGetAsset("/gamepad.svg");
  buttonContent.appendChild(buttonImage);
  buttonContainer.appendChild(buttonContent);
  container.appendChild(buttonContainer);
  const spacer = document.createElement("div");
  spacer.className = "sa-gamepad-spacer";
  let editor;
  let shouldStoreSettingsInProject = false;

  const didChangeProject = () => {
    vm.runtime.emitProjectChanged();

    if (vm.editingTarget === vm.runtime.getTargetForStage()) {
      vm.emitWorkspaceUpdate();
    }
  };

  const storeMappings = () => {
    const exported = editor.export();

    if (!exported) {
      console.warn("Could not export gamepad settings");
      return;
    }

    const text = "".concat(msg("config-header"), "\n").concat(JSON.stringify(exported)).concat(GAMEPAD_CONFIG_MAGIC);
    const existingComment = findOptionsComment();

    if (existingComment) {
      existingComment.text = text;
    } else {
      const target = vm.runtime.getTargetForStage();
      target.createComment( // comment ID, just has to be a random string
      Math.random() + "", // block ID
      null, // text
      text, // x, y, width, height
      50, 50, 350, 150, // minimized
      false);
    }

    didChangeProject();
  };

  const removeMappings = () => {
    const comment = findOptionsComment();

    if (comment) {
      const target = vm.runtime.getTargetForStage();
      delete target.comments[comment.id];
      didChangeProject();
    }
  };

  const handleEditorChanged = () => {
    if (shouldStoreSettingsInProject) {
      storeMappings();
    }
  };

  const handleStoreSettingsCheckboxChanged = e => {
    shouldStoreSettingsInProject = !!e.target.checked;

    if (shouldStoreSettingsInProject) {
      storeMappings();
    } else {
      removeMappings();
    }
  };

  const handleEditorControllerChanged = () => {
    document.body.classList.toggle("sa-gamepad-has-controller", editor.hasControllerSelected());
    handleEditorChanged();
  };

  buttonContainer.addEventListener("click", () => {
    if (!editor) {
      editor = gamepad.editor();
      editor.msg = msg;
      editor.addEventListener("mapping-changed", handleEditorChanged);
      editor.addEventListener("gamepad-changed", handleEditorControllerChanged);
    }

    const editorEl = editor.generateEditor();
    handleEditorControllerChanged();

    const close = () => {
      modalOverlay.remove();
      document.body.removeEventListener("click", handleClickOutside, true);
      window.removeEventListener("keydown", handleKeyDown);
      addon.self.removeEventListener("disabled", close);
      editor.hide();
    };

    const handleClickOutside = e => {
      if (!modalContentContainer.contains(e.target)) {
        close();
      }
    };

    const handleKeyDown = e => {
      if (e.key === "Escape" && !e.target.closest("[data-accepting-input]")) {
        close();
      }
    };

    document.body.addEventListener("click", handleClickOutside, true);
    window.addEventListener("keydown", handleKeyDown);
    addon.self.addEventListener("disabled", close);
    const modalOverlay = document.createElement("div");
    modalOverlay.className = addon.tab.scratchClass("modal_modal-overlay", {
      others: "sa-gamepad-popup-outer"
    });
    const modalContentContainer = document.createElement("div");
    modalContentContainer.className = addon.tab.scratchClass("modal_modal-content", {
      others: "sa-gamepad-popup"
    });
    const modalHeaderContainer = document.createElement("div");
    modalHeaderContainer.className = addon.tab.scratchClass("modal_header");
    const modalHeaderText = document.createElement("div");
    modalHeaderText.className = addon.tab.scratchClass("modal_header-item", "modal_header-item-title");
    modalHeaderText.textContent = msg("settings");
    modalHeaderContainer.appendChild(modalHeaderText);
    const closeContainer = document.createElement("div");
    closeContainer.className = addon.tab.scratchClass("modal_header-item", "modal_header-item-close");
    const closeButton = document.createElement("div");
    closeButton.className = addon.tab.scratchClass("close-button_close-button", "close-button_large");
    closeButton.tabIndex = "0";
    closeButton.setAttribute("role", "button");
    const closeImage = document.createElement("img");
    closeImage.className = addon.tab.scratchClass("close-button_close-icon");
    closeImage.src = _twGetAsset("/close.svg");
    closeButton.appendChild(closeImage);
    closeContainer.appendChild(closeButton);
    modalHeaderContainer.appendChild(closeContainer);
    closeButton.addEventListener("click", close);
    const modalContent = document.createElement("div");
    modalContent.className = "sa-gamepad-popup-content";

    if (_gamepadlib_js__WEBPACK_IMPORTED_MODULE_5__["default"].browserHasBrokenGamepadAPI()) {
      const warning = document.createElement("div");
      warning.textContent = msg("browser-support");
      warning.className = "sa-gamepad-browser-support-warning";
      modalContent.appendChild(warning);
    }

    modalContent.appendChild(editorEl);
    const storeSettingsLabel = document.createElement("label");
    storeSettingsLabel.className = "sa-gamepad-store-settings";
    storeSettingsLabel.textContent = msg("store-in-project");
    const storeSettingsCheckbox = document.createElement("input");
    storeSettingsCheckbox.type = "checkbox";
    storeSettingsCheckbox.checked = shouldStoreSettingsInProject;
    storeSettingsCheckbox.addEventListener("change", handleStoreSettingsCheckboxChanged);
    storeSettingsLabel.prepend(storeSettingsCheckbox);
    modalContent.appendChild(storeSettingsLabel);
    modalContentContainer.appendChild(modalHeaderContainer);
    modalContentContainer.appendChild(modalContent);
    modalOverlay.appendChild(modalContentContainer);
    document.body.appendChild(modalOverlay);
    editor.focus();
  });

  if (addon.tab.redux.state && addon.tab.redux.state.scratchGui.stageSize.stageSize === "small") {
    document.body.classList.add("sa-gamepad-small");
  }

  document.addEventListener("click", e => {
    if (e.target.closest("[class*='stage-header_stage-button-first']")) {
      document.body.classList.add("sa-gamepad-small");
    } else if (e.target.closest("[class*='stage-header_stage-button-last']")) {
      document.body.classList.remove("sa-gamepad-small");
    }
  }, {
    capture: true
  });
  const virtualCursorElement = document.createElement("img");
  virtualCursorElement.hidden = true;
  virtualCursorElement.className = "sa-gamepad-cursor";
  virtualCursorElement.src = _twGetAsset("/cursor.png");
  addon.self.addEventListener("disabled", () => {
    virtualCursorElement.hidden = true;
  });
  let hideCursorTimeout;

  const hideRealCursor = () => {
    document.body.classList.add("sa-gamepad-hide-cursor");
  };

  const showRealCursor = () => {
    document.body.classList.remove("sa-gamepad-hide-cursor");
  };

  const virtualCursorSetVisible = visible => {
    virtualCursorElement.hidden = !visible;
    clearTimeout(hideCursorTimeout);

    if (visible) {
      hideRealCursor();
      hideCursorTimeout = setTimeout(virtualCursorHide, 8000);
    }
  };

  const virtualCursorHide = () => {
    virtualCursorSetVisible(false);
  };

  const virtualCursorSetDown = down => {
    virtualCursorSetVisible(true);
    virtualCursorElement.classList.toggle("sa-gamepad-cursor-down", down);
  };

  const virtualCursorSetPosition = (x, y) => {
    virtualCursorSetVisible(true);
    const CURSOR_SIZE = 6;
    const stageX = width / 2 + x - CURSOR_SIZE / 2;
    const stageY = height / 2 - y - CURSOR_SIZE / 2;
    virtualCursorElement.style.transform = "translate(".concat(stageX, "px, ").concat(stageY, "px)");
  };

  document.addEventListener("mousemove", () => {
    virtualCursorSetVisible(false);
    showRealCursor();
  });
  let getCanvasSize; // Support modern ResizeObserver and slow getBoundingClientRect version for improved browser support (matters for TurboWarp)

  if (window.ResizeObserver) {
    let canvasWidth = width;
    let canvasHeight = height;
    const resizeObserver = new ResizeObserver(entries => {
      for (const entry of entries) {
        canvasWidth = entry.contentRect.width;
        canvasHeight = entry.contentRect.height;
      }
    });
    resizeObserver.observe(canvas);

    getCanvasSize = () => [canvasWidth, canvasHeight];
  } else {
    getCanvasSize = () => {
      const rect = canvas.getBoundingClientRect();
      return [rect.width, rect.height];
    };
  } // Both in Scratch space


  let virtualX = 0;
  let virtualY = 0;

  const postMouseData = data => {
    if (addon.self.disabled || !vmStarted()) return;
    const [rectWidth, rectHeight] = getCanvasSize();
    vm.postIOData("mouse", _objectSpread(_objectSpread({}, data), {}, {
      canvasWidth: rectWidth,
      canvasHeight: rectHeight,
      x: (virtualX + width / 2) * (rectWidth / width),
      y: (height / 2 - virtualY) * (rectHeight / height)
    }));
  };

  const postKeyboardData = (key, isDown) => {
    if (addon.self.disabled || !vmStarted()) return;
    vm.postIOData("keyboard", {
      key,
      isDown
    });
  };

  const handleGamepadButtonDown = e => postKeyboardData(e.detail, true);

  const handleGamepadButtonUp = e => postKeyboardData(e.detail, false);

  const handleGamepadMouseDown = () => {
    virtualCursorSetDown(true);
    postMouseData({
      isDown: true
    });
  };

  const handleGamepadMouseUp = () => {
    virtualCursorSetDown(false);
    postMouseData({
      isDown: false
    });
  };

  const handleGamepadMouseMove = e => {
    virtualX = e.detail.x;
    virtualY = e.detail.y;
    virtualCursorSetPosition(virtualX, virtualY);
    postMouseData({});
  };

  gamepad.virtualCursor.maxX = renderer._xRight;
  gamepad.virtualCursor.minX = renderer._xLeft;
  gamepad.virtualCursor.maxY = renderer._yTop;
  gamepad.virtualCursor.minY = renderer._yBottom;
  gamepad.addEventListener("keydown", handleGamepadButtonDown);
  gamepad.addEventListener("keyup", handleGamepadButtonUp);
  gamepad.addEventListener("mousedown", handleGamepadMouseDown);
  gamepad.addEventListener("mouseup", handleGamepadMouseUp);
  gamepad.addEventListener("mousemove", handleGamepadMouseMove);

  while (true) {
    const target = await addon.tab.waitForElement('[class^="stage-header_stage-size-row"], [class^="stage-header_stage-menu-wrapper"] > [class^="button_outlined-button"]', {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "scratch-gui/mode/SET_FULL_SCREEN", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });
    container.dataset.editorMode = addon.tab.editorMode;

    if (target.className.includes("stage-size-row")) {
      target.insertBefore(container, target.firstChild);
      spacer.remove();
    } else {
      spacer.appendChild(container);
      target.parentElement.insertBefore(spacer, target);
    }

    const monitorListScaler = document.querySelector("[class^='monitor-list_monitor-list-scaler']");
    monitorListScaler.appendChild(virtualCursorElement);
  }
});

/***/ }),

/***/ "./src/addons/addons/hide-flyout/lock.svg":
/*!************************************************!*\
  !*** ./src/addons/addons/hide-flyout/lock.svg ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/0bf9d7356bf6bc4fb28a7e4e8338757a.svg";

/***/ }),

/***/ "./src/addons/addons/hide-flyout/unlock.svg":
/*!**************************************************!*\
  !*** ./src/addons/addons/hide-flyout/unlock.svg ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/b45bc220e004b6343d1a2e1abd9e313a.svg";

/***/ }),

/***/ "./src/addons/addons/hide-flyout/userscript.js":
/*!*****************************************************!*\
  !*** ./src/addons/addons/hide-flyout/userscript.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lock_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lock.svg */ "./src/addons/addons/hide-flyout/lock.svg");
/* harmony import */ var _lock_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lock_svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _unlock_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unlock.svg */ "./src/addons/addons/hide-flyout/unlock.svg");
/* harmony import */ var _unlock_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_unlock_svg__WEBPACK_IMPORTED_MODULE_1__);
/* inserted by pull.js */



const _twGetAsset = path => {
  if (path === "/lock.svg") return _lock_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  if (path === "/unlock.svg") return _unlock_svg__WEBPACK_IMPORTED_MODULE_1___default.a;
  throw new Error("Unknown asset: ".concat(path));
};

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  let placeHolderDiv = null;
  let lockDisplay = null;
  let flyOut = null;
  let scrollBar = null;
  let toggle = true;
  let selectedCategory = null;
  let toggleSetting = addon.settings.get("toggle");
  let flyoutLock = false;

  function getSpeedValue() {
    let data = {
      none: "0",
      short: "0.25",
      default: "0.5",
      long: "1"
    };
    return data[addon.settings.get("speed")];
  }

  function onmouseenter(speed = {}) {
    speed = typeof speed === "object" ? getSpeedValue() : speed;
    flyOut.classList.remove("sa-flyoutClose");
    flyOut.style.transitionDuration = "".concat(speed, "s");
    scrollBar.classList.remove("sa-flyoutClose");
    scrollBar.style.transitionDuration = "".concat(speed, "s");
    lockDisplay.classList.remove("sa-flyoutClose");
    lockDisplay.style.transitionDuration = "".concat(speed, "s");
    setTimeout(() => Blockly.getMainWorkspace().recordCachedAreas(), speed * 1000);
  }

  function onmouseleave(e, speed = getSpeedValue()) {
    // If we go behind the flyout or the user has locked it, let's return
    if (toggleSetting !== "cathover" && e && e.clientX <= scrollBar.getBoundingClientRect().left || flyoutLock) return;
    flyOut.classList.add("sa-flyoutClose");
    flyOut.style.transitionDuration = "".concat(speed, "s");
    scrollBar.classList.add("sa-flyoutClose");
    scrollBar.style.transitionDuration = "".concat(speed, "s");
    lockDisplay.classList.add("sa-flyoutClose");
    lockDisplay.style.transitionDuration = "".concat(speed, "s");
    setTimeout(() => Blockly.getMainWorkspace().recordCachedAreas(), speed * 1000);
  }

  let didOneTimeSetup = false;

  function doOneTimeSetup() {
    if (didOneTimeSetup) {
      return;
    }

    didOneTimeSetup = true;
    addon.tab.redux.initialize();
    addon.tab.redux.addEventListener("statechanged", e => {
      switch (e.detail.action.type) {
        // Event casted when you switch between tabs
        case "scratch-gui/navigation/ACTIVATE_TAB":
          // always 0, 1, 2
          lockDisplay.style.display = e.detail.action.activeTabIndex === 0 ? "block" : "none";
          placeHolderDiv.style.display = e.detail.action.activeTabIndex === 0 ? "block" : "none";

          if (e.detail.action.activeTabIndex === 0) {
            onmouseenter(0);
            toggle = true;
          }

          break;
        // Event casted when you switch between tabs

        case "scratch-gui/mode/SET_PLAYER":
          // always true or false
          lockDisplay.style.display = e.detail.action.isPlayerOnly ? "none" : "block";
          placeHolderDiv.style.display = e.detail.action.activeTabIndex === 0 ? "block" : "none";
          break;
      }
    });

    if (toggleSetting === "category" || toggleSetting === "cathover") {
      (async () => {
        while (true) {
          let category = await addon.tab.waitForElement(".scratchCategoryMenuItem", {
            markAsSeen: true,
            condition: () => !addon.tab.redux.state.scratchGui.mode.isPlayerOnly
          });

          category.onclick = () => {
            if (toggle && selectedCategory === category && toggleSetting === "category") {
              onmouseleave();
              selectedCategory = category;
            } else if (!toggle) {
              onmouseenter();
              selectedCategory = category;
            } else {
              selectedCategory = category;
              return;
            }

            if (toggleSetting === "category") toggle = !toggle;
          };

          if (toggleSetting === "cathover") {
            category.onmouseover = onmouseenter;
            flyOut.onmouseleave = onmouseleave;
          }
        }
      })();
    }
  }

  while (true) {
    flyOut = await addon.tab.waitForElement(".blocklyFlyout", {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"],
      reduxCondition: state => !state.scratchGui.mode.isPlayerOnly
    });
    let blocklySvg = document.querySelector(".blocklySvg");
    scrollBar = document.querySelector(".blocklyFlyoutScrollbar");
    const tabs = document.querySelector('[class^="gui_tabs"]'); // Placeholder Div

    if (placeHolderDiv) placeHolderDiv.remove();
    placeHolderDiv = document.createElement("div");
    if (toggleSetting === "hover") tabs.appendChild(placeHolderDiv);
    placeHolderDiv.className = "sa-flyout-placeHolder"; // Lock Img

    if (lockDisplay) lockDisplay.remove();
    lockDisplay = document.createElement("img");
    lockDisplay.src = _twGetAsset("/".concat(flyoutLock ? "" : "un", "lock.svg"));
    lockDisplay.className = "sa-lock-image";

    lockDisplay.onclick = () => {
      flyoutLock = !flyoutLock;
      lockDisplay.src = _twGetAsset("/".concat(flyoutLock ? "" : "un", "lock.svg"));
    }; // Only append if we don't have "categoryclick" on


    if (toggleSetting === "hover") tabs.appendChild(lockDisplay);

    if (toggleSetting === "hover") {
      placeHolderDiv.onmouseenter = onmouseenter;
      blocklySvg.onmouseenter = onmouseleave;
    }

    if (toggleSetting === "cathover") onmouseleave(null, 0);
    doOneTimeSetup();
  }
});

/***/ }),

/***/ "./src/addons/addons/initialise-sprite-position/userscript.js":
/*!********************************************************************!*\
  !*** ./src/addons/addons/initialise-sprite-position/userscript.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon
}) {
  let vm = addon.tab.traps.vm;
  let oldAddSprite = vm.constructor.prototype.addSprite;

  vm.constructor.prototype.addSprite = function (input) {
    var _spriteObj$costumes, _spriteObj$costumes$;

    let spriteObj,
        stringify = true;
    if (typeof input === "object") [spriteObj, stringify] = [input, false];else spriteObj = JSON.parse(input);
    let isEmpty = ((_spriteObj$costumes = spriteObj.costumes) === null || _spriteObj$costumes === void 0 ? void 0 : (_spriteObj$costumes$ = _spriteObj$costumes[0]) === null || _spriteObj$costumes$ === void 0 ? void 0 : _spriteObj$costumes$.baseLayerMD5) === "cd21514d0531fdffb22204e0ec5ed84a.svg";

    if (isEmpty || !spriteObj.tags || !addon.settings.get("library")) {
      if (spriteObj.scratchX) {
        spriteObj.scratchX = addon.settings.get("x");
        spriteObj.scratchY = addon.settings.get("y");
      }

      if (spriteObj.x) {
        spriteObj.x = addon.settings.get("x");
        spriteObj.y = addon.settings.get("y");
      }
    }

    return oldAddSprite.call(this, stringify ? JSON.stringify(spriteObj) : spriteObj);
  };
});

/***/ }),

/***/ "./src/addons/addons/load-extensions/userscript.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/load-extensions/userscript.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  // IDs are taken from https://github.com/LLK/scratch-vm/blob/ffa78b91b8645b6a8c80f698a3637bb73abf2931/src/extension-support/extension-manager.js#L11
  const Extensions = ["music", "pen", "text2speech", "translate"];

  for (let ext of Extensions) {
    // Check if setting enabled and it's not already loaded
    if (addon.settings.get(ext) && !addon.tab.traps.vm.extensionManager.isExtensionLoaded(ext)) {
      addon.tab.traps.vm.extensionManager.loadExtensionIdSync(ext);
    }
  }
});

/***/ }),

/***/ "./src/addons/addons/mediarecorder/userscript.js":
/*!*******************************************************!*\
  !*** ./src/addons/addons/mediarecorder/userscript.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libraries_common_cs_download_blob_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libraries/common/cs/download-blob.js */ "./src/addons/libraries/common/cs/download-blob.js");

/* harmony default export */ __webpack_exports__["default"] = (async ({
  addon,
  console,
  msg
}) => {
  // Safari supports mp4 but not webm
  const CHECK_TYPES = ["video/webm", "video/mp4"];
  const supportedVideoType = CHECK_TYPES.find(i => MediaRecorder.isTypeSupported(i));
  if (!supportedVideoType) throw new Error("no video types supported");
  let recordElem;
  let isRecording = false;
  let isWaitingForFlag = false;
  let waitingForFlagFunc = null;
  let abortController = null;
  let stopSignFunc = null;
  let recordBuffer = [];
  let recorder;
  let timeout;

  while (true) {
    const elem = await addon.tab.waitForElement('div[class*="menu-bar_file-group"] > div:last-child:not(.sa-record)', {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });

    const getOptions = () => {
      const recordOption = Object.assign(document.createElement("div"), {
        className: addon.tab.scratchClass("modal_modal-overlay")
      });
      const recordOptionPopup = Object.assign(document.createElement("div"), {
        className: addon.tab.scratchClass("modal_modal-content", {
          others: "mediaRecorderPopup"
        }),
        dir: addon.tab.direction
      });
      const recordOptionHeader = Object.assign(document.createElement("div"), {
        className: addon.tab.scratchClass("modal_header")
      });
      recordOptionHeader.appendChild(Object.assign(document.createElement("div"), {
        className: addon.tab.scratchClass("modal_header-item", "modal_header-item-title"),
        textContent: msg("option-title")
      }));
      recordOptionPopup.appendChild(recordOptionHeader);
      const recordOptionInner = Object.assign(document.createElement("div"), {
        className: "mediaRecorderPopupContent"
      });
      recordOptionInner.appendChild(Object.assign(document.createElement("p"), {
        textContent: supportedVideoType === "video/webm" ? msg("record-description") : msg("record-description").replace("WebM", "MP4"),
        className: "recordOptionDescription"
      })); // Seconds

      const recordOptionSeconds = document.createElement("p");
      const recordOptionSecondsInput = Object.assign(document.createElement("input"), {
        type: "number",
        min: 1,
        max: 300,
        defaultValue: 30,
        id: "recordOptionSecondsInput",
        className: addon.tab.scratchClass("prompt_variable-name-text-input")
      });
      const recordOptionSecondsLabel = Object.assign(document.createElement("label"), {
        htmlFor: "recordOptionSecondsInput",
        textContent: msg("record-duration")
      });
      recordOptionSeconds.appendChild(recordOptionSecondsLabel);
      recordOptionSeconds.appendChild(recordOptionSecondsInput);
      recordOptionInner.appendChild(recordOptionSeconds); // Audio

      const recordOptionAudio = document.createElement("p");
      const recordOptionAudioInput = Object.assign(document.createElement("input"), {
        type: "checkbox",
        defaultChecked: true,
        id: "recordOptionAudioInput"
      });
      const recordOptionAudioLabel = Object.assign(document.createElement("label"), {
        htmlFor: "recordOptionAudioInput",
        textContent: msg("record-audio"),
        title: msg("record-audio-description")
      });
      recordOptionAudio.appendChild(recordOptionAudioInput);
      recordOptionAudio.appendChild(recordOptionAudioLabel);
      recordOptionInner.appendChild(recordOptionAudio); // Mic

      const recordOptionMic = document.createElement("p");
      const recordOptionMicInput = Object.assign(document.createElement("input"), {
        type: "checkbox",
        defaultChecked: false,
        id: "recordOptionMicInput"
      });
      const recordOptionMicLabel = Object.assign(document.createElement("label"), {
        htmlFor: "recordOptionMicInput",
        textContent: msg("record-mic")
      });
      recordOptionMic.appendChild(recordOptionMicInput);
      recordOptionMic.appendChild(recordOptionMicLabel);
      recordOptionInner.appendChild(recordOptionMic); // Green flag

      const recordOptionFlag = document.createElement("p");
      const recordOptionFlagInput = Object.assign(document.createElement("input"), {
        type: "checkbox",
        defaultChecked: true,
        id: "recordOptionFlagInput"
      });
      const recordOptionFlagLabel = Object.assign(document.createElement("label"), {
        htmlFor: "recordOptionFlagInput",
        textContent: msg("record-after-flag")
      });
      recordOptionFlag.appendChild(recordOptionFlagInput);
      recordOptionFlag.appendChild(recordOptionFlagLabel);
      recordOptionInner.appendChild(recordOptionFlag); // Stop sign

      const recordOptionStop = document.createElement("p");
      const recordOptionStopInput = Object.assign(document.createElement("input"), {
        type: "checkbox",
        defaultChecked: true,
        id: "recordOptionStopInput"
      });
      const recordOptionStopLabel = Object.assign(document.createElement("label"), {
        htmlFor: "recordOptionStopInput",
        textContent: msg("record-until-stop")
      });
      recordOptionFlagInput.addEventListener("change", () => {
        const disabled = recordOptionStopInput.disabled = !recordOptionFlagInput.checked;

        if (disabled) {
          recordOptionStopLabel.title = msg("record-until-stop-disabled", {
            afterFlagOption: msg("record-after-flag")
          });
        }
      });
      recordOptionStop.appendChild(recordOptionStopInput);
      recordOptionStop.appendChild(recordOptionStopLabel);
      recordOptionInner.appendChild(recordOptionStop);
      let resolvePromise = null;
      const optionPromise = new Promise(resolve => {
        resolvePromise = resolve;
      });
      let handleOptionClose = null;

      const handleClickOutside = e => {
        if (recordOptionPopup.contains(e.target)) return;
        handleOptionClose(null);
      };

      document.body.addEventListener("click", handleClickOutside, {
        capture: true
      });

      handleOptionClose = value => {
        resolvePromise(value);
        document.body.removeEventListener("click", handleClickOutside, {
          capture: true
        });
        recordOption.remove();
      };

      const buttonRow = Object.assign(document.createElement("div"), {
        className: addon.tab.scratchClass("prompt_button-row", {
          others: "mediaRecorderPopupButtons"
        })
      });
      const cancelButton = Object.assign(document.createElement("button"), {
        textContent: msg("cancel")
      });
      cancelButton.addEventListener("click", () => handleOptionClose(null), {
        once: true
      });
      buttonRow.appendChild(cancelButton);
      const startButton = Object.assign(document.createElement("button"), {
        textContent: msg("start"),
        className: addon.tab.scratchClass("prompt_ok-button")
      });
      startButton.addEventListener("click", () => handleOptionClose({
        secs: Number(recordOptionSecondsInput.value),
        audioEnabled: recordOptionAudioInput.checked,
        micEnabled: recordOptionMicInput.checked,
        waitUntilFlag: recordOptionFlagInput.checked,
        useStopSign: !recordOptionStopInput.disabled && recordOptionStopInput.checked
      }), {
        once: true
      });
      buttonRow.appendChild(startButton);
      recordOptionInner.appendChild(buttonRow);
      recordOptionPopup.appendChild(recordOptionInner);
      recordOption.appendChild(recordOptionPopup);
      document.body.appendChild(recordOption);
      return optionPromise;
    };

    const disposeRecorder = () => {
      isRecording = false;
      recordElem.textContent = msg("record");
      recordElem.title = "";
      recorder = null;
      recordBuffer = [];
      clearTimeout(timeout);
      timeout = 0;

      if (stopSignFunc) {
        addon.tab.traps.vm.runtime.off("PROJECT_STOP_ALL", stopSignFunc);
        stopSignFunc = null;
      }
    };

    const stopRecording = force => {
      if (isWaitingForFlag) {
        addon.tab.traps.vm.runtime.off("PROJECT_START", waitingForFlagFunc);
        isWaitingForFlag = false;
        waitingForFlagFunc = null;
        abortController.abort();
        abortController = null;
        disposeRecorder();
        return;
      }

      if (!isRecording || !recorder || recorder.state === "inactive") return;

      if (force) {
        disposeRecorder();
      } else {
        recorder.onstop = () => {
          const blob = new Blob(recordBuffer, {
            type: supportedVideoType
          });
          Object(_libraries_common_cs_download_blob_js__WEBPACK_IMPORTED_MODULE_0__["default"])("video." + supportedVideoType.split("/")[1], blob);
          disposeRecorder();
        };

        recorder.stop();
      }
    };

    const startRecording = async opts => {
      // Timer
      const secs = Math.min(300, Math.max(1, opts.secs)); // Initialize MediaRecorder

      recordBuffer = [];
      isRecording = true;
      const vm = addon.tab.traps.vm;
      let micStream;

      if (opts.micEnabled) {
        // Show permission dialog before green flag is clicked
        try {
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: true
          });
        } catch (e) {
          if (e.name !== "NotAllowedError" && e.name !== "NotFoundError") throw e;
          opts.micEnabled = false;
        }
      }

      if (opts.waitUntilFlag) {
        isWaitingForFlag = true;
        Object.assign(recordElem, {
          textContent: msg("click-flag"),
          title: msg("click-flag-description")
        });
        abortController = new AbortController();

        try {
          await Promise.race([new Promise(resolve => {
            waitingForFlagFunc = () => resolve();

            vm.runtime.once("PROJECT_START", waitingForFlagFunc);
          }), new Promise((_, reject) => {
            abortController.signal.addEventListener("abort", () => reject("aborted"), {
              once: true
            });
          })]);
        } catch (e) {
          if (e.message === "aborted") return;
          throw e;
        }
      }

      recordElem.textContent = msg("stop");
      isWaitingForFlag = false;
      waitingForFlagFunc = abortController = null;
      const stream = new MediaStream();
      const videoStream = vm.runtime.renderer.canvas.captureStream();
      stream.addTrack(videoStream.getVideoTracks()[0]);
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const dest = ctx.createMediaStreamDestination();

      if (opts.audioEnabled) {
        const mediaStreamDestination = vm.runtime.audioEngine.audioContext.createMediaStreamDestination();
        vm.runtime.audioEngine.inputNode.connect(mediaStreamDestination);
        const audioSource = ctx.createMediaStreamSource(mediaStreamDestination.stream);
        audioSource.connect(dest);
      }

      if (opts.micEnabled) {
        const micSource = ctx.createMediaStreamSource(micStream);
        micSource.connect(dest);
      }

      if (opts.audioEnabled || opts.micEnabled) {
        stream.addTrack(dest.stream.getAudioTracks()[0]);
      }

      recorder = new MediaRecorder(stream, {
        mimeType: supportedVideoType
      });

      recorder.ondataavailable = e => {
        recordBuffer.push(e.data);
      };

      recorder.onerror = e => {
        console.warn("Recorder error:", e.error);
        stopRecording(true);
      };

      timeout = setTimeout(() => stopRecording(false), secs * 1000);

      if (opts.useStopSign) {
        stopSignFunc = () => stopRecording();

        vm.runtime.once("PROJECT_STOP_ALL", stopSignFunc);
      }

      recorder.start(1000);
    };

    if (!recordElem) {
      recordElem = Object.assign(document.createElement("div"), {
        className: "sa-record " + elem.className,
        textContent: msg("record")
      });
      recordElem.addEventListener("click", async () => {
        if (isRecording) {
          stopRecording();
        } else {
          const opts = await getOptions();

          if (!opts) {
            console.log("Canceled");
            return;
          }

          startRecording(opts);
        }
      });
    }

    elem.parentElement.appendChild(recordElem);
  }
});

/***/ }),

/***/ "./src/addons/addons/mouse-pos/userscript.js":
/*!***************************************************!*\
  !*** ./src/addons/addons/mouse-pos/userscript.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  var posContainerContainer = document.createElement("div");
  addon.tab.displayNoneWhileDisabled(posContainerContainer, {
    display: "flex"
  });
  var posContainer = document.createElement("div");
  var pos = document.createElement("span");
  posContainerContainer.className = "pos-container-container";
  posContainer.className = "pos-container";
  posContainerContainer.appendChild(posContainer);
  posContainer.appendChild(pos);
  const vm = addon.tab.traps.vm;
  vm.runtime.ioDevices.mouse.__scratchX = vm.runtime.ioDevices.mouse._scratchX;
  vm.runtime.ioDevices.mouse.__scratchY = vm.runtime.ioDevices.mouse._scratchY;
  var x = vm.runtime.ioDevices.mouse.__scratchX ? vm.runtime.ioDevices.mouse.__scratchX : 0;
  var y = vm.runtime.ioDevices.mouse.__scratchY ? vm.runtime.ioDevices.mouse.__scratchY : 0;

  const showUpdatedValue = () => pos.setAttribute("data-content", "".concat(x, ", ").concat(y));

  Object.defineProperty(vm.runtime.ioDevices.mouse, "_scratchX", {
    get: function get() {
      return this.__scratchX;
    },
    set: function set(setx) {
      x = setx;
      showUpdatedValue();
      this.__scratchX = setx;
    }
  });
  Object.defineProperty(vm.runtime.ioDevices.mouse, "_scratchY", {
    get: function get() {
      return this.__scratchY;
    },
    set: function set(sety) {
      y = sety;
      showUpdatedValue();
      this.__scratchY = sety;
    }
  });

  if (addon.tab.redux.state && addon.tab.redux.state.scratchGui.stageSize.stageSize === "small") {
    document.body.classList.add("sa-mouse-pos-small");
  }

  document.addEventListener("click", e => {
    if (e.target.closest("[class*='stage-header_stage-button-first']")) {
      document.body.classList.add("sa-mouse-pos-small");
    } else if (e.target.closest("[class*='stage-header_stage-button-last']")) {
      document.body.classList.remove("sa-mouse-pos-small");
    }
  }, {
    capture: true
  });

  while (true) {
    let bar = await addon.tab.waitForElement('[class*="controls_controls-container"]', {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });

    if (addon.tab.editorMode === "editor") {
      bar.appendChild(posContainerContainer);
    }
  }
});

/***/ }),

/***/ "./src/addons/addons/mute-project/icon--mute.svg":
/*!*******************************************************!*\
  !*** ./src/addons/addons/mute-project/icon--mute.svg ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/ae4b22decf2fde68ad23fd36c48c455e.svg";

/***/ }),

/***/ "./src/addons/addons/mute-project/userscript.js":
/*!******************************************************!*\
  !*** ./src/addons/addons/mute-project/userscript.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _icon_mute_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon--mute.svg */ "./src/addons/addons/mute-project/icon--mute.svg");
/* harmony import */ var _icon_mute_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_icon_mute_svg__WEBPACK_IMPORTED_MODULE_0__);
/* inserted by pull.js */


const _twGetAsset = path => {
  if (path === "/icon--mute.svg") return _icon_mute_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  throw new Error("Unknown asset: ".concat(path));
};

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console
}) {
  const vm = addon.tab.traps.vm;
  let muted = false;
  let icon = document.createElement("img");
  icon.loading = "lazy";
  icon.src = _twGetAsset("/icon--mute.svg");
  icon.style.display = "none";

  const toggleMute = e => {
    if (e.ctrlKey) {
      e.cancelBubble = true;
      e.preventDefault();

      if (e.type === "contextmenu" && window.safari) {
        return;
      }

      muted = !muted;

      if (muted) {
        vm.runtime.audioEngine.inputNode.gain.value = 0;
        icon.style.display = "block";
      } else {
        vm.runtime.audioEngine.inputNode.gain.value = 1;
        icon.style.display = "none";
      }
    }
  };

  while (true) {
    let button = await addon.tab.waitForElement("[class^='green-flag_green-flag']", {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });
    let container = button.parentElement;
    container.appendChild(icon);
    button.addEventListener("click", toggleMute);
    button.addEventListener("contextmenu", toggleMute);
  }
});

/***/ }),

/***/ "./src/addons/addons/onion-skinning/decrement.svg":
/*!********************************************************!*\
  !*** ./src/addons/addons/onion-skinning/decrement.svg ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/d1b20b63da0e8727a5af2aa5768c0b1a.svg";

/***/ }),

/***/ "./src/addons/addons/onion-skinning/increment.svg":
/*!********************************************************!*\
  !*** ./src/addons/addons/onion-skinning/increment.svg ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/05259a52e79f7f0a1bad7bef71d3bbbb.svg";

/***/ }),

/***/ "./src/addons/addons/onion-skinning/settings.svg":
/*!*******************************************************!*\
  !*** ./src/addons/addons/onion-skinning/settings.svg ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/845fea9bdf5fa6c5de3934d64db8adba.svg";

/***/ }),

/***/ "./src/addons/addons/onion-skinning/toggle.svg":
/*!*****************************************************!*\
  !*** ./src/addons/addons/onion-skinning/toggle.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/8b63eff046ba87acfd02c86e631a2d6d.svg";

/***/ }),

/***/ "./src/addons/addons/onion-skinning/userscript.js":
/*!********************************************************!*\
  !*** ./src/addons/addons/onion-skinning/userscript.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _decrement_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decrement.svg */ "./src/addons/addons/onion-skinning/decrement.svg");
/* harmony import */ var _decrement_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_decrement_svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _increment_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./increment.svg */ "./src/addons/addons/onion-skinning/increment.svg");
/* harmony import */ var _increment_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_increment_svg__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _settings_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.svg */ "./src/addons/addons/onion-skinning/settings.svg");
/* harmony import */ var _settings_svg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_settings_svg__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _toggle_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toggle.svg */ "./src/addons/addons/onion-skinning/toggle.svg");
/* harmony import */ var _toggle_svg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_toggle_svg__WEBPACK_IMPORTED_MODULE_3__);
/* inserted by pull.js */





const _twGetAsset = path => {
  if (path === "/decrement.svg") return _decrement_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  if (path === "/increment.svg") return _increment_svg__WEBPACK_IMPORTED_MODULE_1___default.a;
  if (path === "/settings.svg") return _settings_svg__WEBPACK_IMPORTED_MODULE_2___default.a;
  if (path === "/toggle.svg") return _toggle_svg__WEBPACK_IMPORTED_MODULE_3___default.a;
  throw new Error("Unknown asset: ".concat(path));
};

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  let paper = null;
  let paperCenter;
  const storedOnionLayers = [];

  const parseHexColor = color => {
    const hexString = color.substr(1);
    const hexNumber = parseInt(hexString, 16);
    return [hexNumber >> 16 & 0xff, // R
    hexNumber >> 8 & 0xff, // G
    hexNumber & 0xff // B
    ];
  };

  const settings = {
    enabled: addon.settings.get("default"),
    previous: +addon.settings.get("previous"),
    next: +addon.settings.get("next"),
    opacity: +addon.settings.get("opacity"),
    opacityStep: +addon.settings.get("opacityStep"),
    layering: addon.settings.get("layering"),
    mode: addon.settings.get("mode"),
    beforeTint: parseHexColor(addon.settings.get("beforeTint")),
    afterTint: parseHexColor(addon.settings.get("afterTint"))
  };

  const getProject = () => paper && paper.project;

  const foundPaper = _paper => {
    paper = _paper;
    const backgroundGuideLayer = paper.project.layers.find(i => i.data.isBackgroundGuideLayer);
    paperCenter = backgroundGuideLayer.children[0].position; // When background guide layer is added, show onion layers.
    // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/helper/layer.js#L145

    const originalAddLayer = paper.Project.prototype.addLayer;

    paper.Project.prototype.addLayer = function (layer) {
      const result = originalAddLayer.call(this, layer);

      if (layer.data.isBackgroundGuideLayer) {
        let onion;

        while (onion = storedOnionLayers.shift()) {
          originalAddLayer.call(this, onion);
        }

        relayerOnionLayers();
      }

      return result;
    }; // Scratch uses importJSON to undo or redo
    // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/helper/undo.js#L37
    // The code prior to this will remove our onion layers, so we have to manually add them back.


    const originalImportJSON = paper.Project.prototype.importJSON;

    paper.Project.prototype.importJSON = function (json) {
      const result = originalImportJSON.call(this, json);

      if (settings.enabled) {
        updateOnionLayers();
      }

      return result;
    }; // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/helper/layer.js#L114
    // When background guide layer is removed, hide onion layers.


    const originalRemoveLayer = paper.Layer.prototype.remove;

    paper.Layer.prototype.remove = function () {
      if (this.data.isBackgroundGuideLayer) {
        for (const layer of paper.project.layers) {
          if (layer.data.sa_isOnionLayer) {
            storedOnionLayers.push(layer);
          }
        }

        for (const layer of storedOnionLayers) {
          layer.remove();
        }
      }

      return originalRemoveLayer.call(this);
    };
  };

  const foundPaperCanvas = paperCanvas => {
    let expectingImport = false;
    const PaperCanvas = paperCanvas.constructor; // importImage is called to start loading an image.
    // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L124

    const originalImportImage = PaperCanvas.prototype.importImage;

    PaperCanvas.prototype.importImage = function (...args) {
      expectingImport = true;
      removeOnionLayers();
      return originalImportImage.call(this, ...args);
    }; // recalibrateSize is called when the canvas finishes loading an image.
    // all paths of importImage will result in a call to this method.
    // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L310-L327
    // We use this to know when to add layers.


    const originalRecalibrateSize = PaperCanvas.prototype.recalibrateSize;

    PaperCanvas.prototype.recalibrateSize = function (callback) {
      return originalRecalibrateSize.call(this, () => {
        if (callback) callback();

        if (expectingImport) {
          expectingImport = false;

          if (settings.enabled) {
            updateOnionLayers();
          }
        }
      });
    }; // Prototype overrides will work for all future instances, but Scratch manually binds some methods to `this`
    // so we have to manually copy them for the current instance (but not future instances)


    paperCanvas.recalibrateSize = PaperCanvas.prototype.recalibrateSize.bind(paperCanvas);
    paperCanvas.importImage = PaperCanvas.prototype.importImage.bind(paperCanvas);
  };

  const createCanvas = (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    canvas.getContext("2d").imageSmoothingEnabled = false;
    return canvas;
  };

  const createOnionLayer = () => {
    const layer = new paper.Layer();
    layer.locked = true;
    layer.guide = true;
    layer.data.sa_isOnionLayer = true;
    return layer;
  };

  const removeOnionLayers = () => {
    const project = getProject();

    if (!project) {
      return;
    }

    storedOnionLayers.length = 0;
    const layers = project.layers; // Iterate downward because we remove items mid-iteration

    for (let i = layers.length - 1; i >= 0; i--) {
      const layer = layers[i];

      if (layer.data.sa_isOnionLayer) {
        layer.remove();
      }
    }
  };

  const relayerOnionLayers = () => {
    const project = getProject();

    if (!project) {
      return;
    }

    const onions = [];

    for (const layer of project.layers) {
      if (layer.data.sa_isOnionLayer) {
        onions.push(layer);
      }
    }

    onions.sort((a, b) => a.data.sa_onionIndex - b.data.sa_onionIndex);

    if (settings.layering === "front") {
      for (const layer of onions) {
        project.addLayer(layer);
      }
    } else {
      const rasterLayer = project.layers.find(i => i.data.isRasterLayer);

      if (rasterLayer.index === 0) {
        for (const layer of onions) {
          project.insertLayer(0, layer);
        }
      } else {
        for (const layer of onions) {
          project.insertLayer(1, layer);
        }
      }
    }
  };

  const recursePaperItem = (item, callback) => {
    if (item.children) {
      for (const child of item.children) {
        recursePaperItem(child, callback);
      }
    }

    callback(item);
  };

  const getTint = (red, green, blue, isBefore) => {
    const referenceColor = isBefore ? settings.beforeTint : settings.afterTint;
    const colorAverage = (red + green + blue) / 3 / 255;
    const WEIGHT = 1.5;
    const weighted = colorAverage / WEIGHT + (1 - 1 / WEIGHT);
    return [referenceColor[0] * weighted, referenceColor[1] * weighted, referenceColor[2] * weighted];
  };

  const toHexColor = ([red, green, blue]) => {
    const r = Math.round(red).toString(16).padStart(2, "0");
    const g = Math.round(green).toString(16).padStart(2, "0");
    const b = Math.round(blue).toString(16).padStart(2, "0");
    return "#".concat(r).concat(g).concat(b);
  };

  const getPaperColorTint = (color, isBefore) => toHexColor(getTint(color.red * 255, color.green * 255, color.blue * 255, isBefore));

  const tintRaster = (raster, isBefore) => {
    const {
      width,
      height
    } = raster.canvas;
    const context = raster.context; // TODO: check to see if this is a performance issue

    const imageData = context.getImageData(0, 0, width, height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4
    /* RGBA */
    ) {
      const red = data[i + 0];
      const green = data[i + 1];
      const blue = data[i + 2];
      const alpha = data[i + 3];

      if (alpha === 0) {
        continue;
      }

      const [newRed, newGreen, newBlue] = getTint(red, green, blue, isBefore);
      data[i + 0] = newRed;
      data[i + 1] = newGreen;
      data[i + 2] = newBlue;
    }

    context.putImageData(imageData, 0, 0);
  };

  const makeVectorLayer = (layer, costume, asset, isBefore) => new Promise((resolve, reject) => {
    const {
      rotationCenterX,
      rotationCenterY
    } = costume; // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L196-L218

    asset = asset.split(/<\s*svg:/).join("<");
    asset = asset.split(/<\/\s*svg:/).join("</");
    const svgAttrs = asset.match(/<svg [^>]*>/);

    if (svgAttrs && svgAttrs[0].indexOf("xmlns=") === -1) {
      asset = asset.replace("<svg ", '<svg xmlns="http://www.w3.org/2000/svg" ');
    }

    const parser = new DOMParser();
    const svgDom = parser.parseFromString(asset, "text/xml");
    const viewBox = svgDom.documentElement.attributes.viewBox ? svgDom.documentElement.attributes.viewBox.value.match(/\S+/g) : null;

    if (viewBox) {
      for (let i = 0; i < viewBox.length; i++) {
        viewBox[i] = parseFloat(viewBox[i]);
      }
    }

    getProject().importSVG(asset, {
      expandShapes: true,
      onLoad: root => {
        if (!root) {
          reject(new Error("could not load onion skin"));
          return;
        }

        root.remove(); // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L274-L275

        recursePaperItem(root, i => {
          if (i.className === "PathItem") {
            i.clockwise = true;
          }

          if (i.className !== "PointText" && !i.children) {
            if (i.strokeWidth) {
              i.strokeWidth = i.strokeWidth * 2;
            }
          }

          i.locked = true;
          i.guide = true;
        });
        root.scale(2, new paper.Point(0, 0));

        if (settings.mode === "tint") {
          const gradients = new Set();
          recursePaperItem(root, i => {
            if (i.strokeColor) {
              i.strokeColor = getPaperColorTint(i.strokeColor, isBefore);
            }

            if (i.fillColor) {
              const gradient = i.fillColor.gradient;

              if (gradient) {
                if (gradients.has(gradient)) return;
                gradients.add(gradient);

                for (const stop of gradient.stops) {
                  stop.color = getPaperColorTint(stop.color, isBefore);
                }
              } else {
                i.fillColor = getPaperColorTint(i.fillColor, isBefore);
              }
            }

            if (i.canvas) {
              tintRaster(i, isBefore);
            }
          });
        } // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L277-L287


        if (typeof rotationCenterX !== "undefined" && typeof rotationCenterY !== "undefined") {
          let rotationPoint = new paper.Point(rotationCenterX, rotationCenterY);

          if (viewBox && viewBox.length >= 2 && !isNaN(viewBox[0]) && !isNaN(viewBox[1])) {
            rotationPoint = rotationPoint.subtract(viewBox[0], viewBox[1]);
          }

          root.translate(paperCenter.subtract(rotationPoint.multiply(2)));
        } else {
          root.translate(paperCenter.subtract(root.bounds.width, root.bounds.height));
        }

        layer.addChild(root);
        resolve();
      }
    });
  });

  const makeRasterLayer = (layer, costume, asset, isBefore) => new Promise((resolve, reject) => {
    let {
      rotationCenterX,
      rotationCenterY
    } = costume;
    const image = new Image();

    image.onload = () => {
      const width = Math.min(paperCenter.x * 2, image.width);
      const height = Math.min(paperCenter.y * 2, image.height); // https://github.com/LLK/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L151-L156

      if (typeof rotationCenterX === "undefined") {
        rotationCenterX = width / 2;
      }

      if (typeof rotationCenterY === "undefined") {
        rotationCenterY = height / 2;
      }

      const raster = new paper.Raster(createCanvas(width, height));
      raster.parent = layer;
      raster.guide = true;
      raster.locked = true;
      const x = width / 2 + (paperCenter.x - rotationCenterX);
      const y = height / 2 + (paperCenter.y - rotationCenterY);
      raster.position = new paper.Point(x, y);
      raster.drawImage(image, 0, 0);

      if (settings.mode === "tint") {
        tintRaster(raster, isBefore);
      }

      resolve();
    };

    image.onerror = () => {
      reject(new Error("could not load image"));
    };

    image.src = asset;
  });

  const getSelectedCostumeIndex = () => {
    const item = document.querySelector("[class*='selector_list-item'][class*='sprite-selector-item_is-selected']");
    if (!item) return -1;
    const numberEl = item.querySelector("[class*='sprite-selector-item_number']");
    if (!numberEl) return -1;
    return +numberEl.textContent - 1;
  };

  const updateOnionLayers = async () => {
    const project = getProject();

    if (!project) {
      return;
    }

    const selectedCostumeIndex = getSelectedCostumeIndex();

    if (selectedCostumeIndex === -1) {
      return;
    }

    removeOnionLayers();
    const vm = addon.tab.traps.vm;

    if (!vm) {
      return;
    }

    const activeLayer = project.activeLayer;
    const costumes = vm.editingTarget.sprite.costumes;
    const startIndex = Math.max(0, selectedCostumeIndex - settings.previous);
    const endIndex = Math.min(costumes.length - 1, selectedCostumeIndex + settings.next);

    try {
      for (let i = startIndex; i <= endIndex; i++) {
        if (i === selectedCostumeIndex) {
          continue;
        }

        const isBefore = i < selectedCostumeIndex;
        const distance = Math.abs(i - selectedCostumeIndex) - 1;
        const opacity = settings.opacity - settings.opacityStep * distance;

        if (opacity <= 0) {
          continue;
        }

        const layer = createOnionLayer();
        layer.data.sa_onionIndex = i;
        layer.opacity = opacity / 100;
        relayerOnionLayers(); // Important: Make sure that we do not change the active layer of the editor as doing so can cause corruption.

        activeLayer.activate();
        const onionCostume = costumes[i];
        const onionAsset = vm.getCostume(i);

        if (onionCostume.dataFormat === "svg") {
          await makeVectorLayer(layer, onionCostume, onionAsset, isBefore);
        } else if (onionCostume.dataFormat === "png" || onionCostume.dataFormat === "jpg") {
          await makeRasterLayer(layer, onionCostume, onionAsset, isBefore);
        } else {
          throw new Error("Unknown data format: ".concat(onionCostume.dataFormat));
        }
      }
    } catch (e) {
      console.error(e);
    } // Important: Regardless of any errors, we need to make sure the original active layer is still active.


    activeLayer.activate();
  };

  const setEnabled = _enabled => {
    if (settings.enabled === _enabled) {
      return;
    }

    settings.enabled = _enabled;

    if (settings.enabled) {
      if (settings.next === 0 && settings.previous === 0) {
        settings.previous = 1;
        layerInputs.previous.value = settings.previous;
      }

      if (settings.opacity === 0) {
        settings.opacity = 25;
        layerInputs.opacity.value = settings.opacity;
      }

      updateOnionLayers();
    } else {
      removeOnionLayers();
    }

    toggleButton.dataset.enabled = settings.enabled;
  };

  const untilInEditor = () => {
    if (addon.tab.editorMode !== "editor") {
      return new Promise((resolve, reject) => {
        const handler = () => {
          if (addon.tab.editorMode === "editor") {
            resolve();
            addon.tab.removeEventListener("urlChange", handler);
          }
        };

        addon.tab.addEventListener("urlChange", handler);
      });
    }
  };

  const accessScratchInternals = () => {
    if (paper) {
      return;
    }

    const REACT_INTERNAL_PREFIX = "__reactInternalInstance$"; // We can access paper through .tool on tools, for example:
    // https://github.com/LLK/scratch-paint/blob/develop/src/containers/bit-brush-mode.jsx#L60-L62
    // It happens that paper's Tool objects contain a reference to the entirety of paper's scope.

    const modeSelector = document.querySelector("[class*='paint-editor_mode-selector']");
    const reactInternalKey = Object.keys(modeSelector).find(i => i.startsWith(REACT_INTERNAL_PREFIX));
    const internalState = modeSelector[reactInternalKey].child; // .tool only exists on the selected tool

    let toolState = internalState;
    let tool;

    while (!(tool = toolState.child.stateNode.tool)) {
      toolState = toolState.sibling;
    }

    const paperScope = tool._scope;
    const paintEditorCanvasContainer = document.querySelector("[class^='paint-editor_canvas-container']");
    const paperCanvas = paintEditorCanvasContainer[reactInternalKey].child.child.child.stateNode;

    if (paperScope && paperCanvas) {
      foundPaper(paperScope);
      foundPaperCanvas(paperCanvas);
    }
  };

  const settingsChanged = onlyRelayerNeeded => {
    if (settings.previous === 0 && settings.next === 0 || settings.opacity === 0) {
      setEnabled(false);
      return;
    }

    if (settings.enabled) {
      if (onlyRelayerNeeded) {
        relayerOnionLayers();
      } else {
        updateOnionLayers();
      }
    } else if (settings.previous > 0 || settings.next > 0) {
      setEnabled(true);
    }
  };

  const createGroup = () => {
    const el = document.createElement("div");
    el.className = "sa-onion-group";
    return el;
  };

  const createButton = () => {
    const el = document.createElement("span");
    el.className = "sa-onion-button";
    el.setAttribute("role", "button");
    return el;
  };

  const createButtonImage = name => {
    const el = document.createElement("img");
    el.className = "sa-onion-image";
    el.draggable = false;
    el.dataset.image = name;
    el.loading = "lazy";
    el.src = _twGetAsset("/" + name + ".svg");
    return el;
  }; //
  // Controls below editor
  //


  const paintEditorControlsContainer = document.createElement("div");
  paintEditorControlsContainer.className = "sa-onion-controls-container";
  paintEditorControlsContainer.dir = "";
  const toggleControlsGroup = createGroup();
  const toggleButton = createButton();
  toggleButton.dataset.enabled = settings.enabled;
  toggleButton.addEventListener("click", () => setEnabled(!settings.enabled));
  toggleButton.title = msg("toggle");
  toggleButton.appendChild(createButtonImage("toggle"));
  toggleControlsGroup.appendChild(toggleButton);
  const settingButton = createButton();
  settingButton.addEventListener("click", () => setSettingsOpen(!areSettingsOpen()));
  settingButton.title = msg("settings");
  settingButton.appendChild(createButtonImage("settings"));
  toggleControlsGroup.appendChild(settingButton);
  paintEditorControlsContainer.appendChild(toggleControlsGroup); //
  // Settings page
  //

  const settingsPage = document.createElement("div");
  settingsPage.className = "sa-onion-settings";

  const setSettingsOpen = open => {
    settingButton.dataset.enabled = open;
    settingsPage.dataset.visible = open;
  };

  const areSettingsOpen = () => settingsPage.dataset.visible === "true";

  const layerInputs = {};

  for (const type of ["previous", "next", "opacity", "opacityStep"]) {
    const container = document.createElement("div");
    container.className = "sa-onion-settings-line";
    const label = document.createElement("div");
    label.className = "sa-onion-settings-label";
    label.textContent = msg(type);
    container.appendChild(label);
    const group = createGroup();
    const currentButton = createButton();
    const filler = document.createElement("div");
    filler.style.width = "20px";
    currentButton.appendChild(filler);
    const currentInput = document.createElement("input");
    layerInputs[type] = currentInput;
    currentInput.className = "sa-onion-settings-input";
    currentInput.type = "number";
    currentInput.step = "1";
    currentInput.min = "0";
    currentInput.max = "100";
    currentInput.value = settings[type];
    currentInput.addEventListener("input", e => {
      if (currentInput.value.length === 0) {
        settings[type] = 0;
        settingsChanged();
        return;
      }

      let value = +currentInput.value;

      if (value > +currentInput.max) {
        value = +currentInput.max;
      } else if (value < 0) {
        value = 0;
      }

      currentInput.value = value;
      settings[type] = value;
      settingsChanged();
    });
    currentInput.addEventListener("blur", () => {
      if (!currentInput.value) {
        currentInput.value = "0";
      }
    });
    currentButton.appendChild(currentInput);
    const decrementButton = createButton();
    decrementButton.appendChild(createButtonImage("decrement"));
    decrementButton.addEventListener("click", () => {
      if (settings[type] > 0) {
        settings[type]--;
        currentInput.value = settings[type];
        settingsChanged();
      }
    });
    const incrementButton = createButton();
    incrementButton.appendChild(createButtonImage("increment"));
    incrementButton.addEventListener("click", () => {
      if (settings[type] < +currentInput.max) {
        settings[type]++;
        currentInput.value = settings[type];
        settingsChanged();
      }
    });
    group.appendChild(decrementButton);
    group.appendChild(currentButton);
    group.appendChild(incrementButton);
    container.appendChild(group);
    settingsPage.appendChild(container);
  }

  const modeContainer = document.createElement("div");
  modeContainer.className = "sa-onion-settings-line";
  const modeLabel = document.createElement("div");
  modeLabel.className = "sa-onion-settings-label";
  modeLabel.textContent = msg("mode");
  const modeGroup = createGroup();
  modeContainer.appendChild(modeLabel);
  const modeMergeButton = createButton();
  modeMergeButton.appendChild(document.createTextNode(msg("merge")));
  modeGroup.appendChild(modeMergeButton);
  modeMergeButton.addEventListener("click", e => {
    settings.mode = "merge";
    modeTintButton.dataset.enabled = false;
    modeMergeButton.dataset.enabled = true;
    settingsChanged();
  });
  modeMergeButton.dataset.enabled = settings.mode === "merge";
  const modeTintButton = createButton();
  modeTintButton.appendChild(document.createTextNode(msg("tint")));
  modeGroup.appendChild(modeTintButton);
  modeTintButton.addEventListener("click", e => {
    settings.mode = "tint";
    modeTintButton.dataset.enabled = true;
    modeMergeButton.dataset.enabled = false;
    settingsChanged();
  });
  modeTintButton.dataset.enabled = settings.mode === "tint";
  modeContainer.appendChild(modeGroup);
  settingsPage.appendChild(modeContainer);
  const layeringContainer = document.createElement("div");
  layeringContainer.className = "sa-onion-settings-line";
  const layeringLabel = document.createElement("div");
  layeringLabel.className = "sa-onion-settings-label";
  layeringLabel.textContent = msg("layering");
  const layeringGroup = createGroup();
  layeringContainer.appendChild(layeringLabel);
  const layeringFrontButton = createButton();
  layeringFrontButton.appendChild(document.createTextNode(msg("front")));
  layeringGroup.appendChild(layeringFrontButton);
  layeringFrontButton.addEventListener("click", e => {
    settings.layering = "front";
    layeringBehindButton.dataset.enabled = false;
    layeringFrontButton.dataset.enabled = true;
    settingsChanged(true);
  });
  layeringFrontButton.dataset.enabled = settings.layering === "front";
  const layeringBehindButton = createButton();
  layeringBehindButton.appendChild(document.createTextNode(msg("behind")));
  layeringGroup.appendChild(layeringBehindButton);
  layeringBehindButton.addEventListener("click", e => {
    settings.layering = "behind";
    layeringBehindButton.dataset.enabled = true;
    layeringFrontButton.dataset.enabled = false;
    settingsChanged(true);
  });
  layeringBehindButton.dataset.enabled = settings.layering === "behind";
  layeringContainer.appendChild(layeringGroup);
  settingsPage.appendChild(layeringContainer);
  const SVG_NS = "http://www.w3.org/2000/svg";
  const settingsTip = document.createElementNS(SVG_NS, "svg");
  settingsTip.setAttribute("class", "sa-onion-settings-tip");
  settingsTip.setAttribute("width", "14");
  settingsTip.setAttribute("height", "7");
  const settingsTipShape = document.createElementNS(SVG_NS, "polygon");
  settingsTipShape.setAttribute("class", "sa-onion-settings-polygon");
  settingsTipShape.setAttribute("points", "0,0 7,7, 14,0");
  settingsTip.appendChild(settingsTipShape);
  settingsPage.appendChild(settingsTip);

  const controlsLoop = async () => {
    let hasRunOnce = false;

    while (true) {
      const canvasControls = await addon.tab.waitForElement("[class^='paint-editor_canvas-controls']", {
        markAsSeen: true,
        reduxCondition: state => state.scratchGui.editorTab.activeTabIndex === 1 && !state.scratchGui.mode.isPlayerOnly
      });
      accessScratchInternals();
      const zoomControlsContainer = canvasControls.querySelector("[class^='paint-editor_zoom-controls']");
      const canvasContainer = document.querySelector("[class^='paint-editor_canvas-container']"); // TODO: when leaving the paint editor, references to the old zoom controls are kept around by our DOM
      // Need to investigate whether this leaks memory or other issues.

      const oldZoomControlsContainer = paintEditorControlsContainer.querySelector("[class^='paint-editor_zoom-controls']");

      if (oldZoomControlsContainer) {
        oldZoomControlsContainer.parentNode.removeChild(oldZoomControlsContainer);
      }

      paintEditorControlsContainer.appendChild(zoomControlsContainer);
      canvasControls.appendChild(paintEditorControlsContainer);
      canvasContainer.appendChild(settingsPage);

      if (!hasRunOnce) {
        hasRunOnce = true;
        const groupClass = zoomControlsContainer.firstChild.className;
        const buttonClass = zoomControlsContainer.firstChild.firstChild.className;
        const imageClass = zoomControlsContainer.firstChild.firstChild.firstChild.className;

        for (const el of document.querySelectorAll(".sa-onion-group")) {
          el.className += " " + groupClass;
        }

        for (const el of document.querySelectorAll(".sa-onion-button")) {
          el.className += " " + buttonClass;
        }

        for (const el of document.querySelectorAll(".sa-onion-image")) {
          el.className += " " + imageClass;
        }
      }

      if (settings.enabled) {
        updateOnionLayers();
      }
    }
  };

  await untilInEditor();
  controlsLoop();
});

/***/ }),

/***/ "./src/addons/addons/pause/module.js":
/*!*******************************************!*\
  !*** ./src/addons/addons/pause/module.js ***!
  \*******************************************/
/*! exports provided: paused, onPauseChanged, setPaused */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "paused", function() { return paused; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onPauseChanged", function() { return onPauseChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPaused", function() { return setPaused; });
const vm = window.vm;
let paused = false;
let pausedThreadState = new WeakMap();
let eventTarget = new EventTarget();
const onPauseChanged = listener => {
  eventTarget.addEventListener("change", () => listener(paused));
};
const setPaused = _paused => {
  paused = _paused;

  if (paused) {
    vm.runtime.audioEngine.audioContext.suspend();

    if (!vm.runtime.ioDevices.clock._paused) {
      vm.runtime.ioDevices.clock.pause();
    }

    for (const thread of vm.runtime.threads) {
      if (!thread.updateMonitor && !pausedThreadState.has(thread)) {
        const pauseState = {
          pauseTime: vm.runtime.currentMSecs,
          status: thread.status
        };
        pausedThreadState.set(thread, pauseState); // Make sure that paused threads will always be paused.
        // Setting thread.status is not enough for blocks like "ask and wait"

        Object.defineProperty(thread, "status", {
          get() {
            return (
              /* STATUS_PROMISE_WAIT */
              1
            );
          },

          set(status) {
            // Status will be set when the thread is unpaused.
            pauseState.status = status;
          },

          configurable: true,
          enumerable: true
        });
      }
    } // Immediately emit project stop
    // Scratch will do this automatically, but there may be a slight delay.


    vm.runtime.emit("PROJECT_RUN_STOP");
  } else {
    vm.runtime.audioEngine.audioContext.resume();
    vm.runtime.ioDevices.clock.resume();
    const now = Date.now();

    for (const thread of vm.runtime.threads) {
      const pauseState = pausedThreadState.get(thread);

      if (pauseState) {
        const stackFrame = thread.peekStackFrame();

        if (stackFrame && stackFrame.executionContext && stackFrame.executionContext.timer) {
          const dt = now - pauseState.pauseTime;
          stackFrame.executionContext.timer.startTime += dt;
        } // Compiler state is stored differently


        if (thread.timer) {
          const dt = now - pauseState.pauseTime;
          thread.timer.startTime += dt;
        }

        Object.defineProperty(thread, "status", {
          value: pauseState.status,
          configurable: true,
          enumerable: true,
          writable: true
        });
      }
    }

    pausedThreadState = new WeakMap();
  }

  eventTarget.dispatchEvent(new CustomEvent("change"));
};
const originalGreenFlag = vm.runtime.greenFlag;

vm.runtime.greenFlag = function () {
  setPaused(false);
  return originalGreenFlag.call(this);
}; // Disable edge-activated hats and hats like "when key pressed" while paused.


const originalStartHats = vm.runtime.startHats;

vm.runtime.startHats = function (...args) {
  if (paused) {
    const hat = args[0]; // The project can still be edited and the user might manually trigger some events. Let these run.

    if (hat !== "event_whenbroadcastreceived" && hat !== "control_start_as_clone") {
      return [];
    }
  }

  return originalStartHats.apply(this, args);
}; // Paused threads should not be counted as running when updating GUI state.


const originalGetMonitorThreadCount = vm.runtime._getMonitorThreadCount;

vm.runtime._getMonitorThreadCount = function (threads) {
  let count = originalGetMonitorThreadCount.call(this, threads);

  if (paused) {
    for (const thread of threads) {
      if (pausedThreadState.has(thread)) {
        count++;
      }
    }
  }

  return count;
};

/***/ }),

/***/ "./src/addons/addons/pause/pause.svg":
/*!*******************************************!*\
  !*** ./src/addons/addons/pause/pause.svg ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/e079d14437a5d486830af3dc75b9e806.svg";

/***/ }),

/***/ "./src/addons/addons/pause/play.svg":
/*!******************************************!*\
  !*** ./src/addons/addons/pause/play.svg ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/7980c63844b66a9a01a32a70b3e7ca8a.svg";

/***/ }),

/***/ "./src/addons/addons/pause/userscript.js":
/*!***********************************************!*\
  !*** ./src/addons/addons/pause/userscript.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pause_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pause.svg */ "./src/addons/addons/pause/pause.svg");
/* harmony import */ var _pause_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_pause_svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _play_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./play.svg */ "./src/addons/addons/pause/play.svg");
/* harmony import */ var _play_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_play_svg__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./module.js */ "./src/addons/addons/pause/module.js");
/* inserted by pull.js */



const _twGetAsset = path => {
  if (path === "/pause.svg") return _pause_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  if (path === "/play.svg") return _play_svg__WEBPACK_IMPORTED_MODULE_1___default.a;
  throw new Error("Unknown asset: ".concat(path));
};


/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  const img = document.createElement("img");
  img.className = "pause-btn";
  img.draggable = false;
  img.title = msg("pause");

  const setSrc = () => img.src = _twGetAsset(_module_js__WEBPACK_IMPORTED_MODULE_2__["paused"] ? "/play.svg" : "/pause.svg");

  img.addEventListener("click", () => Object(_module_js__WEBPACK_IMPORTED_MODULE_2__["setPaused"])(!_module_js__WEBPACK_IMPORTED_MODULE_2__["paused"]));
  addon.tab.displayNoneWhileDisabled(img);
  addon.self.addEventListener("disabled", () => Object(_module_js__WEBPACK_IMPORTED_MODULE_2__["setPaused"])(false));
  setSrc();
  Object(_module_js__WEBPACK_IMPORTED_MODULE_2__["onPauseChanged"])(setSrc);

  while (true) {
    const flag = await addon.tab.waitForElement("[class^='green-flag']", {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
    });
    flag.insertAdjacentElement("afterend", img);
  }
});

/***/ }),

/***/ "./src/addons/addons/remove-sprite-confirm/userscript.js":
/*!***************************************************************!*\
  !*** ./src/addons/addons/remove-sprite-confirm/userscript.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async ({
  addon,
  console,
  msg
}) => {
  if (!addon.tab.redux.state) return console.warn("Redux is not available!");
  const vm = addon.tab.traps.vm;
  if (!vm) return;
  const oldDeleteSprite = vm.deleteSprite;

  vm.deleteSprite = function (...args) {
    const canDelete = confirm(msg("confirm"));
    if (canDelete) return oldDeleteSprite.apply(this, args);
    const restoreDeletionState = Object.assign({}, addon.tab.redux.state.scratchGui.restoreDeletion);
    setTimeout(() => addon.tab.redux.dispatch({
      type: "scratch-gui/restore-deletion/RESTORE_UPDATE",
      state: restoreDeletionState
    }), 100);
    return Promise.resolve();
  };
});

/***/ }),

/***/ "./src/addons/addons/tw-interface-customization/remove-backpack.js":
/*!*************************************************************************!*\
  !*** ./src/addons/addons/tw-interface-customization/remove-backpack.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function () {
  // Trigger a resize so that Blockly knows that the backpack is gone
  window.dispatchEvent(new Event("resize"));
});

/***/ }),

/***/ "./src/addons/addons/tw-project-info/blockcount.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/tw-project-info/blockcount.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  console,
  msg
}) {
  const vm = addon.tab.traps.vm;

  const getBlockCount = () => {
    let blockCount = 0;
    let scriptCount = 0;
    let sprites = new Set(vm.runtime.targets.map(i => i.sprite.blocks._blocks));
    sprites.forEach((sprite, i) => {
      scriptCount += Object.values(sprite).filter(o => !o.parent).length; // Filter blocks that don't have a parent (meaning it's the top of a stack)

      blockCount += Object.values(sprite).filter(o => !o.shadow).length; // shadow blocks should be filtered out
    });
    return {
      blockCount,
      scriptCount,
      spriteCount: sprites.size - 1 // Backdrop counts as a target so we can subtract it

    };
  };

  const addLiveBlockCount = async () => {
    if (vm.editingTarget) {
      while (true) {
        const topBar = await addon.tab.waitForElement("[class^='menu-bar_main-menu']", {
          markAsSeen: true,
          reduxEvents: ["scratch-gui/mode/SET_PLAYER"]
        });
        let display = topBar.appendChild(document.createElement("span"));
        addon.tab.displayNoneWhileDisabled(display);
        display.style.order = 1;
        display.style.padding = "9px";
        display.innerText = msg("blocks", {
          num: getBlockCount().blockCount
        });
        let debounce; // debouncing values because of the way 'PROJECT_CHANGED' works

        vm.on("PROJECT_CHANGED", () => {
          clearTimeout(debounce);
          debounce = setTimeout(() => {
            display.innerText = msg("blocks", {
              num: getBlockCount().blockCount
            });
          }, 1000);
        });
      }
    } else {
      let timeout = setTimeout(function () {
        addLiveBlockCount();
        clearTimeout(timeout);
      }, 1000);
    }
  };

  addLiveBlockCount();
});

/***/ }),

/***/ "./src/addons/addons/variable-manager/icon.svg":
/*!*****************************************************!*\
  !*** ./src/addons/addons/variable-manager/icon.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/0c99c0eae1be54ccd90e2a77165b1d81.svg";

/***/ }),

/***/ "./src/addons/addons/variable-manager/search.svg":
/*!*******************************************************!*\
  !*** ./src/addons/addons/variable-manager/search.svg ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/assets/1821649bb254ff5d93bb397ad646a23f.svg";

/***/ }),

/***/ "./src/addons/addons/variable-manager/userscript.js":
/*!**********************************************************!*\
  !*** ./src/addons/addons/variable-manager/userscript.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _icon_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.svg */ "./src/addons/addons/variable-manager/icon.svg");
/* harmony import */ var _icon_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_icon_svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _search_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./search.svg */ "./src/addons/addons/variable-manager/search.svg");
/* harmony import */ var _search_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_search_svg__WEBPACK_IMPORTED_MODULE_1__);
/* inserted by pull.js */



const _twGetAsset = path => {
  if (path === "/icon.svg") return _icon_svg__WEBPACK_IMPORTED_MODULE_0___default.a;
  if (path === "/search.svg") return _search_svg__WEBPACK_IMPORTED_MODULE_1___default.a;
  throw new Error("Unknown asset: ".concat(path));
};

/* harmony default export */ __webpack_exports__["default"] = (async function ({
  addon,
  global,
  console,
  msg
}) {
  const vm = addon.tab.traps.vm;
  let localVariables = [];
  let globalVariables = [];
  let preventUpdate = false;
  const manager = document.createElement("div");
  manager.classList.add(addon.tab.scratchClass("asset-panel_wrapper"), "sa-var-manager");
  const searchBox = document.createElement("input");
  searchBox.placeholder = msg("search");
  searchBox.className = addon.tab.scratchClass("input_input-form", {
    others: "sa-var-manager-searchbox"
  });
  searchBox.addEventListener("input", e => {
    for (const variable of localVariables) {
      variable.handleSearch(searchBox.value);
    }

    for (const variable of globalVariables) {
      variable.handleSearch(searchBox.value);
    }

    updateHeadingVisibility();
  });
  manager.appendChild(searchBox);
  const localVars = document.createElement("div");
  const localHeading = document.createElement("span");
  const localList = document.createElement("table");
  localHeading.className = "sa-var-manager-heading";
  localHeading.innerText = msg("for-this-sprite");
  localVars.appendChild(localHeading);
  localVars.appendChild(localList);
  const globalVars = document.createElement("div");
  const globalHeading = document.createElement("span");
  const globalList = document.createElement("table");
  globalHeading.className = "sa-var-manager-heading";
  globalHeading.innerText = msg("for-all-sprites");
  globalVars.appendChild(globalHeading);
  globalVars.appendChild(globalList);
  manager.appendChild(localVars);
  manager.appendChild(globalVars);
  const varTab = document.createElement("li");
  varTab.classList.add(addon.tab.scratchClass("react-tabs_react-tabs__tab"), addon.tab.scratchClass("gui_tab"));
  varTab.id = "react-tabs-7";
  const varTabIcon = document.createElement("img");
  varTabIcon.draggable = false;
  varTabIcon.src = _twGetAsset("/icon.svg");
  const varTabText = document.createElement("span");
  varTabText.innerText = msg("variables");
  varTab.appendChild(varTabIcon);
  varTab.appendChild(varTabText);

  function updateHeadingVisibility() {
    // used to hide the headings if there are no variables
    let filteredLocals = localVariables.filter(v => v.row.style.display !== "none");
    let filteredGlobals = globalVariables.filter(v => v.row.style.display !== "none");
    localHeading.style.display = filteredLocals.length === 0 ? "none" : "";
    globalHeading.style.display = filteredGlobals.length === 0 ? "none" : "";
  }

  const rowToVariableMap = new WeakMap();
  const observer = new IntersectionObserver(changes => {
    for (const change of changes) {
      const variable = rowToVariableMap.get(change.target);
      variable.setVisible(change.intersectionRatio > 0);
    }
  }, {
    rootMargin: "100px"
  });

  class WrappedVariable {
    constructor(scratchVariable, target) {
      this.scratchVariable = scratchVariable;
      this.target = target;
      this.visible = false;
      this.buildDOM();
    }

    updateValue(force) {
      if (!this.visible && !force) return;
      let newValue;

      if (this.scratchVariable.type === "list") {
        newValue = this.scratchVariable.value.join("\n");
      } else {
        newValue = this.scratchVariable.value;
      }

      if (newValue !== this.input.value) {
        this.input.value = newValue;
      }
    }

    handleSearch(search) {
      // this doesn't check if this.visible is true or whatever. maybe that would improve performance while typing into the search box but it's probably fine™
      if (this.scratchVariable.name.toLowerCase().includes(search.toLowerCase()) || !search) {
        // fuzzy searches are lame we are too cool for fuzzy searches (& i doubt they're even the right thing to use here, this should work fine enough)
        this.row.style.display = ""; // make the row normal

        this.updateValue(true); // force it to update because its hidden and it wouldnt be able to otherwise
      } else {
        this.row.style.display = "none"; // set the entire row as hidden
      }
    }

    resizeInputIfList() {
      if (this.scratchVariable.type === "list") {
        this.input.style.height = "auto";
        const height = Math.min(1000, this.input.scrollHeight);

        if (height > 0) {
          this.input.style.height = height + "px";
        }
      }
    }

    setVisible(visible) {
      if (this.visible === visible) return;
      this.visible = visible;

      if (visible) {
        this.updateValue();
      }
    }

    buildDOM() {
      const id = "sa-variable-manager-".concat(this.scratchVariable.id);
      const row = document.createElement("tr");
      this.row = row;
      const labelCell = document.createElement("td");
      labelCell.className = "sa-var-manager-name";
      const label = document.createElement("input");
      label.value = this.scratchVariable.name;
      label.htmlFor = id;

      const onLabelOut = e => {
        e.preventDefault();
        const workspace = Blockly.getMainWorkspace();
        const existingVariableWithNewName = workspace.getVariable(label.value, this.scratchVariable.type);

        if (existingVariableWithNewName) {
          label.value = this.scratchVariable.name;
        } else {
          workspace.renameVariableById(this.scratchVariable.id, label.value);
        }

        label.blur();
      };

      label.addEventListener("keydown", e => {
        if (e.key === "Enter" && !e.shiftKey) e.target.blur();
      });
      label.addEventListener("focusout", onLabelOut);
      label.addEventListener("focus", e => {
        preventUpdate = true;
        manager.classList.add("freeze");
      });
      label.addEventListener("blur", e => {
        preventUpdate = false;
        manager.classList.remove("freeze");
      });
      labelCell.appendChild(label);
      rowToVariableMap.set(row, this);
      observer.observe(row);
      const valueCell = document.createElement("td");
      valueCell.className = "sa-var-manager-value";
      let input;

      if (this.scratchVariable.type === "list") {
        input = document.createElement("textarea");
      } else {
        input = document.createElement("input");
      }

      input.id = id;
      this.input = input;
      this.updateValue(true);

      if (this.scratchVariable.type === "list") {
        this.input.addEventListener("input", () => this.resizeInputIfList(), false);
      }

      const onInputOut = e => {
        e.preventDefault();

        if (this.scratchVariable.type === "list") {
          vm.setVariableValue(this.target.id, this.scratchVariable.id, input.value.split("\n"));
        } else {
          vm.setVariableValue(this.target.id, this.scratchVariable.id, input.value);
        }

        input.blur();
      };

      input.addEventListener("keydown", e => {
        if (e.key === "Enter" && !e.shiftKey) e.target.blur();
      });
      input.addEventListener("focusout", onInputOut);
      input.addEventListener("focus", e => {
        preventUpdate = true;
        manager.classList.add("freeze");
      });
      input.addEventListener("blur", e => {
        preventUpdate = false;
        manager.classList.remove("freeze");
      });
      valueCell.appendChild(input);
      row.appendChild(labelCell);
      row.appendChild(valueCell);
      this.handleSearch(searchBox.value);
    }

  }

  function fullReload() {
    if (addon.tab.redux.state.scratchGui.editorTab.activeTabIndex !== 3 || preventUpdate) return;
    const editingTarget = vm.runtime.getEditingTarget();
    const stage = vm.runtime.getTargetForStage();
    localVariables = editingTarget.isStage ? [] : Object.values(editingTarget.variables).filter(i => i.type === "" || i.type === "list").map(i => new WrappedVariable(i, editingTarget));
    globalVariables = Object.values(stage.variables).filter(i => i.type === "" || i.type === "list").map(i => new WrappedVariable(i, stage));
    updateHeadingVisibility();

    while (localList.firstChild) {
      localList.removeChild(localList.firstChild);
    }

    while (globalList.firstChild) {
      globalList.removeChild(globalList.firstChild);
    }

    for (const variable of localVariables) {
      localList.appendChild(variable.row);
      variable.resizeInputIfList();
    }

    for (const variable of globalVariables) {
      globalList.appendChild(variable.row);
      variable.resizeInputIfList();
    }
  }

  function quickReload() {
    if (addon.tab.redux.state.scratchGui.editorTab.activeTabIndex !== 3 || preventUpdate) return;

    for (const variable of localVariables) {
      variable.updateValue();
    }

    for (const variable of globalVariables) {
      variable.updateValue();
    }
  }

  function cleanup() {
    localVariables = [];
    globalVariables = [];
  }

  varTab.addEventListener("click", e => {
    addon.tab.redux.dispatch({
      type: "scratch-gui/navigation/ACTIVATE_TAB",
      activeTabIndex: 3
    });
  });

  function setVisible(visible) {
    if (visible) {
      varTab.classList.add(addon.tab.scratchClass("react-tabs_react-tabs__tab--selected"), addon.tab.scratchClass("gui_is-selected"));
      const contentArea = document.querySelector("[class^=gui_tabs]");
      contentArea.insertAdjacentElement("beforeend", manager);
      fullReload();
    } else {
      varTab.classList.remove(addon.tab.scratchClass("react-tabs_react-tabs__tab--selected"), addon.tab.scratchClass("gui_is-selected"));
      manager.remove();
      cleanup();
    }
  }

  addon.tab.redux.initialize();
  addon.tab.redux.addEventListener("statechanged", ({
    detail
  }) => {
    if (detail.action.type === "scratch-gui/navigation/ACTIVATE_TAB") {
      setVisible(detail.action.activeTabIndex === 3);
    } else if (detail.action.type === "scratch-gui/mode/SET_PLAYER") {
      if (!detail.action.isPlayerOnly && addon.tab.redux.state.scratchGui.editorTab.activeTabIndex === 3) {
        // DOM doesn't actually exist yet
        queueMicrotask(() => setVisible(true));
      }
    }
  });
  vm.runtime.on("PROJECT_LOADED", () => fullReload());
  vm.runtime.on("TOOLBOX_EXTENSIONS_NEED_UPDATE", () => fullReload());
  const oldStep = vm.runtime.constructor.prototype._step;

  vm.runtime.constructor.prototype._step = function (...args) {
    const ret = oldStep.call(this, ...args);
    quickReload();
    return ret;
  };

  while (true) {
    const tabs = await addon.tab.waitForElement("[class^='react-tabs_react-tabs__tab-list']", {
      markAsSeen: true,
      reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"],
      reduxCondition: state => !state.scratchGui.mode.isPlayerOnly
    });
    const soundTab = tabs.children[2];
    soundTab.insertAdjacentElement("afterend", varTab);
  }
});

/***/ }),

/***/ "./src/addons/api.js":
/*!***************************!*\
  !*** ./src/addons/api.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! intl-messageformat */ "./node_modules/intl-messageformat/index.js");
/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(intl_messageformat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _settings_store_singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings-store-singleton */ "./src/addons/settings-store-singleton.js");
/* harmony import */ var _get_addon_translations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-addon-translations */ "./src/addons/get-addon-translations.js");
/* harmony import */ var _lib_data_uri_to_blob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/data-uri-to-blob */ "./src/lib/data-uri-to-blob.js");
/* harmony import */ var _event_target__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./event-target */ "./src/addons/event-target.js");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks */ "./src/addons/hooks.js");
/* harmony import */ var _addon_manifests__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./addon-manifests */ "./src/addons/addon-manifests.js");
/* harmony import */ var _polyfill__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyfill */ "./src/addons/polyfill.js");
/* harmony import */ var _polyfill__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_polyfill__WEBPACK_IMPORTED_MODULE_7__);
/**
 * Copyright (C) 2021 Thomas Weber
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */








/* eslint-disable no-console */

const escapeHTML = str => str.replace(/([<>'"&])/g, (_, l) => "&#".concat(l.charCodeAt(0), ";"));

const kebabCaseToCamelCase = str => str.replace(/-([a-z])/g, g => g[1].toUpperCase());

const createStylesheet = css => {
  const style = document.createElement('style');
  style.textContent = css;
  return style;
};

let _scratchClassNames = null;

const getScratchClassNames = () => {
  if (_scratchClassNames) {
    return _scratchClassNames;
  }

  const cssRules = Array.from(document.styleSheets) // Ignore some scratch-paint stylesheets
  .filter(styleSheet => !(styleSheet.ownerNode.textContent.startsWith('/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.') && (styleSheet.ownerNode.textContent.includes('input_input-form') || styleSheet.ownerNode.textContent.includes('label_input-group_')))).map(e => {
    try {
      return [...e.cssRules];
    } catch (_e) {
      return [];
    }
  }).flat();
  const classes = cssRules.map(e => e.selectorText).filter(e => e).map(e => e.match(/(([\w-]+?)_([\w-]+)_([\w\d-]+))/g)).filter(e => e).flat();
  _scratchClassNames = [...new Set(classes)];
  const observer = new MutationObserver(mutationList => {
    for (const mutation of mutationList) {
      for (const node of mutation.addedNodes) {
        if (node.tagName === 'STYLE') {
          _scratchClassNames = null;
          observer.disconnect();
          return;
        }
      }
    }
  });
  observer.observe(document.head, {
    childList: true
  });
  return _scratchClassNames;
};

let _mutationObserver;

let _mutationObserverCallbacks = [];

const addMutationObserverCallback = newCallback => {
  if (!_mutationObserver) {
    _mutationObserver = new MutationObserver(() => {
      for (const cb of _mutationObserverCallbacks) {
        cb();
      }
    });

    _mutationObserver.observe(document.documentElement, {
      attributes: false,
      childList: true,
      subtree: true
    });
  }

  _mutationObserverCallbacks.push(newCallback);
};

const removeMutationObserverCallback = callback => {
  _mutationObserverCallbacks = _mutationObserverCallbacks.filter(i => i !== callback);
};

class Redux extends _event_target__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor() {
    super();
    this._initialized = false;
    this._nextState = null;
  }

  initialize() {
    if (!this._initialized) {
      _hooks__WEBPACK_IMPORTED_MODULE_5__["default"].appStateReducer = (action, next) => {
        this._nextState = next;
        this.dispatchEvent(new CustomEvent('statechanged', {
          detail: {
            action,
            next
          }
        }));
        this._nextState = null;
      };

      this._initialized = true;
    }
  }

  dispatch(m) {
    return _hooks__WEBPACK_IMPORTED_MODULE_5__["default"].appStateStore.dispatch(m);
  }

  get state() {
    if (this._nextState) return this._nextState;
    return _hooks__WEBPACK_IMPORTED_MODULE_5__["default"].appStateStore.getState();
  }

}

const getEditorMode = () => {
  // eslint-disable-next-line no-use-before-define
  const mode = tabReduxInstance.state.scratchGui.mode;
  if (mode.isEmbedded) return 'embed';
  if (mode.isFullScreen) return 'fullscreen';
  if (mode.isPlayerOnly) return 'projectpage';
  return 'editor';
};

const tabReduxInstance = new Redux();
const language = tabReduxInstance.state.locales.locale.split('-')[0];
const translations = Object(_get_addon_translations__WEBPACK_IMPORTED_MODULE_2__["default"])(language);

const getDisplayNoneWhileDisabledClass = id => "addons-display-none-".concat(id);

let _firstAddBlockRan = false;

class Tab extends _event_target__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor(id) {
    super();
    this._id = id;
    this._seenElements = new WeakSet(); // traps is public API

    this.traps = {
      get vm() {
        // We expose VM on window
        return window.vm;
      },

      getBlockly: () => {
        // The real Blockly is exposed on window. It may not exist until the user enters the editor.
        if (window.ScratchBlocks) {
          return Promise.resolve(window.ScratchBlocks);
        }

        return new Promise(resolve => {
          const handler = () => {
            if (window.ScratchBlocks) {
              this.removeEventListener('urlChange', handler);
              resolve(window.ScratchBlocks);
            }
          };

          this.addEventListener('urlChange', handler);
        });
      }
    };
  }

  get redux() {
    return tabReduxInstance;
  }

  loadScript() {
    throw new Error('loadScript is not supported');
  }

  waitForElement(selector, {
    markAsSeen = false,
    condition,
    reduxCondition,
    reduxEvents
  } = {}) {
    let externalEventSatisfied = true;

    const evaluateCondition = () => {
      if (!externalEventSatisfied) return false;
      if (condition && !condition()) return false;
      if (reduxCondition && !reduxCondition(tabReduxInstance.state)) return false;
      return true;
    };

    if (evaluateCondition()) {
      const firstQuery = document.querySelectorAll(selector);

      for (const element of firstQuery) {
        if (this._seenElements.has(element)) continue;
        if (markAsSeen) this._seenElements.add(element);
        return Promise.resolve(element);
      }
    }

    let reduxListener;

    if (reduxEvents) {
      externalEventSatisfied = false;

      reduxListener = ({
        detail
      }) => {
        const type = detail.action.type; // As addons can't run before DOM exists here, ignore fontsLoaded/SET_FONTS_LOADED
        // Otherwise, as our font loading is very async, we could activate more often than required.

        if (reduxEvents.includes(type) && type !== 'fontsLoaded/SET_FONTS_LOADED') {
          externalEventSatisfied = true;
        }
      };

      this.redux.initialize();
      this.redux.addEventListener('statechanged', reduxListener);
    }

    return new Promise(resolve => {
      const callback = () => {
        if (!evaluateCondition()) {
          return;
        }

        const elements = document.querySelectorAll(selector);

        for (const element of elements) {
          if (this._seenElements.has(element)) continue;
          resolve(element);
          removeMutationObserverCallback(callback);
          if (markAsSeen) this._seenElements.add(element);

          if (reduxListener) {
            this.redux.removeEventListener('statechanged', reduxListener);
          }

          break;
        }
      };

      addMutationObserverCallback(callback);
    });
  }

  addBlock(procedureCode, args, callback) {
    const vm = this.traps.vm;
    vm.addAddonBlock({
      procedureCode,
      arguments: args,
      callback,
      color: '#29beb8',
      secondaryColor: '#3aa8a4'
    });

    if (!_firstAddBlockRan) {
      _firstAddBlockRan = true;
      this.traps.getBlockly().then(ScratchBlocks => {
        const BlockSvg = ScratchBlocks.BlockSvg;
        const oldUpdateColour = BlockSvg.prototype.updateColour;

        BlockSvg.prototype.updateColour = function (...args2) {
          // procedures_prototype also has a procedure code but we do not want to color them.
          if (this.type === 'procedures_call') {
            const block = this.procCode_ && vm.runtime.getAddonBlock(this.procCode_);

            if (block) {
              this.colour_ = '#29beb8';
              this.colourSecondary_ = '#3aa8a4';
              this.colourTertiary_ = '#3aa8a4';
              this.customContextMenu = null;
            }
          }

          return oldUpdateColour.call(this, ...args2);
        };

        if (vm.editingTarget) {
          vm.emitWorkspaceUpdate();
        }
      });
    }
  }

  removeBlock() {
    throw new Error('not implemented');
  }

  copyImage(dataURL) {
    if (!navigator.clipboard.write) {
      return Promise.reject(new Error('Clipboard API not supported'));
    }

    const items = [// eslint-disable-next-line no-undef
    new ClipboardItem({
      'image/png': Object(_lib_data_uri_to_blob__WEBPACK_IMPORTED_MODULE_3__["default"])(dataURL)
    })];
    return navigator.clipboard.write(items);
  }

  scratchClass(...args) {
    const scratchClasses = getScratchClassNames();
    const classes = [];

    for (const arg of args) {
      if (typeof arg === 'string') {
        for (const scratchClass of scratchClasses) {
          if (scratchClass.startsWith("".concat(arg, "_")) && scratchClass.length === arg.length + 6) {
            classes.push(scratchClass);
            break;
          }
        }
      }
    }

    const options = args[args.length - 1];

    if (typeof options === 'object') {
      const others = Array.isArray(options.others) ? options.others : [options.others];

      for (const className of others) {
        classes.push(className);
      }
    }

    return classes.join(' ');
  }

  get editorMode() {
    return getEditorMode();
  }

  displayNoneWhileDisabled(el) {
    el.classList.add(getDisplayNoneWhileDisabledClass(this._id));
  }

  get direction() {
    return this.redux.state.locales.isRtl ? 'rtl' : 'ltr';
  }

}

class Settings extends _event_target__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor(addonId, manifest) {
    super();
    this._addonId = addonId;
    this._manifest = manifest;
  }

  get(id) {
    return _settings_store_singleton__WEBPACK_IMPORTED_MODULE_1__["default"].getAddonSetting(this._addonId, id);
  }

}

class Self extends _event_target__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor(id) {
    super();
    this.id = id;
    this.disabled = false;
  } // These are removed at build-time by pull.js. Throw if attempting to access them at runtime.


  get dir() {
    throw new Error("Addon tried to access addon.self.dir");
  }

  get lib() {
    throw new Error("Addon tried to access addon.self.lib");
  }

}

class AddonRunner {
  constructor(id) {
    AddonRunner.instances.push(this);
    const manifest = _addon_manifests__WEBPACK_IMPORTED_MODULE_6__["default"][id];
    this.id = id;
    this.manifest = manifest;
    this.messageCache = {};
    this.stylesheets = [];
    this.disabledStylesheet = null;
    this.publicAPI = {
      global,
      console,
      addon: {
        tab: new Tab(id),
        settings: new Settings(id, manifest),
        self: new Self(id)
      },
      msg: this.msg.bind(this),
      safeMsg: this.safeMsg.bind(this)
    };
  }

  _msg(key, vars, handler) {
    const namespacedKey = "".concat(this.id, "/").concat(key);

    if (this.messageCache[namespacedKey]) {
      return this.messageCache[namespacedKey].format(vars);
    }

    let translation = translations[namespacedKey];

    if (!translation) {
      return namespacedKey;
    }

    if (handler) {
      translation = handler(translation);
    }

    const messageFormat = new intl_messageformat__WEBPACK_IMPORTED_MODULE_0___default.a(translation, language);
    this.messageCache[namespacedKey] = messageFormat;
    return messageFormat.format(vars);
  }

  msg(key, vars) {
    return this._msg(key, vars, null);
  }

  safeMsg(key, vars) {
    return this._msg(key, vars, escapeHTML);
  }

  settingsChanged() {
    this.publicAPI.addon.settings.dispatchEvent(new CustomEvent('change'));
    this.updateCSSVariables();
  }

  updateCSSVariables() {
    if (this.manifest.settings) {
      const kebabCaseId = kebabCaseToCamelCase(this.id);

      for (const setting of this.manifest.settings) {
        const settingId = setting.id;
        const variable = "--".concat(kebabCaseId, "-").concat(kebabCaseToCamelCase(settingId));
        const value = this.publicAPI.addon.settings.get(settingId);
        document.documentElement.style.setProperty(variable, value);
      }
    }
  }

  settingsMatch(settingMatch) {
    if (!settingMatch) {
      // No settings to match.
      return true;
    }

    const settingValue = this.publicAPI.addon.settings.get(settingMatch.id);
    return settingValue === settingMatch.value;
  }

  dynamicEnable() {
    this.publicAPI.addon.self.dispatchEvent(new CustomEvent('reenabled'));
    this.publicAPI.addon.self.disabled = false;
    this.appendStylesheets();

    if (this.disabledStylesheet) {
      this.disabledStylesheet.remove();
      this.disabledStylesheet = null;
    }
  }

  dynamicDisable() {
    this.publicAPI.addon.self.dispatchEvent(new CustomEvent('disabled'));
    this.publicAPI.addon.self.disabled = true;
    this.removeStylesheets();
    const disabledCSS = ".".concat(getDisplayNoneWhileDisabledClass(this.id), "{display:none !important;}");
    this.disabledStylesheet = createStylesheet(disabledCSS);
    document.body.insertBefore(this.disabledStylesheet, document.body.firstChild);
  }

  removeStylesheets() {
    for (const style of this.stylesheets) {
      style.remove();
    }
  }

  appendStylesheets() {
    for (const style of this.stylesheets) {
      // Insert styles at the start of the body so that they have higher precedence than those in <head>
      document.body.insertBefore(style, document.body.firstChild);
    }
  }

  async run() {
    this.updateCSSVariables();

    if (this.manifest.userstyles) {
      for (const userstyle of this.manifest.userstyles) {
        if (!this.settingsMatch(userstyle.settingMatch)) {
          continue;
        }

        const m = await __webpack_require__("./src/addons/addons eager recursive ./!./node_modules/css-loader/index.js!./ ^\\.\\/.*$ include: \\.css$")("./".concat(this.id, "/").concat(userstyle.url));
        const source = m.default[0][1];
        const style = createStylesheet(source);
        style.className = 'scratch-addons-theme';
        style.dataset.addonId = this.id;
        this.stylesheets.push(style);
      }
    }

    this.appendStylesheets();

    if (this.manifest.userscripts) {
      for (const userscript of this.manifest.userscripts) {
        if (!this.settingsMatch(userscript.settingMatch)) {
          continue;
        }

        const m = await __webpack_require__("./src/addons/addons eager recursive ^\\.\\/.*$ include: \\.js$")("./".concat(this.id, "/").concat(userscript.url));
        m.default(this.publicAPI);
      }
    }
  }

}

AddonRunner.instances = [];

const runAddon = addonId => {
  const runner = new AddonRunner(addonId);
  runner.run();
};

let oldMode = getEditorMode();

const emitUrlChange = () => {
  // In Scratch, URL changes usually mean someone went from editor to fullscreen or something like that.
  // This is not the case in TW -- the URL can change for many other reasons that addons probably aren't prepared
  // to handle.
  const newMode = getEditorMode();

  if (newMode !== oldMode) {
    oldMode = newMode;
    setTimeout(() => {
      for (const addon of AddonRunner.instances) {
        addon.publicAPI.addon.tab.dispatchEvent(new CustomEvent('urlChange'));
      }
    });
  }
};

const originalReplaceState = history.replaceState;

history.replaceState = function (...args) {
  originalReplaceState.apply(this, args);
  emitUrlChange();
};

const originalPushState = history.pushState;

history.pushState = function (...args) {
  originalPushState.apply(this, args);
  emitUrlChange();
};

_settings_store_singleton__WEBPACK_IMPORTED_MODULE_1__["default"].addEventListener('addon-changed', e => {
  const addonId = e.detail.addonId;
  const runner = AddonRunner.instances.find(i => i.id === addonId);

  if (e.detail.dynamicEnable) {
    if (runner) {
      runner.dynamicEnable();
    } else {
      runAddon(addonId);
    }
  } else if (e.detail.dynamicDisable) {
    if (runner) {
      runner.dynamicDisable();
    }
  }

  if (runner) {
    runner.settingsChanged();
  }
});

for (const id of Object.keys(_addon_manifests__WEBPACK_IMPORTED_MODULE_6__["default"])) {
  if (!_settings_store_singleton__WEBPACK_IMPORTED_MODULE_1__["default"].getAddonEnabled(id)) {
    continue;
  }

  runAddon(id);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/addons/entry.js":
/*!*****************************!*\
  !*** ./src/addons/entry.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./src/addons/api.js");


/***/ }),

/***/ "./src/addons/libraries/common/cs/download-blob.js":
/*!*********************************************************!*\
  !*** ./src/addons/libraries/common/cs/download-blob.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// From https://github.com/LLK/scratch-gui/blob/develop/src/lib/download-blob.js
/* harmony default export */ __webpack_exports__["default"] = ((filename, blob) => {
  const downloadLink = document.createElement("a");
  document.body.appendChild(downloadLink); // Use special ms version if available to get it working on Edge.

  if (navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, filename);
    return;
  }

  if ("download" in HTMLAnchorElement.prototype) {
    const url = window.URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = filename;
    downloadLink.type = blob.type;
    downloadLink.click(); // remove the link after a timeout to prevent a crash on iOS 13 Safari

    window.setTimeout(() => {
      document.body.removeChild(downloadLink);
      window.URL.revokeObjectURL(url);
    }, 1000);
  } else {
    // iOS 12 Safari, open a new page and set href to data-uri
    let popup = window.open("", "_blank");
    const reader = new FileReader();

    reader.onloadend = function () {
      popup.location.href = reader.result;
      popup = null;
    };

    reader.readAsDataURL(blob);
  }
});

/***/ }),

/***/ "./src/addons/libraries/common/cs/normalize-color.js":
/*!***********************************************************!*\
  !*** ./src/addons/libraries/common/cs/normalize-color.js ***!
  \***********************************************************/
/*! exports provided: getHexRegex, normalizeHex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHexRegex", function() { return getHexRegex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeHex", function() { return normalizeHex; });
const getHexRegex = () => /^#?[0-9a-fA-F]{3,8}$/;
const normalizeHex = input => {
  let hex = String(input);
  if (!getHexRegex().test(hex)) return "#000000";
  if (!hex.startsWith("#")) hex = "#".concat(hex);

  if (hex.length === 4) {
    const [_, r, g, b] = hex;
    hex = "#".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b);
  }

  return hex.toLowerCase();
};

/***/ }),

/***/ "./src/addons/libraries/common/cs/rate-limiter.js":
/*!********************************************************!*\
  !*** ./src/addons/libraries/common/cs/rate-limiter.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RateLimiter; });
class RateLimiter {
  constructor(wait) {
    this.timeout = null;
    this.callback = null;
    this.wait = wait;
  }

  abort(call = true) {
    if (this.timeout) {
      clearTimeout(this.timeout);
      if (call) this.callback();
      this.timeout = this.callback = null;
    }
  }

  limit(callback) {
    this.abort(false);
    this.callback = callback;
    this.timeout = setTimeout(() => {
      this.timeout = this.callback = null;
      callback();
    }, this.wait);
  }

}

/***/ }),

/***/ "./src/addons/libraries/common/cs/text-color.esm.js":
/*!**********************************************************!*\
  !*** ./src/addons/libraries/common/cs/text-color.esm.js ***!
  \**********************************************************/
/*! exports provided: textColor, multiply, brighten, alphaBlend, recolorFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textColor", function() { return textColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighten", function() { return brighten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alphaBlend", function() { return alphaBlend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recolorFilter", function() { return recolorFilter; });
function parseHex(hex) {
  return {
    r: parseInt(hex.substring(1, 3), 16),
    g: parseInt(hex.substring(3, 5), 16),
    b: parseInt(hex.substring(5, 7), 16),
    a: hex.length >= 9 ? parseInt(hex.substring(7, 9), 16) / 255 : 1
  };
}

function convertComponentToHex(a) {
  a = Math.round(a).toString(16);
  if (a.length === 1) return "0".concat(a);
  return a;
}

function convertToHex(obj) {
  const r = convertComponentToHex(obj.r);
  const g = convertComponentToHex(obj.g);
  const b = convertComponentToHex(obj.b);
  const a = obj.a !== undefined ? convertComponentToHex(255 * obj.a) : "";
  return "#".concat(r).concat(g).concat(b).concat(a);
}

function textColor(hex, black, white, threshold) {
  const {
    r,
    g,
    b
  } = parseHex(hex);
  threshold = threshold !== undefined ? threshold : 170;

  if (r * 0.299 + g * 0.587 + b * 0.114 > threshold) {
    // https://stackoverflow.com/a/3943023
    return black !== undefined ? black : "#575e75";
  } else {
    return white !== undefined ? white : "#ffffff";
  }
}

function multiply(hex, c) {
  const {
    r,
    g,
    b,
    a
  } = parseHex(hex);
  if (c.r === undefined) c.r = 1;
  if (c.g === undefined) c.g = 1;
  if (c.b === undefined) c.b = 1;
  if (c.a === undefined) c.a = 1;
  return convertToHex({
    r: c.r * r,
    g: c.g * g,
    b: c.b * b,
    a: c.a * a
  });
}

function brighten(hex, c) {
  const {
    r,
    g,
    b,
    a
  } = parseHex(hex);
  if (c.r === undefined) c.r = 1;
  if (c.g === undefined) c.g = 1;
  if (c.b === undefined) c.b = 1;
  if (c.a === undefined) c.a = 1;
  return convertToHex({
    r: (1 - c.r) * 255 + c.r * r,
    g: (1 - c.g) * 255 + c.g * g,
    b: (1 - c.b) * 255 + c.b * b,
    a: (1 - c.a) * 255 + c.a * a
  });
}

function alphaBlend(opaqueHex, transparentHex) {
  const {
    r: r1,
    g: g1,
    b: b1
  } = parseHex(opaqueHex);
  const {
    r: r2,
    g: g2,
    b: b2,
    a
  } = parseHex(transparentHex);
  return convertToHex({
    r: (1 - a) * r1 + a * r2,
    g: (1 - a) * g1 + a * g2,
    b: (1 - a) * b1 + a * b2
  });
}

function recolorFilter(hex) {
  const {
    r,
    g,
    b
  } = parseHex(hex);
  return "url(\"data:image/svg+xml,\n    <svg xmlns='http://www.w3.org/2000/svg'>\n      <filter id='recolor'>\n        <feColorMatrix values='\n          0 0 0 0 ".concat(r / 255, "\n          0 0 0 0 ").concat(g / 255, "\n          0 0 0 0 ").concat(b / 255, "\n          0 0 0 1 0\n        '/>\n      </filter>\n    </svg>#recolor\n  \")").split("\n").join("");
}



/***/ }),

/***/ "./src/addons/libraries/thirdparty/cs/tinycolor-min.js":
/*!*************************************************************!*\
  !*** ./src/addons/libraries/thirdparty/cs/tinycolor-min.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// TinyColor v1.4.2
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License
// Modified to use ES6 export
const tinycolor = function (Math) {
  var trimLeft = /^\s+/,
      trimRight = /\s+$/,
      tinyCounter = 0,
      mathRound = Math.round,
      mathMin = Math.min,
      mathMax = Math.max,
      mathRandom = Math.random;

  function tinycolor(color, opts) {
    color = color ? color : '';
    opts = opts || {}; // If input is already a tinycolor, return itself

    if (color instanceof tinycolor) {
      return color;
    } // If we are called as a function, call using new instead


    if (!(this instanceof tinycolor)) {
      return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType; // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`

    if (this._r < 1) {
      this._r = mathRound(this._r);
    }

    if (this._g < 1) {
      this._g = mathRound(this._g);
    }

    if (this._b < 1) {
      this._b = mathRound(this._b);
    }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
  }

  tinycolor.prototype = {
    isDark: function isDark() {
      return this.getBrightness() < 128;
    },
    isLight: function isLight() {
      return !this.isDark();
    },
    isValid: function isValid() {
      return this._ok;
    },
    getOriginalInput: function getOriginalInput() {
      return this._originalInput;
    },
    getFormat: function getFormat() {
      return this._format;
    },
    getAlpha: function getAlpha() {
      return this._a;
    },
    getBrightness: function getBrightness() {
      //http://www.w3.org/TR/AERT#color-contrast
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function getLuminance() {
      //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
      var rgb = this.toRgb();
      var RsRGB, GsRGB, BsRGB, R, G, B;
      RsRGB = rgb.r / 255;
      GsRGB = rgb.g / 255;
      BsRGB = rgb.b / 255;

      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }

      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }

      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }

      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    },
    setAlpha: function setAlpha(value) {
      this._a = boundAlpha(value);
      this._roundA = mathRound(100 * this._a) / 100;
      return this;
    },
    toHsv: function toHsv() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v,
        a: this._a
      };
    },
    toHsvString: function toHsvString() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      var h = mathRound(hsv.h * 360),
          s = mathRound(hsv.s * 100),
          v = mathRound(hsv.v * 100);
      return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
    },
    toHsl: function toHsl() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      return {
        h: hsl.h * 360,
        s: hsl.s,
        l: hsl.l,
        a: this._a
      };
    },
    toHslString: function toHslString() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      var h = mathRound(hsl.h * 360),
          s = mathRound(hsl.s * 100),
          l = mathRound(hsl.l * 100);
      return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
    },
    toHex: function toHex(allow3Char) {
      return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function toHexString(allow3Char) {
      return '#' + this.toHex(allow3Char);
    },
    toHex8: function toHex8(allow4Char) {
      return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function toHex8String(allow4Char) {
      return '#' + this.toHex8(allow4Char);
    },
    toRgb: function toRgb() {
      return {
        r: mathRound(this._r),
        g: mathRound(this._g),
        b: mathRound(this._b),
        a: this._a
      };
    },
    toRgbString: function toRgbString() {
      return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function toPercentageRgb() {
      return {
        r: mathRound(bound01(this._r, 255) * 100) + "%",
        g: mathRound(bound01(this._g, 255) * 100) + "%",
        b: mathRound(bound01(this._b, 255) * 100) + "%",
        a: this._a
      };
    },
    toPercentageRgbString: function toPercentageRgbString() {
      return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function toName() {
      if (this._a === 0) {
        return "transparent";
      }

      if (this._a < 1) {
        return false;
      }

      return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function toFilter(secondColor) {
      var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
      var secondHex8String = hex8String;
      var gradientType = this._gradientType ? "GradientType = 1, " : "";

      if (secondColor) {
        var s = tinycolor(secondColor);
        secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
      }

      return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
    },
    toString: function toString(format) {
      var formatSet = !!format;
      format = format || this._format;
      var formattedString = false;
      var hasAlpha = this._a < 1 && this._a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

      if (needsAlphaFormat) {
        // Special case for "transparent", all other non-alpha formats
        // will return rgba when there is transparency.
        if (format === "name" && this._a === 0) {
          return this.toName();
        }

        return this.toRgbString();
      }

      if (format === "rgb") {
        formattedString = this.toRgbString();
      }

      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }

      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }

      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }

      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }

      if (format === "hex8") {
        formattedString = this.toHex8String();
      }

      if (format === "name") {
        formattedString = this.toName();
      }

      if (format === "hsl") {
        formattedString = this.toHslString();
      }

      if (format === "hsv") {
        formattedString = this.toHsvString();
      }

      return formattedString || this.toHexString();
    },
    clone: function clone() {
      return tinycolor(this.toString());
    },
    _applyModification: function _applyModification(fn, args) {
      var color = fn.apply(null, [this].concat([].slice.call(args)));
      this._r = color._r;
      this._g = color._g;
      this._b = color._b;
      this.setAlpha(color._a);
      return this;
    },
    lighten: function lighten() {
      return this._applyModification(_lighten, arguments);
    },
    brighten: function brighten() {
      return this._applyModification(_brighten, arguments);
    },
    darken: function darken() {
      return this._applyModification(_darken, arguments);
    },
    desaturate: function desaturate() {
      return this._applyModification(_desaturate, arguments);
    },
    saturate: function saturate() {
      return this._applyModification(_saturate, arguments);
    },
    greyscale: function greyscale() {
      return this._applyModification(_greyscale, arguments);
    },
    spin: function spin() {
      return this._applyModification(_spin, arguments);
    },
    _applyCombination: function _applyCombination(fn, args) {
      return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function analogous() {
      return this._applyCombination(_analogous, arguments);
    },
    complement: function complement() {
      return this._applyCombination(_complement, arguments);
    },
    monochromatic: function monochromatic() {
      return this._applyCombination(_monochromatic, arguments);
    },
    splitcomplement: function splitcomplement() {
      return this._applyCombination(_splitcomplement, arguments);
    },
    triad: function triad() {
      return this._applyCombination(_triad, arguments);
    },
    tetrad: function tetrad() {
      return this._applyCombination(_tetrad, arguments);
    }
  }; // If input is an object, force 1 into "1.0" to handle ratios properly
  // String input requires "1.0" as input, so 1 will be treated as 1

  tinycolor.fromRatio = function (color, opts) {
    if (typeof color == "object") {
      var newColor = {};

      for (var i in color) {
        if (color.hasOwnProperty(i)) {
          if (i === "a") {
            newColor[i] = color[i];
          } else {
            newColor[i] = convertToPercentage(color[i]);
          }
        }
      }

      color = newColor;
    }

    return tinycolor(color, opts);
  }; // Given a string or object, convert that input to RGB
  // Possible string inputs:
  //
  //     "red"
  //     "#f00" or "f00"
  //     "#ff0000" or "ff0000"
  //     "#ff000000" or "ff000000"
  //     "rgb 255 0 0" or "rgb (255, 0, 0)"
  //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
  //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
  //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
  //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
  //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
  //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
  //


  function inputToRGB(color) {
    var rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
      color = stringInputToObject(color);
    }

    if (typeof color == "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
        format = "hsl";
      }

      if (color.hasOwnProperty("a")) {
        a = color.a;
      }
    }

    a = boundAlpha(a);
    return {
      ok: ok,
      format: color.format || format,
      r: mathMin(255, mathMax(rgb.r, 0)),
      g: mathMin(255, mathMax(rgb.g, 0)),
      b: mathMin(255, mathMax(rgb.b, 0)),
      a: a
    };
  } // Conversion Functions
  // --------------------
  // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
  // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
  // `rgbToRgb`
  // Handle bounds / percentage checking to conform to CSS color spec
  // <http://www.w3.org/TR/css3-color/>
  // *Assumes:* r, g, b in [0, 255] or [0, 1]
  // *Returns:* { r, g, b } in [0, 255]


  function rgbToRgb(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  } // `rgbToHsl`
  // Converts an RGB color value to HSL.
  // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
  // *Returns:* { h, s, l } in [0,1]


  function rgbToHsl(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = mathMax(r, g, b),
        min = mathMin(r, g, b);
    var h,
        s,
        l = (max + min) / 2;

    if (max == min) {
      h = s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h,
      s: s,
      l: l
    };
  } // `hslToRgb`
  // Converts an HSL color value to RGB.
  // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
  // *Returns:* { r, g, b } in the set [0, 255]


  function hslToRgb(h, s, l) {
    var r, g, b;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  } // `rgbToHsv`
  // Converts an RGB color value to HSV
  // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
  // *Returns:* { h, s, v } in [0,1]


  function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = mathMax(r, g, b),
        min = mathMin(r, g, b);
    var h,
        s,
        v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max == min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h,
      s: s,
      v: v
    };
  } // `hsvToRgb`
  // Converts an HSV color value to RGB.
  // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
  // *Returns:* { r, g, b } in the set [0, 255]


  function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  } // `rgbToHex`
  // Converts an RGB color to hex
  // Assumes r, g, and b are contained in the set [0, 255]
  // Returns a 3 or 6 character hex


  function rgbToHex(r, g, b, allow3Char) {
    var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))]; // Return a 3 character hex if possible

    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
  } // `rgbaToHex`
  // Converts an RGBA color plus alpha transparency to hex
  // Assumes r, g, b are contained in the set [0, 255] and
  // a in [0, 1]. Returns a 4 or 8 character rgba hex


  function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a))]; // Return a 4 character hex if possible

    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
  } // `rgbaToArgbHex`
  // Converts an RGBA color to an ARGB Hex8 string
  // Rarely used, but required for "toFilter()"


  function rgbaToArgbHex(r, g, b, a) {
    var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];
    return hex.join("");
  } // `equals`
  // Can be called with any tinycolor input


  tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) {
      return false;
    }

    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
  };

  tinycolor.random = function () {
    return tinycolor.fromRatio({
      r: mathRandom(),
      g: mathRandom(),
      b: mathRandom()
    });
  }; // Modification Functions
  // ----------------------
  // Thanks to less.js for some of the basics here
  // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>


  function _desaturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }

  function _saturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }

  function _greyscale(color) {
    return tinycolor(color).desaturate(100);
  }

  function _lighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  }

  function _brighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
    return tinycolor(rgb);
  }

  function _darken(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  } // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
  // Values outside of this range will be wrapped into this range.


  function _spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
  } // Combination Functions
  // ---------------------
  // Thanks to jQuery xColor for some of the ideas behind these
  // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>


  function _complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
  }

  function _triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 120) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 240) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }

  function _tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 90) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 180) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 270) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }

  function _splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }

  function _analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;
    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(tinycolor(hsl));
    }

    return ret;
  }

  function _monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h,
        s = hsv.s,
        v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
      ret.push(tinycolor({
        h: h,
        s: s,
        v: v
      }));
      v = (v + modification) % 1;
    }

    return ret;
  } // Utility Functions
  // ---------------------


  tinycolor.mix = function (color1, color2, amount) {
    amount = amount === 0 ? 0 : amount || 50;
    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();
    var p = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return tinycolor(rgba);
  }; // Readability Functions
  // ---------------------
  // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
  // `contrast`
  // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)


  tinycolor.readability = function (color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
  }; // `isReadable`
  // Ensure that foreground and background color combinations meet WCAG2 guidelines.
  // The third argument is an optional Object.
  //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
  //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
  // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
  // *Example*
  //    tinycolor.isReadable("#000", "#111") => false
  //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false


  tinycolor.isReadable = function (color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;
    out = false;
    wcag2Parms = validateWCAG2Parms(wcag2);

    switch (wcag2Parms.level + wcag2Parms.size) {
      case "AAsmall":
      case "AAAlarge":
        out = readability >= 4.5;
        break;

      case "AAlarge":
        out = readability >= 3;
        break;

      case "AAAsmall":
        out = readability >= 7;
        break;
    }

    return out;
  }; // `mostReadable`
  // Given a base color and a list of possible foreground or background
  // colors for that base, returns the most readable color.
  // Optionally returns Black or White if the most readable color is unreadable.
  // *Example*
  //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
  //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
  //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
  //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"


  tinycolor.mostReadable = function (baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors;
    level = args.level;
    size = args.size;

    for (var i = 0; i < colorList.length; i++) {
      readability = tinycolor.readability(baseColor, colorList[i]);

      if (readability > bestScore) {
        bestScore = readability;
        bestColor = tinycolor(colorList[i]);
      }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {
      "level": level,
      "size": size
    }) || !includeFallbackColors) {
      return bestColor;
    } else {
      args.includeFallbackColors = false;
      return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
    }
  }; // Big List of Colors
  // ------------------
  // <http://www.w3.org/TR/css3-color/#svg-color>


  var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  }; // Make it easy to access colors via `hexNames[hex]`

  var hexNames = tinycolor.hexNames = flip(names); // Utilities
  // ---------
  // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`

  function flip(o) {
    var flipped = {};

    for (var i in o) {
      if (o.hasOwnProperty(i)) {
        flipped[o[i]] = i;
      }
    }

    return flipped;
  } // Return a valid alpha value [0,1] with all invalid values being set to 1


  function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }

    return a;
  } // Take input from [0, n] and return it as [0, 1]


  function bound01(n, max) {
    if (isOnePointZero(n)) {
      n = "100%";
    }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n))); // Automatically convert percentage into number

    if (processPercent) {
      n = parseInt(n * max, 10) / 100;
    } // Handle floating point rounding errors


    if (Math.abs(n - max) < 0.000001) {
      return 1;
    } // Convert into [0, 1] range if it isn't already


    return n % max / parseFloat(max);
  } // Force a number between 0 and 1


  function clamp01(val) {
    return mathMin(1, mathMax(0, val));
  } // Parse a base-16 hex value into a base-10 integer


  function parseIntFromHex(val) {
    return parseInt(val, 16);
  } // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
  // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>


  function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
  } // Check to see if string passed in is a percentage


  function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
  } // Force a hex value to have 2 characters


  function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
  } // Replace a decimal with it's percentage value


  function convertToPercentage(n) {
    if (n <= 1) {
      n = n * 100 + "%";
    }

    return n;
  } // Converts a decimal to a hex value


  function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
  } // Converts a hex value to a decimal


  function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
  }

  var matchers = function () {
    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?"; // <http://www.w3.org/TR/css3-values/#number-value>

    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?"; // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.

    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")"; // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren

    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    return {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
  }(); // `isValidCSSUnit`
  // Take in a single string / number and check to see if it looks like a CSS unit
  // (see `matchers` above for definition).


  function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
  } // `stringInputToObject`
  // Permissive string parsing.  Take in a number of formats, and output an object
  // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`


  function stringInputToObject(color) {
    color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
    var named = false;

    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color == 'transparent') {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
      };
    } // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.


    var match;

    if (match = matchers.rgb.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3]
      };
    }

    if (match = matchers.rgba.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
      };
    }

    if (match = matchers.hsl.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3]
      };
    }

    if (match = matchers.hsla.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
      };
    }

    if (match = matchers.hsv.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3]
      };
    }

    if (match = matchers.hsva.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
      };
    }

    if (match = matchers.hex8.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? "name" : "hex8"
      };
    }

    if (match = matchers.hex6.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? "name" : "hex"
      };
    }

    if (match = matchers.hex4.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + '' + match[1]),
        g: parseIntFromHex(match[2] + '' + match[2]),
        b: parseIntFromHex(match[3] + '' + match[3]),
        a: convertHexToDecimal(match[4] + '' + match[4]),
        format: named ? "name" : "hex8"
      };
    }

    if (match = matchers.hex3.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + '' + match[1]),
        g: parseIntFromHex(match[2] + '' + match[2]),
        b: parseIntFromHex(match[3] + '' + match[3]),
        format: named ? "name" : "hex"
      };
    }

    return false;
  }

  function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {
      "level": "AA",
      "size": "small"
    };
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();

    if (level !== "AA" && level !== "AAA") {
      level = "AA";
    }

    if (size !== "small" && size !== "large") {
      size = "small";
    }

    return {
      "level": level,
      "size": size
    };
  }
  /*// Node: Export function
  if (typeof module !== "undefined" && module.exports) {
      module.exports = tinycolor;
  }
  // AMD/requirejs: Define the module
  else if (typeof define === 'function' && define.amd) {
      define(function () {return tinycolor;});
  }
  // Browser: Expose to window
  else {
      window.tinycolor = tinycolor;
  }*/


  return tinycolor;
}(Math);

/* harmony default export */ __webpack_exports__["default"] = (tinycolor);

/***/ })

}]);
//# sourceMappingURL=addons.js.map